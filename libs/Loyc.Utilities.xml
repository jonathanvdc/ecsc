<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Loyc.Utilities</name>
    </assembly>
    <members>
        <member name="T:Loyc.Geometry.BoundingBoxMath">
            <summary>Math and extension methods for <see cref="T:Loyc.Geometry.BoundingBox`1"/>.</summary>
            <remarks>This contains many methods that could be considered "core" methods.
            they are implemented as extension methods instead for performance reasons,
            because as a generic class, <see cref="T:Loyc.Geometry.BoundingBox`1"/> cannot do 
            arithmetic quickly.</remarks>
        </member>
        <member name="T:Loyc.Geometry.LineMath">
            <summary>Contains algorithms that operate on lines.</summary>
        </member>
        <member name="M:Loyc.Geometry.LineMath.SimplifyPolyline``1(``0,System.Collections.Generic.ICollection{Loyc.Geometry.Point{System.Single}},System.Single)">
            <summary>Simplifies a polyline using the Douglas-Peucker line 
            simplification algorithm. This algorithm removes points that are 
            deemed unimportant; the output is a subset of the input.</summary>
            <typeparam name="List">Original unsimplified polyline</typeparam>
            <param name="output">The output polyline is added in order to this collection</param>
            <param name="tolerance">The distance between the input polyline and the 
            output polyline will never exceed this distance. Increase this value to 
            simplify more aggressively.</param>
            <returns>The number of output points.</returns>
            <remarks>
            The average time complexity of this algorithm is O(N log N). 
            The worst-case time complexity is O(N^2).
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.SimplifyPolyline``1(``0,System.Collections.Generic.ICollection{Loyc.Geometry.Point{System.Double}},System.Double)">
            <inheritdoc cref="M:Loyc.Geometry.LineMath.SimplifyPolyline``1(``0,System.Collections.Generic.ICollection{Loyc.Geometry.Point{System.Single}},System.Single)"/>
        </member>
        <member name="M:Loyc.Geometry.LineMath.ProjectOnto(Loyc.Geometry.Point{System.Single},Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType)">
            <summary>Performs projection, which finds the point on a line segment 
            or infinite line that is nearest to a specified point.</summary>
            <param name="seg">The line segment</param>
            <param name="p">The test point to be projected</param>
            <param name="infiniteLine">Whether to extend the line infinitely.</param>
            <param name="end">Set to 0 if the point is on the line segment (including
            one of the endpoints), -1 if the point is before seg.A, 1 if the point is 
            after seg.B, and null if the line segment is degenerate (seg.A==seg.B)</param>
            <returns>The projected point.</returns>
            <remarks>
            This algorithm is fast and accurate, and can be easily adapted to 3D.
            A special advantage of this approach is that it runs fastest when the 
            point is projected onto one of the endpoints (when infiniteLine is 
            false).
            <para/>
            Algorithm comes from: http://geomalgorithms.com/a02-_lines.html
            See section "Distance of a Point to a Ray or Segment"
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.GetFractionAlong(Loyc.Geometry.Point{System.Single},Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType)">
            <summary>Gets the projection of a point onto a line, expressed as a 
            fraction where 0 represents the start of the line and 1 represents the 
            end of the line.</summary>
            <param name="infiniteLine">Whether to return numbers outside the range
            (0, 1) if the projection is outside the line segment. If this is false,
            the result is clamped to (0, 1)</param>
            <param name="end">Same as for <see cref="M:Loyc.Geometry.LineMath.ProjectOnto(Loyc.Geometry.Point{System.Single},Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType)"/>.</param>
            <returns>The fraction of p along seg, as explained already. If seg is
            zero-length, the result is always 0.</returns>
            <remarks>This method uses the same technique as <see cref="M:Loyc.Geometry.LineMath.ProjectOnto(Loyc.Geometry.Point{System.Single},Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType)"/>.</remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.PointAlong(Loyc.Geometry.LineSegment{System.Single},System.Single)">
            <summary>Given a fraction between zero and one, calculates a point 
            between two points (0=point A, 1=point B, 0.5=midpoint).</summary>
            <remarks>If you just want the midpoint, call Midpoint() which 
            is faster. If the fraction is outside the range [0,1], the result
            will be along the infinite extension of the line. If the two points
            are the same, this method always returns the same point as long as
            the math doesn't overflow, possibly with slight deviations caused 
            by floating-point rounding.</remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.Midpoint(Loyc.Geometry.LineSegment{System.Single})">
            <summary>Returns the midpoint, (A + B) >> 1.</summary>
        </member>
        <member name="M:Loyc.Geometry.LineMath.ComputeIntersection(Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType,System.Single@,Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType,System.Single@)">
            <summary>Computes the location that lines, rays or line segments 
            intersect, expressed as a fraction of the distance along each 
            LineSegment.</summary>
            <param name="P">First line segment</param>
            <param name="pType">Type of line P (Segment, Ray, Infinite)</param>
            <param name="pFrac">Fraction along P of the intersection point. If this
            method returns false, pFrac is still computed. If the hypothetical
            intersection point of the infinite extension of P and Q is beyond the 
            P.A side of the line, pFrac is set to an appropriate negative value if 
            pType is Infinite and 0 otherwise. If the hypothetical intersection
            is on the P.B side of the line, pFrac is set to 1 if pType is Segment
            and a value above 1 otherwise.</param>
            <param name="Q">Second line segment</param>
            <param name="qType">Type of line Q (Segment, Ray, Infinite)</param>
            <param name="qFrac">Fraction along Q of the intersection point. If this
            method returns false, qFrac may be <c>NaN</c> if the analysis of line
            P already determined that pFrac is beyond the range of line P. In other 
            words, if Q is assumed to be an infinite line and P still does not 
            intersect with Q, qFrac is set to NaN because the method aborts 
            analysis to avoid wasting CPU time. On the other hand, if this method 
            determines that P might intersect with Q, but a full analysis shows 
            that it does not, the method returns false and sets qFrac to a real 
            number. qFrac is set to 0 if the intersection point of the infinite 
            extension of Q is on the Q.A side of the line, and 1 if the 
            intersection point is on the Q.B side of the line.</param>
            <returns>True if the lines intersect, false otherwise.</returns>
            <remarks>
            This method does not do a bounding-box check. If you are doing 
            calculations with line segments and you expect the majority of your
            intersection calculations to return false, you may save time by 
            testing whether the bounding boxes of the lines overlap before calling 
            this method.
            <para/>
            If the input segments contain NaNs, the result is false and pFrac/qFrac
            will be NaN.
            <para/>
            If the either of the line segments are degenerate (single points), 
            overlap can still be detected and the LineType of the degenerate line
            has no effect; the degenerate line is always treated as a point.
            If both lines are points, the method will return true iff they are the
            same point, and if true is returned, pFrac will be 0.5f
            <para/>
            The output fractions pFrac and qFrac will be infinite if the magnitude 
            of the result overflows.
            <para/>
            If the two line segments are parallel but do not overlap, this method
            returns false; pFrac and qFrac are both set to NaN. If the two lines 
            are parallel and overlap, a region of overlap is detected and pFrac
            and qFrac refer to the center of this region of overlap. If, in this
            case, P and/or Q are rays or infinite lines, this method behaves as
            though P and/or Q are extended to cover each other. For instance, 
            suppose that P and Q are lines on the X axis, P.A.X=0, P.B.X=6, 
            Q.A.X=10, Q.B.X=16:
            <pre>
                   P.A---------------P.B         Q.B---------------------Q.A
            -2  -1  0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17
            </pre>
            If P and Q are both line segments, there is no overlap and this method 
            will return false. However, if Q is a Ray or an infinite line, it 
            extends toward negative infinity and the minimum overlap between the 
            lines is 0..6. In this case, the region of overlap is considered to be 
            0..6 if P is a line segment, and 0..16 if P is a ray or an infinite 
            line. If P is a line segment, the midpoint is 3, and pFrac will be set
            to 0.5, halfway along the line, while qFrac will be 2.333. If P is a 
            ray or an infinite line, the midpoint is 8, pFrac will be 1.333, and
            qFrac will be 1.333.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.ComputeIntersection(Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType,Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType)">
            <summary>Computes the intersection point between two lines, rays or 
            line segments.</summary>
            <remarks>This method is implemented based on the other overload,
            <see cref="!:ComputeIntersection(LineSegment P, LineType pType, out T pFrac, LineSegment Q, LineType qType, out T qFrac)"/>.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.ClipTo(Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.BoundingBox{System.Single})">
            <summary>Quickly clips a line to a bounding box.</summary>
            <returns>A clipped line, or null if the line was outside the bounding box.</returns>
            <remarks>If the bounding box is not normalized (min > max), the result is undefined.</remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.ProjectOnto(Loyc.Geometry.Point{System.Double},Loyc.Geometry.LineSegment{System.Double},Loyc.Geometry.LineType)">
            <summary>Performs projection, which finds the point on a line segment 
            or infinite line that is nearest to a specified point.</summary>
            <param name="seg">The line segment</param>
            <param name="p">The test point to be projected</param>
            <param name="infiniteLine">Whether to extend the line infinitely.</param>
            <param name="end">Set to 0 if the point is on the line segment (including
            one of the endpoints), -1 if the point is before seg.A, 1 if the point is 
            after seg.B, and null if the line segment is degenerate (seg.A==seg.B)</param>
            <returns>The projected point.</returns>
            <remarks>
            This algorithm is fast and accurate, and can be easily adapted to 3D.
            A special advantage of this approach is that it runs fastest when the 
            point is projected onto one of the endpoints (when infiniteLine is 
            false).
            <para/>
            Algorithm comes from: http://geomalgorithms.com/a02-_lines.html
            See section "Distance of a Point to a Ray or Segment"
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.GetFractionAlong(Loyc.Geometry.Point{System.Double},Loyc.Geometry.LineSegment{System.Double},Loyc.Geometry.LineType)">
            <summary>Gets the projection of a point onto a line, expressed as a 
            fraction where 0 represents the start of the line and 1 represents the 
            end of the line.</summary>
            <param name="infiniteLine">Whether to return numbers outside the range
            (0, 1) if the projection is outside the line segment. If this is false,
            the result is clamped to (0, 1)</param>
            <param name="end">Same as for <see cref="M:Loyc.Geometry.LineMath.ProjectOnto(Loyc.Geometry.Point{System.Single},Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType)"/>.</param>
            <returns>The fraction of p along seg, as explained already. If seg is
            zero-length, the result is always 0.</returns>
            <remarks>This method uses the same technique as <see cref="M:Loyc.Geometry.LineMath.ProjectOnto(Loyc.Geometry.Point{System.Single},Loyc.Geometry.LineSegment{System.Single},Loyc.Geometry.LineType)"/>.</remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.PointAlong(Loyc.Geometry.LineSegment{System.Double},System.Double)">
            <summary>Given a fraction between zero and one, calculates a point 
            between two points (0=point A, 1=point B, 0.5=midpoint).</summary>
            <remarks>If you just want the midpoint, call Midpoint() which 
            is faster. If the fraction is outside the range [0,1], the result
            will be along the infinite extension of the line. If the two points
            are the same, this method always returns the same point as long as
            the math doesn't overflow, possibly with slight deviations caused 
            by floating-point rounding.</remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.Midpoint(Loyc.Geometry.LineSegment{System.Double})">
            <summary>Returns the midpoint, (A + B) >> 1.</summary>
        </member>
        <member name="M:Loyc.Geometry.LineMath.ComputeIntersection(Loyc.Geometry.LineSegment{System.Double},Loyc.Geometry.LineType,System.Double@,Loyc.Geometry.LineSegment{System.Double},Loyc.Geometry.LineType,System.Double@)">
            <summary>Computes the location that lines, rays or line segments 
            intersect, expressed as a fraction of the distance along each 
            LineSegment.</summary>
            <param name="P">First line segment</param>
            <param name="pType">Type of line P (Segment, Ray, Infinite)</param>
            <param name="pFrac">Fraction along P of the intersection point. If this
            method returns false, pFrac is still computed. If the hypothetical
            intersection point of the infinite extension of P and Q is beyond the 
            P.A side of the line, pFrac is set to an appropriate negative value if 
            pType is Infinite and 0 otherwise. If the hypothetical intersection
            is on the P.B side of the line, pFrac is set to 1 if pType is Segment
            and a value above 1 otherwise.</param>
            <param name="Q">Second line segment</param>
            <param name="qType">Type of line Q (Segment, Ray, Infinite)</param>
            <param name="qFrac">Fraction along Q of the intersection point. If this
            method returns false, qFrac may be <c>NaN</c> if the analysis of line
            P already determined that pFrac is beyond the range of line P. In other 
            words, if Q is assumed to be an infinite line and P still does not 
            intersect with Q, qFrac is set to NaN because the method aborts 
            analysis to avoid wasting CPU time. On the other hand, if this method 
            determines that P might intersect with Q, but a full analysis shows 
            that it does not, the method returns false and sets qFrac to a real 
            number. qFrac is set to 0 if the intersection point of the infinite 
            extension of Q is on the Q.A side of the line, and 1 if the 
            intersection point is on the Q.B side of the line.</param>
            <returns>True if the lines intersect, false otherwise.</returns>
            <remarks>
            This method does not do a bounding-box check. If you are doing 
            calculations with line segments and you expect the majority of your
            intersection calculations to return false, you may save time by 
            testing whether the bounding boxes of the lines overlap before calling 
            this method.
            <para/>
            If the input segments contain NaNs, the result is false and pFrac/qFrac
            will be NaN.
            <para/>
            If the either of the line segments are degenerate (single points), 
            overlap can still be detected and the LineType of the degenerate line
            has no effect; the degenerate line is always treated as a point.
            If both lines are points, the method will return true iff they are the
            same point, and if true is returned, pFrac will be 0.5f
            <para/>
            The output fractions pFrac and qFrac will be infinite if the magnitude 
            of the result overflows.
            <para/>
            If the two line segments are parallel but do not overlap, this method
            returns false; pFrac and qFrac are both set to NaN. If the two lines 
            are parallel and overlap, a region of overlap is detected and pFrac
            and qFrac refer to the center of this region of overlap. If, in this
            case, P and/or Q are rays or infinite lines, this method behaves as
            though P and/or Q are extended to cover each other. For instance, 
            suppose that P and Q are lines on the X axis, P.A.X=0, P.B.X=6, 
            Q.A.X=10, Q.B.X=16:
            <pre>
                   P.A---------------P.B         Q.B---------------------Q.A
            -2  -1  0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17
            </pre>
            If P and Q are both line segments, there is no overlap and this method 
            will return false. However, if Q is a Ray or an infinite line, it 
            extends toward negative infinity and the minimum overlap between the 
            lines is 0..6. In this case, the region of overlap is considered to be 
            0..6 if P is a line segment, and 0..16 if P is a ray or an infinite 
            line. If P is a line segment, the midpoint is 3, and pFrac will be set
            to 0.5, halfway along the line, while qFrac will be 2.333. If P is a 
            ray or an infinite line, the midpoint is 8, pFrac will be 1.333, and
            qFrac will be 1.333.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.ComputeIntersection(Loyc.Geometry.LineSegment{System.Double},Loyc.Geometry.LineType,Loyc.Geometry.LineSegment{System.Double},Loyc.Geometry.LineType)">
            <summary>Computes the intersection point between two lines, rays or 
            line segments.</summary>
            <remarks>This method is implemented based on the other overload,
            <see cref="!:ComputeIntersection(LineSegment P, LineType pType, out T pFrac, LineSegment Q, LineType qType, out T qFrac)"/>.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.LineMath.ClipTo(Loyc.Geometry.LineSegment{System.Double},Loyc.Geometry.BoundingBox{System.Double})">
            <summary>Quickly clips a line to a bounding box.</summary>
            <returns>A clipped line, or null if the line was outside the bounding box.</returns>
            <remarks>If the bounding box is not normalized (min > max), the result is undefined.</remarks>
        </member>
        <member name="T:Loyc.Geometry.LineType">
            <summary>Indicates how a <see cref="T:Loyc.Geometry.LineSegment`1"/> should be treated in
            a math algorithm: as a segment (the default), as a ray originating at A 
            (extending B infinitely), or as an line that is infinite in both directions.</summary>
        </member>
        <member name="T:Loyc.Geometry.PointMath">
            <summary>Math and extension methods for <see cref="T:Loyc.Geometry.Point`1"/>.</summary>
            <remarks>This contains many methods that should be considered "core" 
            functionality, including many methods such as Add(), Sub() and Mul() that 
            would ordinarily be implemented as operators (+ - *) if it weren't for 
            limitations of C#. These operations are implemented as extension methods for 
            performance reasons, because as a generic class, <see cref="T:Loyc.Geometry.Point`1"/> 
            cannot do arithmetic quickly. The extension methods provide operations that 
            are optimized for specific data types (currently int, float and double).</remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Cross``1(Loyc.Geometry.Vector{``0},Loyc.Geometry.Vector{``0})">
            <summary>Computes the "cross product" of a pair of vectors.</summary>
            <remarks>
            This is not a general cross product, as cross product is only a 3D concept,
            but this operator acts as though the two points were in the Z=0 plane and
            returns the Z coordinate of the cross product: b.X * a.Y - b.Y * a.X.
            This value is zero if the vectors are parallel; it is a.Length * b.Length 
            or -a.Length * b.Length if the vectors are perpendicular. One use of 
            cross product is to determine whether the angle between two lines is greater 
            or less than 180 degrees, corresponding to return values less or greater than 
            zero.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Rot90``1(Loyc.Geometry.Vector{``0})">
            <summary>Rotates a vector 90 degrees.</summary>
            <remarks>
            Rotatation is clockwise if increasing Y goes downward, counter-
            clockwise if increasing Y goes upward. If the vector represents the 
            direction of a line, the result also represents the coefficients 
            (a,b) of the implicit line equation aX + bY + c = 0.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Quadrance``1(Loyc.Geometry.Vector{``0})">
            <summary>Gets the square of the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Length``1(Loyc.Geometry.Vector{``0})">
            <summary>Gets the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Angle``1(Loyc.Geometry.Vector{``0})">
            <summary>Gets the angle from 0 to 2*PI of the vector, where (1,0) has 
            angle 0 and (0,1) has angle PI/2.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Vector``1(Loyc.Geometry.LineSegment{``0})">
            <summary>Returns the vector from A to B (seg.B - seg.A)</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.HalfwayTo``1(Loyc.Geometry.Point{``0},Loyc.Geometry.Point{``0})">
            <summary>Returns the midpoint between A and B ((a + b) / 2)</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsBCL(Loyc.Geometry.Point{System.Int32})">
            <summary>Converts a Loyc point to BCL type.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsBCL(Loyc.Geometry.Vector{System.Int32})">
            <summary>Converts a Loyc vector to BCL type.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsBCL(Loyc.Geometry.Point{System.Single})">
            <summary>Converts a Loyc point to BCL type.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsBCL(Loyc.Geometry.Vector{System.Single})">
            <summary>Converts a Loyc vector to BCL type.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsBCL(Loyc.Geometry.Point{System.Double})">
            <summary>Converts a Loyc point to BCL type.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsBCL(Loyc.Geometry.Vector{System.Double})">
            <summary>Converts a Loyc vector to BCL type.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsLoyc(System.Drawing.Point)">
            <summary>Converts a BCL point to a Loyc point.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsLoyc(System.Drawing.PointF)">
            <summary>Converts a BCL point to a Loyc point.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsLoyc(System.Windows.Point)">
            <summary>Converts a BCL point to a Loyc point.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsLoyc(System.Windows.Vector)">
            <summary>Converts a BCL Vector to a Loyc point.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsLoycVector(System.Drawing.Point)">
            <summary>Converts a BCL point to a Loyc vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsLoycVector(System.Drawing.PointF)">
            <summary>Converts a BCL point to a Loyc vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AsLoycVector(System.Windows.Point)">
            <summary>Converts a BCL point to a Loyc vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.To``1(Loyc.Geometry.Point{``0},Loyc.Geometry.Point{``0})">
            <summary>Constructs a <see cref="T:Loyc.Geometry.LineSegment`1"/> from two points.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Abs``1(Loyc.Geometry.Vector{``0})">
            <summary>Gets the absolute value of vector's individual components.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Abs``1(Loyc.Geometry.Vector3{``0})">
            <summary>Gets the absolute value of vector's individual components.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Dot(Loyc.Geometry.Vector{System.Int32},Loyc.Geometry.Vector{System.Int32})">
            <summary>Dot product. a*b equals lhs.Length*rhs.Length*Cos(theta) if theta 
            is the angle between two vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Cross(Loyc.Geometry.Vector{System.Int32},Loyc.Geometry.Vector{System.Int32})">
            <summary>Computes the "cross product" of a pair of 2D vectors.</summary>
            <remarks>
            This is not a general cross product, as cross product is only a 3D concept,
            but this operator acts as though the two points were in the Z=0 plane and
            returns the Z coordinate of the cross product: b.X * a.Y - b.Y * a.X.
            This value is zero if the vectors are parallel; it is a.Length * b.Length 
            or -a.Length * b.Length if the vectors are perpendicular. One use of 
            cross product is to determine whether the angle between two lines is greater 
            or less than 180 degrees, corresponding to return values less or greater than 
            zero.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Cross(Loyc.Geometry.Vector3{System.Int32},Loyc.Geometry.Vector3{System.Int32})">
            <summary>Computes the cross product of a pair of 3D vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Rot90(Loyc.Geometry.Vector{System.Int32})">
            <summary>Rotates a vector 90 degrees.</summary>
            <remarks>
            Rotatation is clockwise if increasing Y goes downward, counter-
            clockwise if increasing Y goes upward. If the vector represents the 
            direction of a line, the result also represents the coefficients 
            (a,b) of the implicit line equation aX + bY + c = 0.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Neg(Loyc.Geometry.Vector{System.Int32})">
            <summary>Reverses a vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Neg(Loyc.Geometry.Vector3{System.Int32})">
            <summary>Reverses a vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Quadrance(Loyc.Geometry.Vector{System.Int32})">
            <summary>Gets the square of the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Length(Loyc.Geometry.Vector{System.Int32})">
            <summary>Gets the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Angle(Loyc.Geometry.Vector{System.Int32})">
            <summary>Gets the angle from 0 to 2*PI of the vector, where (1,0) has 
            angle 0 and (0,1) has angle PI/2.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AngleDeg(Loyc.Geometry.Vector{System.Int32})">
            <summary>Gets the angle from 0 to 360 of the vector, where (1,0) has 
            angle 0 and (0,1) has angle 90.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Vector(Loyc.Geometry.LineSegment{System.Int32})">
            <summary>Returns seg.B - seg.A.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Abs(Loyc.Geometry.Vector{System.Int32})">
            <summary>Gets the absolute value of the vector's individual components.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Abs(Loyc.Geometry.Vector3{System.Int32})">
            <summary>Gets the absolute value of the vector's individual components.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.ComputeConvexHull(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Int32}})">
            <summary>Computes the convex hull of a polygon, in clockwise order in a Y-up 
            coordinate system (counterclockwise in a Y-down coordinate system).</summary>
            <remarks>Uses the Monotone Chain algorithm, a.k.a. Andrew's Algorithm.</remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Dot(Loyc.Geometry.Vector{System.Single},Loyc.Geometry.Vector{System.Single})">
            <summary>Dot product. a*b equals lhs.Length*rhs.Length*Cos(theta) if theta 
            is the angle between two vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Cross(Loyc.Geometry.Vector{System.Single},Loyc.Geometry.Vector{System.Single})">
            <summary>Computes the "cross product" of a pair of 2D vectors.</summary>
            <remarks>
            This is not a general cross product, as cross product is only a 3D concept,
            but this operator acts as though the two points were in the Z=0 plane and
            returns the Z coordinate of the cross product: b.X * a.Y - b.Y * a.X.
            This value is zero if the vectors are parallel; it is a.Length * b.Length 
            or -a.Length * b.Length if the vectors are perpendicular. One use of 
            cross product is to determine whether the angle between two lines is greater 
            or less than 180 degrees, corresponding to return values less or greater than 
            zero.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Cross(Loyc.Geometry.Vector3{System.Single},Loyc.Geometry.Vector3{System.Single})">
            <summary>Computes the cross product of a pair of 3D vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Rot90(Loyc.Geometry.Vector{System.Single})">
            <summary>Rotates a vector 90 degrees.</summary>
            <remarks>
            Rotatation is clockwise if increasing Y goes downward, counter-
            clockwise if increasing Y goes upward. If the vector represents the 
            direction of a line, the result also represents the coefficients 
            (a,b) of the implicit line equation aX + bY + c = 0.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Neg(Loyc.Geometry.Vector{System.Single})">
            <summary>Reverses a vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Neg(Loyc.Geometry.Vector3{System.Single})">
            <summary>Reverses a vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Quadrance(Loyc.Geometry.Vector{System.Single})">
            <summary>Gets the square of the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Length(Loyc.Geometry.Vector{System.Single})">
            <summary>Gets the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Angle(Loyc.Geometry.Vector{System.Single})">
            <summary>Gets the angle from 0 to 2*PI of the vector, where (1,0) has 
            angle 0 and (0,1) has angle PI/2.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AngleDeg(Loyc.Geometry.Vector{System.Single})">
            <summary>Gets the angle from 0 to 360 of the vector, where (1,0) has 
            angle 0 and (0,1) has angle 90.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Vector(Loyc.Geometry.LineSegment{System.Single})">
            <summary>Returns seg.B - seg.A.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Abs(Loyc.Geometry.Vector{System.Single})">
            <summary>Gets the absolute value of the vector's individual components.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Abs(Loyc.Geometry.Vector3{System.Single})">
            <summary>Gets the absolute value of the vector's individual components.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.ComputeConvexHull(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Single}})">
            <summary>Computes the convex hull of a polygon, in clockwise order in a Y-up 
            coordinate system (counterclockwise in a Y-down coordinate system).</summary>
            <remarks>Uses the Monotone Chain algorithm, a.k.a. Andrew's Algorithm.</remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Dot(Loyc.Geometry.Vector{System.Double},Loyc.Geometry.Vector{System.Double})">
            <summary>Dot product. a*b equals lhs.Length*rhs.Length*Cos(theta) if theta 
            is the angle between two vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Cross(Loyc.Geometry.Vector{System.Double},Loyc.Geometry.Vector{System.Double})">
            <summary>Computes the "cross product" of a pair of 2D vectors.</summary>
            <remarks>
            This is not a general cross product, as cross product is only a 3D concept,
            but this operator acts as though the two points were in the Z=0 plane and
            returns the Z coordinate of the cross product: b.X * a.Y - b.Y * a.X.
            This value is zero if the vectors are parallel; it is a.Length * b.Length 
            or -a.Length * b.Length if the vectors are perpendicular. One use of 
            cross product is to determine whether the angle between two lines is greater 
            or less than 180 degrees, corresponding to return values less or greater than 
            zero.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Cross(Loyc.Geometry.Vector3{System.Double},Loyc.Geometry.Vector3{System.Double})">
            <summary>Computes the cross product of a pair of 3D vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Rot90(Loyc.Geometry.Vector{System.Double})">
            <summary>Rotates a vector 90 degrees.</summary>
            <remarks>
            Rotatation is clockwise if increasing Y goes downward, counter-
            clockwise if increasing Y goes upward. If the vector represents the 
            direction of a line, the result also represents the coefficients 
            (a,b) of the implicit line equation aX + bY + c = 0.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Neg(Loyc.Geometry.Vector{System.Double})">
            <summary>Reverses a vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Neg(Loyc.Geometry.Vector3{System.Double})">
            <summary>Reverses a vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Quadrance(Loyc.Geometry.Vector{System.Double})">
            <summary>Gets the square of the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Length(Loyc.Geometry.Vector{System.Double})">
            <summary>Gets the length of the vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Angle(Loyc.Geometry.Vector{System.Double})">
            <summary>Gets the angle from 0 to 2*PI of the vector, where (1,0) has 
            angle 0 and (0,1) has angle PI/2.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.AngleDeg(Loyc.Geometry.Vector{System.Double})">
            <summary>Gets the angle from 0 to 360 of the vector, where (1,0) has 
            angle 0 and (0,1) has angle 90.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Vector(Loyc.Geometry.LineSegment{System.Double})">
            <summary>Returns seg.B - seg.A.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Abs(Loyc.Geometry.Vector{System.Double})">
            <summary>Gets the absolute value of the vector's individual components.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.Abs(Loyc.Geometry.Vector3{System.Double})">
            <summary>Gets the absolute value of the vector's individual components.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointMath.ComputeConvexHull(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Double}})">
            <summary>Computes the convex hull of a polygon, in clockwise order in a Y-up 
            coordinate system (counterclockwise in a Y-down coordinate system).</summary>
            <remarks>Uses the Monotone Chain algorithm, a.k.a. Andrew's Algorithm.</remarks>
        </member>
        <member name="T:Loyc.Geometry.PolygonMath">
            <summary>
            Contains useful basic polygon algorithms: hit testing, area calculation,
            orientation detection.
            </summary>
            <summary>
            Contains useful basic polygon algorithms: hit testing, area calculation,
            orientation detection.
            </summary>
            <summary>
            Contains useful basic polygon algorithms: hit testing, area calculation,
            orientation detection.
            </summary>
            <summary>
            Contains useful basic polygon algorithms: hit testing, area calculation,
            orientation detection.
            </summary>
            <summary>
            Contains useful basic polygon algorithms: hit testing, area calculation,
            orientation detection.
            </summary>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.PolygonArea(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Int32}})">
            <summary>Computes the area of a polygon.</summary>
            <returns>The area. The result is positive if the polygon is clockwise 
            (assuming a coordinate system in which increasing Y goes upward), or 
            negative if the polygon is counterclockwise.</returns>
            <remarks>http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.Orientation(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Int32}})">
            <summary>Returns Math.Sign(PolygonArea(poly)): positive when clockwise 
            and increasing Y goes upward.</summary>
            <remarks>A common approach to this problem is to look at the topmost
            point and the two points on either side. However, if one is not careful,
            this technique may be unable to detect the orientation in case the 
            polygon has duplicate points, horizontal lines on top, or a degenerate
            top in which the top part of the polygon is zero-width (these problems
            can occur even if the polygon's lines do not cross one another.) That's
            why I chose to compute orientation based on area instead.</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.IsPointInPolygon(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Int32}},Loyc.Geometry.Point{System.Int32})">
            <summary>Finds out if a point is inside the polygon using a winding 
            test.</summary>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.GetWindingNumber(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Int32}},Loyc.Geometry.Point{System.Int32})">
            <summary>Counts the number of times the polygon winds around a test 
            point, using a rightward raycasting test.</summary>
            <returns>Returns the winding number: the number of times that the
            polygon winds around the point. Positive means clockwise (assuming a 
            coordinate system in which increasing Y goes upward), negative means
            counterclockwise. Always returns -1, 0 or +1 when the polygon does
            not self-intersect. Returns 0 for a degenerate polygon.</returns>
            <remarks>
            The test point is considered to be within the polygon if it lies
            on a top or left edge, but not on a bottom or right edge (within
            the precision limits of 'double' arithmetic). The test point will 
            never be considered inside a degenerate (zero-width) area.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.PolygonArea(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Single}})">
            <summary>Computes the area of a polygon.</summary>
            <returns>The area. The result is positive if the polygon is clockwise 
            (assuming a coordinate system in which increasing Y goes upward), or 
            negative if the polygon is counterclockwise.</returns>
            <remarks>http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.Orientation(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Single}})">
            <summary>Returns Math.Sign(PolygonArea(poly)): positive when clockwise 
            and increasing Y goes upward.</summary>
            <remarks>A common approach to this problem is to look at the topmost
            point and the two points on either side. However, if one is not careful,
            this technique may be unable to detect the orientation in case the 
            polygon has duplicate points, horizontal lines on top, or a degenerate
            top in which the top part of the polygon is zero-width (these problems
            can occur even if the polygon's lines do not cross one another.) That's
            why I chose to compute orientation based on area instead.</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.IsPointInPolygon(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Single}},Loyc.Geometry.Point{System.Single})">
            <summary>Finds out if a point is inside the polygon using a winding 
            test.</summary>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.GetWindingNumber(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Single}},Loyc.Geometry.Point{System.Single})">
            <summary>Counts the number of times the polygon winds around a test 
            point, using a rightward raycasting test.</summary>
            <returns>Returns the winding number: the number of times that the
            polygon winds around the point. Positive means clockwise (assuming a 
            coordinate system in which increasing Y goes upward), negative means
            counterclockwise. Always returns -1, 0 or +1 when the polygon does
            not self-intersect. Returns 0 for a degenerate polygon.</returns>
            <remarks>
            The test point is considered to be within the polygon if it lies
            on a top or left edge, but not on a bottom or right edge (within
            the precision limits of 'double' arithmetic). The test point will 
            never be considered inside a degenerate (zero-width) area.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.PolygonArea(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Double}})">
            <summary>Computes the area of a polygon.</summary>
            <returns>The area. The result is positive if the polygon is clockwise 
            (assuming a coordinate system in which increasing Y goes upward), or 
            negative if the polygon is counterclockwise.</returns>
            <remarks>http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.Orientation(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Double}})">
            <summary>Returns Math.Sign(PolygonArea(poly)): positive when clockwise 
            and increasing Y goes upward.</summary>
            <remarks>A common approach to this problem is to look at the topmost
            point and the two points on either side. However, if one is not careful,
            this technique may be unable to detect the orientation in case the 
            polygon has duplicate points, horizontal lines on top, or a degenerate
            top in which the top part of the polygon is zero-width (these problems
            can occur even if the polygon's lines do not cross one another.) That's
            why I chose to compute orientation based on area instead.</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.IsPointInPolygon(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Double}},Loyc.Geometry.Point{System.Double})">
            <summary>Finds out if a point is inside the polygon using a winding 
            test.</summary>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.GetWindingNumber(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{System.Double}},Loyc.Geometry.Point{System.Double})">
            <summary>Counts the number of times the polygon winds around a test 
            point, using a rightward raycasting test.</summary>
            <returns>Returns the winding number: the number of times that the
            polygon winds around the point. Positive means clockwise (assuming a 
            coordinate system in which increasing Y goes upward), negative means
            counterclockwise. Always returns -1, 0 or +1 when the polygon does
            not self-intersect. Returns 0 for a degenerate polygon.</returns>
            <remarks>
            The test point is considered to be within the polygon if it lies
            on a top or left edge, but not on a bottom or right edge (within
            the precision limits of 'double' arithmetic). The test point will 
            never be considered inside a degenerate (zero-width) area.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.PolygonArea(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{Loyc.Math.FPI8}})">
            <summary>Computes the area of a polygon.</summary>
            <returns>The area. The result is positive if the polygon is clockwise 
            (assuming a coordinate system in which increasing Y goes upward), or 
            negative if the polygon is counterclockwise.</returns>
            <remarks>http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.Orientation(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{Loyc.Math.FPI8}})">
            <summary>Returns Math.Sign(PolygonArea(poly)): positive when clockwise 
            and increasing Y goes upward.</summary>
            <remarks>A common approach to this problem is to look at the topmost
            point and the two points on either side. However, if one is not careful,
            this technique may be unable to detect the orientation in case the 
            polygon has duplicate points, horizontal lines on top, or a degenerate
            top in which the top part of the polygon is zero-width (these problems
            can occur even if the polygon's lines do not cross one another.) That's
            why I chose to compute orientation based on area instead.</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.IsPointInPolygon(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{Loyc.Math.FPI8}},Loyc.Geometry.Point{Loyc.Math.FPI8})">
            <summary>Finds out if a point is inside the polygon using a winding 
            test.</summary>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.GetWindingNumber(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{Loyc.Math.FPI8}},Loyc.Geometry.Point{Loyc.Math.FPI8})">
            <summary>Counts the number of times the polygon winds around a test 
            point, using a rightward raycasting test.</summary>
            <returns>Returns the winding number: the number of times that the
            polygon winds around the point. Positive means clockwise (assuming a 
            coordinate system in which increasing Y goes upward), negative means
            counterclockwise. Always returns -1, 0 or +1 when the polygon does
            not self-intersect. Returns 0 for a degenerate polygon.</returns>
            <remarks>
            The test point is considered to be within the polygon if it lies
            on a top or left edge, but not on a bottom or right edge (within
            the precision limits of 'double' arithmetic). The test point will 
            never be considered inside a degenerate (zero-width) area.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.PolygonArea(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{Loyc.Math.FPI16}})">
            <summary>Computes the area of a polygon.</summary>
            <returns>The area. The result is positive if the polygon is clockwise 
            (assuming a coordinate system in which increasing Y goes upward), or 
            negative if the polygon is counterclockwise.</returns>
            <remarks>http://www.codeproject.com/Tips/601272/Calculating-the-area-of-a-polygon</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.Orientation(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{Loyc.Math.FPI16}})">
            <summary>Returns Math.Sign(PolygonArea(poly)): positive when clockwise 
            and increasing Y goes upward.</summary>
            <remarks>A common approach to this problem is to look at the topmost
            point and the two points on either side. However, if one is not careful,
            this technique may be unable to detect the orientation in case the 
            polygon has duplicate points, horizontal lines on top, or a degenerate
            top in which the top part of the polygon is zero-width (these problems
            can occur even if the polygon's lines do not cross one another.) That's
            why I chose to compute orientation based on area instead.</remarks>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.IsPointInPolygon(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{Loyc.Math.FPI16}},Loyc.Geometry.Point{Loyc.Math.FPI16})">
            <summary>Finds out if a point is inside the polygon using a winding 
            test.</summary>
        </member>
        <member name="M:Loyc.Geometry.PolygonMath.GetWindingNumber(System.Collections.Generic.IEnumerable{Loyc.Geometry.Point{Loyc.Math.FPI16}},Loyc.Geometry.Point{Loyc.Math.FPI16})">
            <summary>Counts the number of times the polygon winds around a test 
            point, using a rightward raycasting test.</summary>
            <returns>Returns the winding number: the number of times that the
            polygon winds around the point. Positive means clockwise (assuming a 
            coordinate system in which increasing Y goes upward), negative means
            counterclockwise. Always returns -1, 0 or +1 when the polygon does
            not self-intersect. Returns 0 for a degenerate polygon.</returns>
            <remarks>
            The test point is considered to be within the polygon if it lies
            on a top or left edge, but not on a bottom or right edge (within
            the precision limits of 'double' arithmetic). The test point will 
            never be considered inside a degenerate (zero-width) area.
            </remarks>
        </member>
        <member name="T:Loyc.Utilities.GoInterface">
            <summary>Mainly for internal use by the other GoInterface classes.</summary>
        </member>
        <member name="M:Loyc.Utilities.GoInterface.Unwrap(System.Object)">
            <summary>Unwraps an object if it was wrapped by GoInterface. Unwrapping
            is recursive, so that if a wrapper is inside another wrapper, the
            underlying object is returned.</summary>
            <param name="obj">Any object.</param>
            <returns>Returns the original object wrapped by GoInterface. If the
            specified object is not a GoInterface wrapper, returns obj itself.</returns>
        </member>
        <member name="M:Loyc.Utilities.GoInterface.UnwrapOnce(System.Object)">
            <summary>Unwraps an object if it was wrapped by GoInterface. This
            unwrapping is not recursive--if a wrapper is inside another wrapper,
            only the outer wrapper is removed.</summary>
            <param name="obj">Any object.</param>
            <returns>Returns the original object wrapped by GoInterface. If the
            specified object is not a GoInterface wrapper, returns obj itself.</returns>
        </member>
        <member name="T:Loyc.Utilities.IGoInterfaceWrapper">
            <summary>All GoInterface wrappers implement this interface.</summary>
        </member>
        <member name="T:Loyc.Utilities.GoInterface`1">
             <summary>GoInterface&lt;Interface> creates wrappers around objects of your 
             choosing that implement the specified Interface, forwarding calls to 
             methods in the wrapped object. It is inspired by the duck-typed interfaces 
             in the Go programming language.</summary>
             <remarks>
             In the Go programming language, you do not say explicitly that your type 
             implements a given interface. Instead, a type is convertable to <i>any</i>
             interface, just so long as it implements all the methods in the interface.
             This often reminds people of "duck typing" in dynamic languages such as 
             Python or Ruby, but it is faster; in fact, Go interface calls are the same 
             speed as virtual method calls in C++ and C#!
             <para/>
             To put it in C# terms, if you have a class T...
             <pre>public class T {
                 public void Foo(int x);
             }</pre>
             
             ...and an interface called "Interface"...
             
             <pre>public interface Interface {
                 void Foo(int x);
             }</pre>
            
             ...then you can cast T to Interface even though T does not explicitly implement it.
            
             <pre>Interface t = new T();</pre>
             
             This cast can be implicit since the compiler can tell at compile time that
             T implements the Interface. However, you can cast any object to Interface 
             and, at run-time, Go will determine whether it implements the Interface.
             <para/>
             I asked how Go dispatch works on the "Go Nuts" google group and was pointed 
             to two articles:
             <para/>
             http://research.swtch.com/2009/12/go-data-structures-interfaces.html
             http://www.airs.com/blog/archives/281
             <para/>
             To summarize those, the first time you convert a type "T" to an interface 
             "Interface", a vtable (virtual function table) is generated just like the 
             kind used for virtual calls in .NET and C++. However, instead of storing 
             the vtable in the object itself like C++ and .NET do, Go stores the vtable 
             pointer alongside the interface pointer (i.e. an interface pointer is 
             really two pointers). This simple but unique design allows a single object
             to implement an unlimited number of interfaces with overall performance 
             that is competitive with C# and Java.
             <para/>
             Unfortunately, as far as I can tell, there is no way to efficiently
             implement this same technique in .NET without changing the CLR itself. A
             virtual method table is just a list of pointers to functions; importantly,
             function pointers in a virtual method table are not associated with a
             specific object, which makes them different from .NET delegates. By not
             associating the vtable with a specific object, it is possible to re-use the
             same vtable with any number of objects (as long as they are of the same
             class). However, .NET delegates are associated with specific objects, so we
             can't use them to form a reusable vtable.
             <para/>
             Even if .NET allowed delegates that are not associated with a specific
             object, delegate invocation on .NET is slower than virtual method
             invocation; why this is so is not entirely clear to me, but part of the
             reason may be that Microsoft decided to make delegates reference types when
             they should have been a simpler 8-byte value type (just bundling a function
             pointer with a 'this' pointer).
             <para/>
             However, just a few days ago I learned that Visual Basic 9 has a very
             similar feature to Go called "dynamic interfaces", which pretty much lets
             you do as described above (albeit only in Visual Basic). So far I've heard
             nothing about how VB's dynamic interfaces work, but I got to thinking: how
             hard would it be to bring go-style interfaces to all .NET languages, and
             would it be possible to get good performance?
             <para/>
             The technique I chose doesn't have performance as good as you would get from
             Go, but in exchange for a small performance hit (which I believe to be
             unavoidable anyway), the GoInterface classes provide automatic interface
             adaptations that you can't get in Go itself. Specifically, my GoInterface
             classes can automatically do small type conversion tasks like enlarging
             "int" to "long", boxing value types, and allowing return type covariance
             (for instance, if the wrapped method returns a "string", the Interface can
             return an "object".) And since GoInterface returns heap objects that
             actually implement the interface you ask for (rather than, say, an 8-byte
             structure imitating the Go implementation), it's very easy to use.
             <para/>
             The GoInterface classes use .NET Reflection.Emit to generate wrapper classes
             in a "dynamic assembly"--basically a DLL that exists only in memory. Each
             wrapper class implements a single interface of your choosing, and forwards
             calls on that interface to an object of your choosing.
             <para/>
             Given the types from above...
             
             <pre>public class T {
                 public void Foo(int x);
             }
             public interface Interface {
                 void Foo(int x);
             }</pre>
             
             ...you can use GoInterface to cast T to Interface like this:
             
             <pre>Interface t = GoInterface&lt;Interface>.From(new T());</pre>
             
             The first time you cast a T to Interface, GoInterface generates a wrapper 
             class such as the following on-the-fly:
             
             <pre>public class T_46F3E18_46102A0 : Interface
             {
                 T _obj;
                 public T_46F3E18_46102A0(T obj) { _obj = obj; }
                 void Foo(int x) { _obj.Foo(x); }
             }</pre>
             
             The hex numbers in the name of the type are simply handles to interface and 
             type being wrapped, in order to guarantee no name collisions occur when you 
             are wrapping a lot of different classes with GoInterface.
             <para/>
             After the first cast, all future casts are fairly fast, especially if you
             call GoInterface&lt;Interface,T>.From() instead of just
             GoInterface&lt;Interface>.From(). That's because after
             GoInterface&lt;Interface,T> is fully initialized, all its From() method does
             is invoke a delegate that contains the following code:
             
             <pre>delegate(T obj) { return new T_46F3E18_46102A0(obj); }</pre>
             
             You can create wrappers with either GoInterface&lt;Interface> or
             GoInterface&lt;Interface, T> (note the extra type argument "T").
             <ul>
             <li>GoInterface&lt;Interface> is intended for creating wrappers when you do
             not know the type of the object at compile time. For example, if you have a
             list of objects of unknown type and you want to cast them to an interface,
             use this one.</li>
             <li>GoInterface&lt;Interface, T> creates wrappers when you already know the
             type of the object at compile time. This version assumes that T itself (and
             not some derived class!) contains the methods you want to call.
             GoInterface&lt;Interface, T> has the disadvantage that it is unable to call
             methods in a derived class of T. For example, you should not use
             GoInterface&lt;Interface, object> because the object class does not contain
             a Foo method.</li>
             </ul>
             If you're not sure which one to use, use GoInterface&lt;Interface>. If you
             need to adapt a large number of objects to a single interface, you should
             use GoInterface&lt;Interface, T> where possible, because it is slightly
             faster. GoInterface&lt;Interface>, in contrast, has to examine each object
             it is given to find out its most derived type. However, this process is
             optimized so that an expensive analysis is only done once per derived type,
             after which only a hashtable lookup is required.
             <para/>
             Compared to interfaces in the Go programming language, which have a 1-word
             overhead for every interface pointer (the vtable pointer, which is 4 bytes
             in 32-bit code), GoInterface wrappers normally have 3 words of overhead (2
             words for the wrapper's object header and 1 word for a reference to the
             wrapped object). Also, GoInterface wrapper classes are no doubt much more
             costly to produce (since they involve run-time code generation), which will
             increase your program's startup time and have a fixed memory overhead that
             dwarfs Go's implementation. However, once you are up-and-running with
             GoInterface wrappers, their performance should be pretty good. TODO:
             benchmarks
             <para/>
             Note: GoInterface can create wrappers for value types (structures), not just
             classes. Such wrappers have the same memory overhead as boxed structures,
             which is one word less than wrappers for reference types.
             <para/>
             GoInterface wrappers automatically forward calls to object.ToString(),
             object.GetHashCode() and object.Equals(), even though these methods are 
             not technically part of the interface being wrapped.
             <para/>
             GoInterface cannot wrap explicit interface implementations in the target
             class. For instance, if the target class implements IEnumerable(of T), that
             interface has two versions of the GetEnumerator function that differ only by
             return type (one returns IEnumerator and the other returns IEnumerator(of
             T)), so one of them must be implemented "explicitly". GoInterface will
             typically only see the version that returns IEnumerator(of T), but this is
             not a problem since IEnumerator(of T) is implicitly convertable to
             IEnumerator, so GoInterface can use that one method to represent either of 
             them. In Visual Basic there is a caveat, since an explicit interface
             implementation is allowed to be public. In that case, GoInterface will only 
             see the method's public name (not the name used in the interface).
             </remarks>
        </member>
        <member name="T:Loyc.Utilities.CastOptions">
            <summary>Options you can pass to GoInterface.From()</summary>
        </member>
        <member name="F:Loyc.Utilities.CastOptions.As">
            <summary>If there is a mismatch, return null instead of throwing InvalidCastException</summary>
        </member>
        <member name="F:Loyc.Utilities.CastOptions.AllowUnmatchedMethods">
            <summary>Allow the cast even if NumberOfUnmatchedMethods > 0</summary>
        </member>
        <member name="F:Loyc.Utilities.CastOptions.AllowRefMismatch">
            <summary>Allow the cast even if NumberOfMethodsWithRefMismatch > 0</summary>
        </member>
        <member name="F:Loyc.Utilities.CastOptions.AllowMissingParams">
            <summary>Allow the cast even if NumberOfMethodsMissingParameters > 0</summary>
        </member>
        <member name="F:Loyc.Utilities.CastOptions.NoUnwrap">
            <summary>If the object to be wrapped is already wrapped, 
            GoInterface&lt;Interface> will normally unwrap it before wrapping the
            original object in another interface. Pass this flag to 
            GoInterface&lt;Interface>.From() if you would like to make a wrapper 
            around another wrapper.
            <para/>
            Note 1: This flag only works in GoInterfaceFactory&lt;Interface>, 
            not GoInterfaceFactory&lt;Interface,T>.
            Note 2: Unwrapping occurs recursively until an object is reached that
            does not implement IGoInterfaceWrapper.
            </summary>
        </member>
        <member name="T:Loyc.Utilities.GoInterfaceFactory`1">
            <summary>For internal use. Base class of GoInterface&lt;Interface,T>.Factory 
            and GoDirectCaster&lt;Interface>.</summary>
        </member>
        <member name="T:Loyc.Utilities.GoDirectCaster`1">
            <summary>Used by GoInterface&lt;Interface> to cast objects directly to an 
            interface when it turns out that they implement that interface.</summary>
        </member>
        <member name="T:Loyc.Utilities.GoInterface`2">
            <summary>GoInterface&lt;Interface,T&gt; creates a wrapper that implements 
            the specified Interface, forwarding calls to methods in T. It is inspired 
            by the duck-typed interfaces in the Go programming language.</summary>
            <remarks>
            Please see <see cref="T:Loyc.Utilities.GoInterface`1"/> for more information.
            </remarks>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.ForceFrom(`1)">
            <summary>Creates a wrapper regardless of whether or not T could be 
            wrapped completely.</summary>
            <exception cref="T:System.InvalidOperationException">The Interface is not 
            valid (e.g. it is not public or is not abstract)</exception>
            <remarks>
            GoInterface maps methods in certain cases where you might not 
            want it to--for example, if the Interface takes two ints and T only 
            takes one, GoInterface maps one to the other by omitting the second 
            parameter. To accept these mappings, call ForceFrom(T) or From(T, 
            CastOptions.AllowMissingParams | CastOptions.AllowRefMismatch); to 
            reject them, call From(T).
            <para/>
            ForceFrom always creates a wrapper, even if some methods of Interface
            couldn't be matched with T at all. If you then call a method that 
            couldn't be wrapped, you'll get a MissingMethodException.
            </remarks>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.From(`1)">
            <summary>Creates a wrapper if the interface matches T well.</summary>
            <exception cref="T:System.InvalidCastException">T does not match the Interface 
            very well. Specifically, NumberOfUnmatchedMethods&gt;0, 
            NumberOfMethodsMissingParameters&gt;0 or NumberOfMethodsWithRefMismatch&gt;0.</exception>
            <returns>A pointer to a wrapper that implements the Interface.</returns>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.From(`1,Loyc.Utilities.CastOptions)">
            <summary>Creates a wrapper if T matches Interface according to the 
            specified CastOptions.</summary>
            <returns>A pointer to a wrapper that implements the Interface.</returns>
            <remarks>See CastOptions for more information.</remarks>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.DefineCustomWrapperCreator(Loyc.Utilities.GoInterface{`0,`1}.GoWrapperCreator,Loyc.Utilities.GoInterface{`0,`1}.GoWrapperCreator)">
            <summary>Defines a custom wrapper class for the type pair (Interface, 
            T). If you want to install a custom wrapper, you must do so before 
            From() or ForceFrom() is ever called on this pair of types, otherwise 
            an exception is thrown. Also, you cannot call this method twice on 
            the same pair of types.</summary>
            <param name="from">A method to be invoked by From().</param>
            <param name="forceFrom">A method to be invoked by ForceFrom().</param>
            <remarks>
            Since generating a wrapper is expensive and the wrapper cannot be 
            garbage-collected, I decided to make sure you don't waste time and
            memory generating a wrapper you don't intend to use, by restricting 
            this method only to be used on type pairs that have never been used 
            before. Make sure you call this method as soon as possible, before 
            anybody calls From() or ForceFrom().
            </remarks>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.ContainsIdenticalMethod(System.Reflection.MethodInfo,System.Collections.Generic.List{Loyc.Utilities.GoInterface{`0,`1}.MethodAndParams})">
            <summary>Returns true if 'otherMethods' contains a method identical to
            'method' (IGNORING the return value!)</summary>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.GenerateWrapperMethod(System.Reflection.Emit.TypeBuilder,System.Collections.Generic.List{Loyc.Utilities.GoInterface{`0,`1}.MethodAndParams},System.Int32,System.Collections.Generic.List{Loyc.Utilities.GoInterface{`0,`1}.MethodAndParams})">
            <summary>Generates a method that implements baseMethod (a method of
            Interface) and forwards the call to the same method on T.</summary>
            <remarks>"Safe" parameter variance is allowed between Interface and T,
            such as return type covariance.</remarks>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.GetMatchingMethods(System.Reflection.MethodInfo,System.Collections.Generic.List{Loyc.Utilities.GoInterface{`0,`1}.MethodAndParams})">
            <summary>Scans methods of T looking for a method matching a method 
            of Interface (baseMethod)</summary>
            <remarks>
            Before generating code for the method, we must find a matching 
            method of T. Note that we want to support various kinds of
            "variance", including boxing if necessary:
            <para/>
            - Return type covariance. If T's method returns a derived class,
              Interface's method can return a base class or interface. Also, 
              allow any return type if baseMethod returns void.
            - "out" parameter covariance.
            - T's "out" argument(s) can be absent from Interface, as long as
              they are at the end of the argument list.
            - Interface's input arguments can be absent from T, as long as the
              missing parameters come at the end of the argument list.
            - Input parameter contravariance. If T's method accepts a base class
              (or interface) such as "object", Interface's method can accept a 
              derived class (or a class that implements said interface).
            - If T takes a "ref" argument, allow the method in Interface not to
              be "ref" and vice versa.
            - T's method can be static
            <para/>
            Implicit conversion operators are not currently detected, except 
            primitive type conversions like Int16 to Float that C# allows you 
            to do implicitly. Information-losing conversions like Int64 to 
            Int32 are not supported.
            <para/>
            Variable argument lists are not supported specifically (they are 
            treated as arrays).
            <para/>
            Generic methods in T and Interface are not supported.
            <para/>
            Default (optional) arguments are generally supported.
            <para/>
            Argument names are ignored and need not match.
            <para/>
            Methods that differ only in case are not considered, but Aliases 
            specified with GoAliasAttribute are considered if a matching method 
            with the original name could not be found. All matching aliases are 
            considered together, as if they were overloads of each other.
            <para/>
            We scan all methods of "T" with a matching name and find the best
            match, since there may be multiple methods matching these
            requirements. For the most part I try to follow the rules of 
            the C# standard (ECMA-334 §14.4.2.1 and §14.4.2.2), but be a little 
            more liberal. The way I figure it, "void" should be treated like a
            base class of "object". Note that this matching algorithm may reject
            all overloads due to "ambiguity", in case one overload is not better
            than all others.
            </remarks>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.ImplicitConvType(System.Type,System.Type)">
            <summary>Figures out what kind of conversion you need to get from 
            "from" to "to", returning ConvType.IsA if no conversion is needed.</summary>
        </member>
        <member name="M:Loyc.Utilities.GoInterface`2.PrimSize(System.Type,System.Boolean@)">
            <summary>Returns the size of a primitive integer or float type and 
            also tells you if the type is unsigned; note that IntPtr and 
            UIntPtr are not handled.</summary>
            <returns>The size of type t, or 0 for unhandled types.</returns>
        </member>
        <member name="P:Loyc.Utilities.GoInterface`2.IsValidInterface">
            <summary>If this value is false, Interface is not valid and ForceFrom 
            will throw InvalidOperationException if called. In that case, the other 
            values such as NumberOfUnmatchedMethods are zero, but have no meaning.</summary>
            <remarks>Calling this property or any of the "int" properties forces 
            the wrapper class to be generated, during which the relationship 
            between Interface and T is analyzed.</remarks>
        </member>
        <member name="P:Loyc.Utilities.GoInterface`2.NumberOfUnmatchedMethods">
            <summary>The number of methods in the interface for which a matching 
            method in T could not be found.</summary>
        </member>
        <member name="P:Loyc.Utilities.GoInterface`2.NumberOfAmbiguousMethods">
            <summary>The number of methods in the interface for which a matching 
            method in T could not be found because T contained more than one 
            equally suitable match.</summary>
        </member>
        <member name="P:Loyc.Utilities.GoInterface`2.NumberOfMethodsMissingParameters">
            <summary>The number of methods in the interface that were matched to 
            a method in T with one or more parameters dropped. For instance, if a
            method in the interface takes two ints but T's method only takes one
            int, the second int of </summary>
        </member>
        <member name="P:Loyc.Utilities.GoInterface`2.NumberOfMethodsWithRefMismatch">
            <summary>The number of methods in the interface that were matched to a 
            method in T, in which there was a mismatch that one parameter was 
            passed by reference ("ref") and the other was passed by value.</summary>
        </member>
        <member name="T:Loyc.Utilities.GoInterface`2.Factory">
            <summary>This helper class allows GoInterface&lt;Interface> to cache 
            access to the static methods in GoInterface&lt;Interface, T>, so that 
            it only needs to use reflection once.</summary>
        </member>
        <member name="T:Loyc.Utilities.GoInterface`2.MethodAndParams">
            <summary>A MethodInfo with cached parameter information.</summary>
        </member>
        <member name="T:Loyc.Utilities.GoAliasAttribute">
            <summary>This attribute is applied to a method of an interface to specify 
            alternate names that a method can have in T when you use GoInterface
            &lt;Interface, T> to produce a wrapper.</summary>
            <example>
            public class MyCollection
            {
                 void Insert(object obj);
                 int Size { get; }
                 object GetAt(int i);
            }
            public interface ISimpleList
            {
                [GoAlias("Insert")] void Add(object item);
                
                int Count 
                {
                    [GoAlias("get_Size")] get;
                }
                object this[int index]
                {
                    [GoAlias("GetAt")] get;
                }
            }
            void Example()
            {
                ISimpleList list = GoInterface&lt;ISimpleList>.From(new MyCollection());
                list.Add(10); // calls MyCollection.Insert(10)
            }
            </example>
        </member>
        <member name="T:Loyc.Utilities.GoDecoratorFieldAttribute">
            <summary>
            This attribute marks a field in an abstract class as pointing to a wrapped
            object to which GoInterface should forward calls. It is used when you want
            GoInterface to "complete" a decorator pattern for you.
            </summary>
            <remarks>
            After writing the basic functionality of GoInterface, I realized it could
            also serve as a handy way to implement the Decorator pattern. A decorator
            is a class that wraps around some target class (usually sharing the same
            interface or base class), while modifying the functionality of the target.
            For instance, you could write a decorator for TextWriter that filters out 
            curse words, replacing them with asterisks.
            <para/>
            Writing decorators is sometimes inconvenient because you only want to 
            modify the behavior of some functions while leaving others alone. 
            Without GoInterface, you must write a wrapper for every method, manually 
            forwarding calls from the decorator to the target.
            <para/>
            GoInterface can help by generating forwarding functions automatically.
            <para/>
            The example shows how to use GoInterface to help you make a decorator.
            </remarks>
            <example>
            // A view of an IList in which the order of the elements is reversed.
            // The test suite offers this example in full; this partial implementation
            // just explains the concepts.
            public abstract class ReverseView&lt;T> : IList&lt;T> 
            {
                // Use the GoDecoratorField attribute so that GoInterface will access
                // the list through this field instead of creating a new field.
                // Important: the field must be "protected" or "public" and have 
                // exactly the right data type; otherwise, GoInterface will ignore 
                // it and create its own field in the generated class.
            	[GoDecoratorField]
            	protected IList&lt;T> _list;
            
            	// The derived class will init _list for you if you have a default 
            	// constructor. If your constructor instead takes an IList argument,
            	// you are expected to initialize _list yourself.
            	protected ReverseView() { Debug.Assert(_list != null); }
            
                // The downside of using GoInterface to help you make decorators is 
                // that GoInterface creates a derived class that overrides abstract
                // methods in your own class, which means your class must be abstract,
                // and users can't write "new ReverseView"--instead you must provide
                // a static method like this one to create the wrapper.
            	public static ReverseView&lt;T> From(IList&lt;T> list)
            	{
            		return GoInterface&lt;ReverseView&lt;T>, IList&lt;T>>.From(list);
            	}
            
                // Here are two of several methods whose functionality we need to 
                // modify in order to reverse a list.
            	public int IndexOf(T item)
            	{ 
            		int i = _list.IndexOf(item); 
            		return i == -1 ? -1 : Count - 1 - i;
            	}
            	public void Insert(int index, T item)
            	{
            		_list.Insert(Count - index, item);
            	}
            	
            	// Here are the functions that we don't have to implement, which we
            	// allow GoInterface to implement automatically. Unfortunately, when 
            	// implementing an interface you can't simply leave out the functions 
            	// you want to remain abstract. C#, at least, requires you to make a
            	// list of the interface methods that you don't want to implement. 
            	// This inconvenience is only when implementing an interface; if you
            	// are just deriving from an abstract base class, you don't have to 
            	// do this because the base class already did it.
            	public abstract void Add(T item);
            	public abstract void Clear();
            	public abstract bool Contains(T item);
            	public abstract void CopyTo(T[] array, int arrayIndex);
            	public abstract int Count { get; }
            	public abstract bool IsReadOnly { get; }
            	public abstract bool Remove(T item);
            	public abstract IEnumerator&lt;T> GetEnumerator();
            	
            	// IEnumerable has two GetEnumerator functions so you must use an 
            	// "explicit interface implementation" for the second one. 
            	// You must write this one yourself, as it can't be marked abstract.
            	System.Collections.IEnumerator
            	System.Collections.IEnumerable.GetEnumerator()
            	{
            		return GetEnumerator();
            	}
            }
            </example>
        </member>
        <member name="T:Loyc.LLParserGenerator.IntSet">
            <summary>Represents a set of characters (e.g. 'A'..'Z' | 'a'..'z' | '_'), 
            or a set of token IDs.</summary>
            <remarks>This class was written for, and is used by, LLLPG. In addition to
            set operations like union and Subtract, one of its main features is that it 
            can convert a set of integers or characters to/from a string form like 
            "[A-Z]" or "(65..90)".</remarks>
        </member>
        <member name="F:Loyc.LLParserGenerator.IntSet._ranges">
            <summary>A list of non-overlapping character ranges, sorted by code 
            point. EOF can be included in this list as character -1 (hence CharRange 
            holds ints instead of chars).</summary>
        </member>
        <member name="F:Loyc.LLParserGenerator.IntSet.IsCharSet">
            <summary>Controls the default stringization mode. When IsCharSet, the
            set "(36, 65..90, 126)" prints as "[$A-Z~]". IsCharSet is false by default.
            </summary>
        </member>
        <member name="M:Loyc.LLParserGenerator.IntSet.EquivalentInverted">
            <summary>Computes the equivalent inverted set, e.g. if the set is 
            <c>'b'..'y'</c>, the equivalent inverted set is 
            <c>~(int.MinValue..'a' | 'z'..int.MaxValue)</c>.</summary>
        </member>
        <member name="M:Loyc.LLParserGenerator.IntSet.ToString">
            <summary>Prints the character set using regex syntax, e.g. [\$a-z] 
            means "EOF or a to z", [^\n\r] means "not \n or \r". Use 
            ToString(false) if this is an integer set.</summary>
        </member>
        <member name="P:Loyc.LLParserGenerator.IntSet.IsInverted">
            <summary>When Inverted is true, the set behaves as if it contains the
            opposite set of items. That is, membership tests that succeeded when
            Inverted was false will fail, and vice versa.</summary>
        </member>
        <member name="P:Loyc.LLParserGenerator.IntSet.IsEmptySet">
            <summary>Returns true iff the set is empty. When the set is inverted 
            and contains the set of all integers, that also counts as empty.</summary>
        </member>
        <member name="P:Loyc.LLParserGenerator.IntSet.ContainsEverything">
            <summary>Returns true iff the set covers all integers. This includes 
            the common scenario that the set is empty but inverted.</summary>
        </member>
        <member name="P:Loyc.LLParserGenerator.IntSet.Size">
            <summary>Gets the number of integers whose membership test would 
            succeed (the maximum possible value is 0x100000000L).</summary>
        </member>
        <member name="T:Loyc.LLParserGenerator.IntRange">
            <summary>Represents a range of single characters (e.g. 'A'..'Z').</summary>
        </member>
        <member name="M:Loyc.LLParserGenerator.IntRange.CompareTo(Loyc.LLParserGenerator.IntRange)">
            <summary>Compares only the <see cref="F:Loyc.LLParserGenerator.IntRange.Lo"/> values of two ranges.</summary>
        </member>
        <member name="T:Loyc.Geometry.PointExt">
            <summary>Contains methods for manipulating points in generic code.</summary>
            <remarks>Using <see cref="T:Loyc.Geometry.PointMath"/> extension methods is easier. These
            methods may be faster but they require a "math" structure (see <see cref="T:Loyc.Math.Maths`1"/>).</remarks>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Add``3(``2,``0,``0)">
            <summary>Returns the sum of two vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Subtract``2(``1,Loyc.Geometry.IPoint{``0},Loyc.Geometry.IPoint{``0})">
            <summary>Returns the difference between two points or vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Multiply``2(``1,Loyc.Geometry.IPoint{``0},``0)">
            <summary>Returns a point or vector multiplied by a scaling factor.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Divide``2(``1,Loyc.Geometry.IPoint{``0},``0)">
            <summary>Returns a point or vector divided by a scaling factor.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.ShiftLeft``2(``1,Loyc.Geometry.IPoint{``0},System.Int32)">
            <summary>Returns a point or vector scaled up by a power of two.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.ShiftRight``2(``1,Loyc.Geometry.IPoint{``0},System.Int32)">
            <summary>Returns a point or vector scaled down by a power of two.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.MulDiv``2(``1,Loyc.Geometry.IPoint{``0},``0,``0)">
            <summary>Returns a point or vector by a factor, then divides by another factor.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Dot``2(``1,Loyc.Geometry.IPoint{``0},Loyc.Geometry.IPoint{``0})">
            <summary>Gets the dot product of two vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Cross``2(``1,Loyc.Geometry.IPoint{``0},Loyc.Geometry.IPoint{``0})">
            <summary>Gets the cross product of two vectors.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Rot90``2(``1,Loyc.Geometry.IPoint{``0})">
            <summary>Returns a vector rotated 90 degrees.</summary>
            <remarks>
            Rotatation is clockwise if increasing Y goes downward, counter-
            clockwise if increasing Y goes upward.
            </remarks>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Negate``2(``1,Loyc.Geometry.IPoint{``0})">
            <summary>Returns a vector with its direction reversed.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Quadrance``2(``1,Loyc.Geometry.IPoint{``0})">
            <summary>Gets the square of the length of a vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Length``2(``1,Loyc.Geometry.IPoint{``0})">
            <summary>Gets the length of a vector.</summary>
        </member>
        <member name="M:Loyc.Geometry.PointExt.Angle``2(``1,Loyc.Geometry.IPoint{``0})">
            <summary>Gets the angle from 0 to 2*PI of the vector, where (1,0) has 
            angle 0 and (0,1) has angle PI/2.</summary>
        </member>
        <member name="T:Loyc.Utilities.SimpleTimer">
            <summary>
            A fast, simple timer class with a more convenient interface than 
            System.Diagnostics.Stopwatch. Its resolution is typically 10-16 ms
            on desktop Windows systems.
            </summary>
            <remarks>
            With SimpleTimer, the timer starts when you construct the object and 
            it is always counting. You can get the elapsed time and restart the 
            timer from zero with a single call to Restart(). The Stopwatch class 
            requires you to make three separate method calls to do the same thing:
            you have to call ElapsedMilliseconds, then Reset(), then Start().
            <para/>
            SimpleTimer cannot be used to measure time periods longer than 24.8 
            days. The 32-bit millisecond counter will overflow and Millisec will 
            become negative.
            </remarks>
        </member>
        <member name="M:Loyc.Utilities.SimpleTimer.Restart">
            <summary>Restarts the timer from zero (unpausing it if it is paused), 
            and returns the number of elapsed milliseconds prior to the reset.</summary>
        </member>
        <member name="M:Loyc.Utilities.SimpleTimer.ClearAfter(System.Int32)">
            <summary>Restarts the timer from zero if the specified number of 
            milliseconds have passed, and returns the former value of Millisec.</summary>
            <returns>If the timer was restarted, this method returns the number of 
            elapsed milliseconds prior to the reset. Returns 0 if the timer was not 
            reset.</returns>
            <remarks>If this method resets a paused timer, it remains paused but 
            Millisec is set to zero.</remarks>
        </member>
        <member name="P:Loyc.Utilities.SimpleTimer.Millisec">
            <summary>
            The getter returns the number of milliseconds since the timer was 
            started; the resolution of this property depends on the system timer.
            The setter changes the value of the timer.
            </summary>
        </member>
        <member name="T:Loyc.Utilities.Statistic">
            <summary>
            A lightweight class to help you compute the minimum, maximum, average
            and standard deviation of a set of values. Call Clear(), then Add(each
            value); you can compute the average and standard deviation at any time by 
            calling Avg() and StdDeviation().
            </summary>
        </member>
        <member name="T:Loyc.Utilities.TagsInWList`1">
            <summary>An implementation of ITags designed for AstNode.</summary>
            <remarks>
            It is supposed to be possible to clone AstNode quickly; to support extra 
            tags, we need to be able to clone the tags quickly too, so it makes sense
            to store them in a WList. To make cloning as quick as possible, we derive
            from WListProtected. To optimize access to tags, we use the UserByte of
            WListProtected to hold the index of the last tag that was used. This 
            ensures tags can be accessed quickly by code that only uses a single tag.
            </remarks>
        </member>
        <member name="T:Loyc.Utilities.UG">
            <summary>Contains global functions of Loyc.Utilities that don't belong in any specific class.</summary>
        </member>
        <member name="M:Loyc.Utilities.UG.ProcessCommandLineArguments(System.Collections.Generic.IList{System.String},System.Collections.Generic.ICollection{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.String,System.Collections.Generic.IDictionary{System.Char,System.String},Loyc.Collections.InvertibleSet{System.String},System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Expands environment variables (e.g. %TEMP%) and @files in a list of
            command-line arguments, and adds any options of the form "--opt" or
            "--opt=value" to a dictionary.
            </summary>
            <param name="args">The original arguments to process.</param>
            <param name="options">Any long options (arguments that start with "--") 
            will be added to this dictionary, and removed from <c>args</c>. This 
            parameter cannot be null. 
              By default, long options are not case sensitive. In that case, the 
            user's option name is converted to lower case.
            <para/>
            Long options are expected to have the form --ID or --ID=value, where ID 
            matches the regex "[a-zA-Z_0-9-]+". If there is no "=" or ":", that's 
            okay too. For example, --Id{foo} is equivalent to --Id={foo}; both yield
            in the name-value pair ("id", "{foo}"). If there is no value (no equals
            or colon), the value associated with the option is null.</param>
            <param name="atFolder">If a parameter has the form @filename, the folder
            specified by atFolder will be searched for an options text file with the
            user-specified filename, and the contents of the file will be expanded 
            into the list of arguments (split using SplitCommandLineArguments). The
            expanded list can contain new @filenames, which are also processed. To
            search in the current directory, use "". The @filename may use an absolute
            path, which overrides this folder. To disable @filename expansion, set 
            this parameter to null. Whether the feature is enabled or disabled, 
            @filenames are <i>not</i> removed from <c>args</c>, in case you want to 
            be aware of the filenames afterward.</param>
            <param name="shortOptions">A map from one-letter options that start with 
            "-" rather than "--", to the name of the corresponding long option (this
            option can be null to ignore all short options.) For example, if this 
            contains (<c>'a', "all"</c>), and the input <c>args</c> contains "-a:foo",
            the pair ("all", "foo") will be added to <c>options</c>. If a value in 
            this map is null, the key itself is used. Short options can be combined; 
            for example <c>-abc:foo</c> is equivalent to <c>-a -b -c:foo</c>. Short 
            options are always case-sensitive; to define an option that is not case 
            sensitive, place two entries in the dictionary e.g. ('a', "all") and 
            ('A', "all"). If the user specifies a short option letter that is not 
            recognized, the entire command will be ignored and left in args. For 
            example, if <c>shortOptions</c> contains only ('a', "all") but <c>args</c>
            contains "-ab=foo", the command is ignored and left in <c>args</c>. 
            Rationale: -ab=foo might be a filename.
            <para/>
            On the other hand, if -a is a valid option then <c>-a123</c> is also 
            valid even when there is no option called '1'; the number "123" is 
            treated as an argument to -a. Now, if '1' is a registered short option 
            but '2' is not, then <c>-a123</c> is equivalent to <c>-a -1=23</c>.
            </param>
            <param name="twoArgOptions">A set of options in which the argument can
            be separated by a space from the option. For example, if the input is 
            "--out foo.txt" and you want to recognize "foo.txt" as the argument to
            "--out", add the string "out" to this set. If you want to treat <i>all</i>
            options this way, use <c>InvertibleSet{string}.All</c>. Note: 
            If the input is "--out:foo bar", "foo" is recognized as the argument to
            "--out" and "bar" is left alone, i.e. it is treated as unrelated.
              Short options participate automatically. For example if "-f" means 
            "--foo", and twoArgOptions contains "foo", then "-f arg" is interpreted 
            like "--foo=arg".
            <para/>
            The argument will not be treated as an argument if it starts with a 
            dash, e.g. in <c>--foo -*</c>, <c>-*</c> will not be treated as an 
            argument to <c>--foo</c>, even if <c>-*</c> is not a registered option.
            </param>
            <param name="argLimit">A limit placed on the number of arguments when
            expanding @files. Such a file may refer to itself, and this is the only
            protection provided against infinite recursive expansion.</param>
            <param name="expandEnvVars">If true, environment variable references
            such as <c>%TEMP%</c> are expanded by calling the standard method
            <see cref="M:System.Environment.ExpandEnvironmentVariables(System.String)"/>.</param>
            <param name="caseSensitiveLongOpts">If true, long options are case-
            sensitive. By default, long options are not case sensitive.</param>
            <remarks>
            Two types of options are recognized, short (-s) and long (--long), and
            only one argument is supported per option. The documentation is above.
            <para/>
            You can choose whether to permit duplicate options or not. If you use
            a standard <see cref="T:System.Collections.Generic.Dictionary`2"/> to hold the options, an 
            exception will occur when this method calls Add() to add the duplicate. 
            The exception is caught, the first ocurrance is kept, and a warning 
            message is printed to <see cref="P:Loyc.MessageSink.Current"/>.
            <para/>
            To allow duplicates, store options in a different data structure such as 
            <c>List(KeyValuePair(string, string))</c> or <c>BMultiMap(string,string)</c>.
            <para/>
            DOS-style slash-options like /foo are not supported. Since Windows
            recognizes the forward slash as a path separator, forward-slash options
            can be recognized as paths. If you want to recognize them as options 
            instead, you can preprocess the argument list, replacing every command 
            that starts with "/" with a "--" command:
            <code>
              for (int i = 0; args.Count &gt; i; i++)
                if (args[i].StartsWith("/")) 
                  args[i] = "--" + args[i].Substring(1);
            </code>
            <para/>
            Globs (e.g. *.txt) are not recognized or expanded, but environment 
            variables are expanded when <c>expandEnvVars</c> is true.
            <para/>
            Quote marks are not processed. An argument of <c>"--a"</c>, with quote 
            marks, is not recognized as an option (these quote marks should be 
            removed before calling this method, e.g. 
            <see cref="M:Loyc.G.SplitCommandLineArguments(System.String)"/> handles this.)
            </remarks>
        </member>
    </members>
</doc>
