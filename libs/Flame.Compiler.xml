<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Flame.Compiler</name>
  </assembly>
  <members>
    <member name="T:Flame.Compiler.AbortCompilationException">
      <summary>
 Defines a type of error that indicates that
 a fatal error has occured, and the compiler
 should abort compilation as soon as possible.
 </summary>
    </member>
    <member name="P:Flame.Compiler.AbortCompilationException.Entry">
      <summary>
 Gets this fatal error's error message.
 </summary>
    </member>
    <member name="F:Flame.Compiler.AbortCompilationException.FatalErrorEntryTitle">
      <summary>
 Gets the default entry title for fatal errors.
 </summary>
    </member>
    <member name="F:Flame.Compiler.AbortCompilationException.FatalErrorEntryMessage">
      <summary>
 Gets the default entry message for fatal errors.
 </summary>
    </member>
    <member name="T:Flame.Compiler.UniqueTag">
      <summary>
 Defines a unique tag that is associated with some construct, like
 a control-flow block or a variable.
 Such a tag is named, but its name need not be unique, as the name
 has nothing to do with the tag's identity.
 </summary>
    </member>
    <member name="M:Flame.Compiler.UniqueTag.#ctor">
      <summary>
 Creates a new unique tag with the empty string as its name.
 </summary>
    </member>
    <member name="M:Flame.Compiler.UniqueTag.#ctor(System.String)">
      <summary>
 Creates a new unique tag and assigns it the given name.
 </summary>
    </member>
    <member name="P:Flame.Compiler.UniqueTag.Name">
      <summary>
 Gets this unique tag's name.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IMemberNode">
      <summary>
 Defines a node that directly contains one or more members.
 Such a node may have its members converted to other members.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IMemberNode.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IMetadataNode`1">
      <summary>
 Defines a metadata node: a node that contains an essential node, and
 some non-essential metadata.
 </summary>
    </member>
    <member name="P:Flame.Compiler.IMetadataNode`1.Value">
      <summary>
 Gets this metadata node's inner node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.INode">
      <summary>
 Defines a code node: the root type for independent code generation.
 Code nodes specify the *how* of generating code blocks based on a
 code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.INode.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.ICopyableNode`1">
      <summary>
 Defines a node that can be copied, thereby removing any dependencies
 on the original node.
 This is a useful interface for nodes that change their internal
 representation when they encounter a code generator, and can thus not
 be shared safely.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICopyableNode`1.Copy">
      <summary>
 Copies this node. A new node is returned that does not depend
 on this node.
 </summary>
      <remarks>
 Note that this method creates neither a deep nor a shallow clone.
 Instead, it creates a new node that does not depend on this
 node's internals.
 </remarks>
    </member>
    <member name="T:Flame.Compiler.INodeVisitor">
      <summary>
 Defines a node visitor: an object that transforms code nodes.
 </summary>
    </member>
    <member name="M:Flame.Compiler.INodeVisitor.Visit(Flame.Compiler.IExpression)">
      <summary>
 "Visits" an expression: an expression is taken as input and transformed into another expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.INodeVisitor.Visit(Flame.Compiler.IStatement)">
      <summary>
 "Visits" a statement: an statement is taken as input and transformed into another statement.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IPredicateNode">
      <summary>
 Defines a node that provides a fast path for predicate visitors, i.e.
 visitors that retrieve some of the node's properties, but do not
 in any way modify the node itself.
 </summary>
      <remarks>
 Implementing this interface is especially useful for nodes with a variable
 amount of children, which may thus have to perform complex logic or allocate
 a new block on every call to 'Accept', even though the nature of the
 node visitor makes this unnecessary.
 </remarks>
    </member>
    <member name="M:Flame.Compiler.IPredicateNode.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.VisitorExtensions.Aggregate(Flame.Compiler.INodeVisitor,Flame.Compiler.INodeVisitor)">
      <summary>
 Creates a node visitor that applies the given node visitors in sequence.
 </summary>
    </member>
    <member name="M:Flame.Compiler.VisitorExtensions.Aggregate(System.Collections.Generic.IEnumerable`1{Flame.Compiler.INodeVisitor})">
      <summary>
 Creates a node visitor that applies the given node visitors in sequence.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IExpression">
      <summary>
 Defines an expression: a code node focused on yielding a value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.IExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.IExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="P:Flame.Compiler.IExpression.Type">
      <summary>
 Gets the type of object that the expression will return.
 </summary>
    </member>
    <member name="P:Flame.Compiler.IExpression.IsConstant">
      <summary>
 Gets a boolean value that indicates if the expression is a constant expression.
 A constant expression has no side-effects, and depends solely on
 information that is known at compile-time.
 </summary>
      <remarks>
 Constant expressions can often be evaluated at compile-time,
 but this is not a requirement. For example, a sizeof(type) expression is
 constant by its very nature, but cannot be evaluated before the
 layout of the type has been defined.
 </remarks>
    </member>
    <member name="T:Flame.Compiler.IDelegateExpression">
      <summary>
 Defines common behavior for delegate expressions, i.e. expressions
 that can support creating invocation.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IDelegateExpression.CreateInvocationExpression(System.Collections.Generic.IEnumerable`1{Flame.Compiler.IExpression})">
      <summary>
 Creates an invocation expression based on this delegate expression and
 the given arguments.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IDelegateExpression.MakeGenericExpression(System.Collections.Generic.IEnumerable`1{Flame.IType})">
      <summary>
 Creates a generic delegate instantiation.
 </summary>
    </member>
    <member name="P:Flame.Compiler.IDelegateExpression.ParameterTypes">
      <summary>
 Gets the delegate expression's parameter types.
 </summary>
    </member>
    <member name="P:Flame.Compiler.IDelegateExpression.ReturnType">
      <summary>
 Gets the return type of the delegate expression's delegate.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IStatement">
      <summary>
 Defines a statement: a code node focused on executing an action.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.IStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="P:Flame.Compiler.IStatement.IsEmpty">
      <summary>
 Gets a boolean value that indicates if the statement is empty.
 An empty statement is a statement that will not influence the output of a function when compiled.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IVariable">
      <summary>
 Defines a common interface for variables.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IVariable.CreateGetExpression">
      <summary>
 Creates an expression that returns this variable's value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IVariable.CreateSetStatement(Flame.Compiler.IExpression)">
      <summary>
 Creates a statement that assigns the given value to this variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IVariable.CreateReleaseStatement">
      <summary>
 Creates a release statement for this variable. Release statements
 flag this variable for re-use within the scope of the current method.
 The actual re-use of the variable is the variable and the code generator's
 prerogative.
 </summary>
    </member>
    <member name="P:Flame.Compiler.IVariable.Type">
      <summary>
 Gets the variable's type.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IUnmanagedVariable">
      <summary>
 Defines an unmanaged variable: a variable whose address can be taken.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IUnmanagedVariable.CreateAddressOfExpression">
      <summary>
 Creates an expression that returns the address in memory of this variable.
 </summary>
      <returns />
    </member>
    <member name="T:Flame.Compiler.ICompilerFeedbackProvider">
      <summary>
 Defines common functionality for compiler feedback providers:
 objects that create various compiler logs for individual compilation
 processes.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICompilerFeedbackProvider.CreateLog(System.String)">
      <summary>
 Creates a new compiler log for the compilation process with the given
 name.
 </summary>
    </member>
    <member name="T:Flame.Compiler.ICompilerLog">
      <summary>
 Provides common functionality for compiler logs:
 objects that allow various modules in various stages of the compilation
 process to provide feedback to the user.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICompilerLog.LogError(Flame.Compiler.LogEntry)">
      <summary>
 Writes an error message to the compiler log.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICompilerLog.LogWarning(Flame.Compiler.LogEntry)">
      <summary>
 Writes a warning message to the compiler log.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICompilerLog.LogMessage(Flame.Compiler.LogEntry)">
      <summary>
 Writes an informative message to the compiler log.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICompilerLog.LogEvent(Flame.Compiler.LogEntry)">
      <summary>
 Writes an event message to the compiler log.
 </summary>
    </member>
    <member name="P:Flame.Compiler.ICompilerLog.Options">
      <summary>
 Gets the compiler log's options.
 </summary>
    </member>
    <member name="T:Flame.Compiler.ILogAssembly">
      <summary>
 Describes an assembly that has access to a compiler log.
 </summary>
    </member>
    <member name="P:Flame.Compiler.ILogAssembly.Log">
      <summary>
 Gets the assembly's compiler log.
 </summary>
    </member>
    <member name="M:Flame.Compiler.NodeExtensions.GetEssentialExpression(Flame.Compiler.IExpression)">
      <summary>
 Gets this expression's "essential" inner expression, i.e. its inner
 non-metadata expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.NodeExtensions.GetEssentialStatement(Flame.Compiler.IStatement)">
      <summary>
 Gets this statement's "essential" inner statement, i.e. its inner
 non-metadata statement.
 </summary>
    </member>
    <member name="M:Flame.Compiler.NodeExtensions.IsEffectful(Flame.Compiler.IExpression)">
      <summary>
 Tries to determine whether the given expression has side effects or not.
 The algorithm will err on the safe side when trying to determine this.
 </summary>
    </member>
    <member name="M:Flame.Compiler.NodeExtensions.CanDelay(Flame.Compiler.IStatement)">
      <summary>
 Tries to tell if the given statement's execution can be delayed without
 changing the semantics of the program. Note that performing the
 delaying transformation will not necessarily preserve the performance
 of the program.
 </summary>
      <remarks>
 Release statements can always be delayed.
 </remarks>
    </member>
    <member name="M:Flame.Compiler.ParameterExtensions.GetSetField(Flame.IParameter,Flame.IType,System.Boolean)">
      <summary>
 Gets the field this parameter sets. Returns null if no field is set.
 </summary>
      <param name="Parameter" />
      <returns />
    </member>
    <member name="M:Flame.Compiler.ParameterExtensions.GetSetProperty(Flame.IParameter,Flame.IType,System.Boolean)">
      <summary>
 Gets the property this parameter sets. Returns null if no property is set.
 </summary>
      <param name="Parameter" />
      <returns />
    </member>
    <member name="T:Flame.Compiler.IVariableNode">
      <summary>
 Defines a common interface for nodes that represent variable access.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IVariableNode.GetVariable">
      <summary>
 Gets the variable node's underlying variable.
 </summary>
    </member>
    <member name="P:Flame.Compiler.IVariableNode.Action">
      <summary>
 Gets the action associated with this variable node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.ISetVariableNode">
      <summary>
 Defines a variable node that performs an assignment operation.
 </summary>
    </member>
    <member name="P:Flame.Compiler.ISetVariableNode.Value">
      <summary>
 Gets the value this node assigns to the underlying variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IInitializedField.GetValue">
      <summary>
 Gets an expression that represents the field's value.
 </summary>
      <returns />
    </member>
    <member name="T:Flame.Compiler.ILambdaNode`1">
      <summary>
 Defines common functionality for lambda nodes: nodes whose contents
 belong to a separate method.
 </summary>
    </member>
    <member name="P:Flame.Compiler.ILambdaNode`1.Signature">
      <summary>
 Gets the lambda expression's method signature.
 </summary>
    </member>
    <member name="T:Flame.Compiler.ILambdaVisitor">
      <summary>
 Defines common functionality for node visitors that can deal with lambdas.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ILambdaVisitor.VisitBody(Flame.Compiler.IExpression,Flame.IMethod)">
      <summary>
 Visits the given expression, which logically belongs to the given method.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ILambdaVisitor.VisitBody(Flame.Compiler.IStatement,Flame.IMethod)">
      <summary>
 Visits the given statement, which logically belongs to the given method.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IBodyMethod.GetMethodBody">
      <summary>
 Gets the method's body statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.PrimitiveExpressionExtensions.IsPrimitiveExpressionType(Flame.IType)">
      <summary>
 Gets a boolean value that indicates if primitive expressions can be created for this type.
 </summary>
    </member>
    <member name="T:Flame.Compiler.ICompilerOptions">
      <summary>
 Defines common functionality for generic option dictionaries.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICompilerOptions.GetOption``1(System.String,T)">
      <summary>
 Gets the option associated with the given key.
 If no such option has been specified, returns the given default value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICompilerOptions.HasOption(System.String)">
      <summary>
 Gets a boolean value that indicates whether an option for the given key has been specified.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IStringOptions">
      <summary>
 Defines common functionality for string-serializable option dictionaries.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IStringOptions.GetOptions">
      <summary>
 Gets all string options.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IRandomAccessOptions">
      <summary>
 Defines common functionality for random-access options. These options
 can be manipulated and retrieved.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IRandomAccessOptions.SetOption``1(System.String,T)">
      <summary>
 Sets the option witht the given key to the given value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.EmptyCompilerLog.LogError(Flame.Compiler.LogEntry)">
      <summary>
 Writes an error message to the compiler log.
 </summary>
    </member>
    <member name="M:Flame.Compiler.EmptyCompilerLog.LogWarning(Flame.Compiler.LogEntry)">
      <summary>
 Writes a warning message to the compiler log.
 </summary>
    </member>
    <member name="M:Flame.Compiler.EmptyCompilerLog.LogMessage(Flame.Compiler.LogEntry)">
      <summary>
 Writes an informative message to the compiler log.
 </summary>
    </member>
    <member name="M:Flame.Compiler.EmptyCompilerLog.LogEvent(Flame.Compiler.LogEntry)">
      <summary>
 Writes an event message to the compiler log.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Flags">
      <summary>
 Defines a number of compiler option related constants and functions.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Flags.GetFlagOptionName(System.String)">
      <summary>
 Gets the given flag's (positive) option name.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Flags.GetNegatedFlagOptionName(System.String)">
      <summary>
 Gets the given flag's negated option name.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Flags.GetRemarkOptionName(System.String)">
      <summary>
 Gets the given remark type's option name.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Flags.CreateCauseNode(System.String)">
      <summary>
 Creates a markup node that represents the cause of some message,
 which happens to be the given option.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Flags.CreateCauseNode(System.String,System.String)">
      <summary>
 Creates a markup node that represents the cause of some message,
 which happens to be the given value assigned to the given option.
 </summary>
    </member>
    <member name="F:Flame.Compiler.Flags.EmitAssemblyOptionName">
      <summary>
 An option that instructs the compiler to emit assembly
 code instead of one or more binary files.
 </summary>
    </member>
    <member name="F:Flame.Compiler.Flags.CompileOnlyOptionName">
      <summary>
 An option that requests the compiler to compile its input into binaries,
 but stop before linking said binaries into an executable. This
 may not make much sense on platforms that do not typically use or
 require static linking, such as high-level languages or
 virtual machines.
 </summary>
    </member>
    <member name="F:Flame.Compiler.Flags.VerifyOnlyFlagName">
      <summary>
 A flag that requests the compiler to verify that an assembly
 is correct, but not do anything more than that.
 </summary>
    </member>
    <member name="F:Flame.Compiler.Flags.WholeProgramFlagName">
      <summary>
 A flag that assures the compiler that the input it has been given
 is indeed the entirety of the program: it can legally optimize
 aggresively. For example, unused public members can be discarded.
 </summary>
    </member>
    <member name="M:Flame.Compiler.FlagExtensions.GetFlag(Flame.Compiler.ICompilerOptions,System.String,System.Boolean)">
      <summary>
 Gets the given flag from this compiler options dictionary.
 This differs from 'Options.GetValue&lt;bool&gt;' in that
 it appends an 'f' prefix to the flag's name before calling
 the aforementioned option. If said option does not exist,
 this function also checks if no 'fno-' prefixed
 option has been defined for this flag, in which case its value is
 negated.
 </summary>
    </member>
    <member name="M:Flame.Compiler.FlagExtensions.ShouldRemark(Flame.Compiler.ICompilerOptions,System.String,System.Boolean)">
      <summary>
 Finds out if remarks of the given remark type should be made, according
 to the given compiler options and default value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.FlagExtensions.ShouldRemark(Flame.Compiler.ICompilerOptions,System.String)">
      <summary>
 Finds out if remarks of the given remark type should be made, according
 to the given compiler options. Unless the given remark type was
 requested by the options, false will be returned. That is, this function's
 result defaults to false.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IFlowExpression">
      <summary>
 Defines a control flow expression: an expression that interacts with a control flow
 visitor.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IFlowExpression.AcceptFlow``2(Flame.Compiler.IFlowVisitor`2{TState,TFlow})">
      <summary>
 Accepts and interacts with a flow visitor.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IFlowStatement">
      <summary>
 Defines a control flow statement: a statement that interacts with a control flow
 visitor.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IFlowStatement.AcceptFlow``2(Flame.Compiler.IFlowVisitor`2{TState,TFlow})">
      <summary>
 Accepts and interacts with a flow visitor.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IFlowVisitor`2">
      <summary>
 Defines a flow visitor: a node visitor that flow nodes can interact with.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IFlowVisitor`2.CreateCollapsedFlow(TState,TDelta)">
      <summary>
 Computes the "sum" of a flow state and a control flow delta.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IFlowVisitor`2.CreateDeltaFlow(TState,TState)">
      <summary>
 Computes the "difference" between two flow states, such that
 the "sum" of the first flow state and the result of this operation
 results in the second state.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IFlowVisitor`2.CreateSequenceFlow(TDelta,TDelta)">
      <summary>
 Creates a flow delta that represents the sequential execution of
 two flow deltas.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IFlowVisitor`2.CreateSelectFlow(TDelta,TDelta)">
      <summary>
 Creates a flow delta that represents selecting precisely one of two
 flow deltas.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IFlowVisitor`2.CreateLoopFlow(Flame.Compiler.UniqueTag,TDelta)">
      <summary>
 Creates a flow delta that will be executed zero or more
 times.
 </summary>
    </member>
    <member name="P:Flame.Compiler.IFlowVisitor`2.CurrentFlow">
      <summary>
 Gets or sets the current flow state.
 </summary>
    </member>
    <member name="P:Flame.Compiler.IFlowVisitor`2.TerminatedFlow">
      <summary>
 Gets a flow delta that represents flow termination:
 sequential flow that succeeds it will never be executed.
 </summary>
    </member>
    <member name="T:Flame.Compiler.ILocalFlowVisitor`2">
      <summary>
 Defines common functionality for flow visitors with a specific intrest
 in local flow.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ILocalFlowVisitor`2.CreateTerminatedLocalFlow(Flame.Compiler.UniqueTag)">
      <summary>
 Creates a terminated local flow delta, which terminates the current
 iteration of the given block, but does not end the function's execution.
 </summary>
    </member>
    <member name="P:Flame.Compiler.ILocalFlowVisitor`2.TerminatedGlobalFlow">
      <summary>
 Gets a flow delta that represents global flow termination:
 this signifies the end of this function call.
 </summary>
    </member>
    <member name="M:Flame.Compiler.OperatorExpressionExtensions.GetOperatorOverload(Flame.Operator,System.Collections.Generic.IEnumerable`1{Flame.Compiler.IExpression})">
      <summary>
 Gets the best operator overload for the given operator with the given arguments.
 </summary>
    </member>
    <member name="M:Flame.Compiler.OperatorExpressionExtensions.CreateOperatorInvocation(Flame.Operator,System.Collections.Generic.IEnumerable`1{Flame.Compiler.IExpression})">
      <summary>
 Creates an invocation expression for this operator with the given arguments.
 </summary>
    </member>
    <member name="T:Flame.Compiler.SourceGridPosition">
      <summary>
 Represents source code on a given line and at a given offset.
 </summary>
    </member>
    <member name="T:Flame.Compiler.ISourceDocument">
      <summary>
 Describes a source document.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ISourceDocument.GetLine(System.Int32)">
      <summary>
 Gets the source line with the given index.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ISourceDocument.ToGridPosition(System.Int32)">
      <summary>
 Converts a source code character index to a grid position.
 </summary>
    </member>
    <member name="P:Flame.Compiler.ISourceDocument.Identifier">
      <summary>
 Gets the source document's identifier.
 </summary>
    </member>
    <member name="P:Flame.Compiler.ISourceDocument.Source">
      <summary>
 Gets the source document's source code.
 </summary>
    </member>
    <member name="P:Flame.Compiler.ISourceDocument.LineCount">
      <summary>
 Gets the line count of this source document.
 </summary>
    </member>
    <member name="T:Flame.Compiler.SourceDocument">
      <summary>
 Provides a straightforward source document implementation.
 </summary>
    </member>
    <member name="M:Flame.Compiler.SourceDocument.GetLine(System.Int32)">
      <summary>
 Gets the source line with the given index.
 </summary>
    </member>
    <member name="M:Flame.Compiler.SourceDocument.ToGridPosition(System.Int32)">
      <summary>
 Converts a source code character index to a grid position.
 </summary>
    </member>
    <member name="P:Flame.Compiler.SourceDocument.LineCount">
      <summary>
 Gets the line count of this source document.
 </summary>
    </member>
    <member name="P:Flame.Compiler.SourceDocument.CharacterCount">
      <summary>
 Gets the number of characters in the source file.
 </summary>
    </member>
    <member name="P:Flame.Compiler.SourceDocument.LineLengths">
      <summary>
 Gets document's line length for every line.
 </summary>
    </member>
    <member name="P:Flame.Compiler.SourceDocument.CumulativeLineLengths">
      <summary>
 Gets document's cumulative line length for every line.
 </summary>
    </member>
    <member name="P:Flame.Compiler.SourceDocument.Identifier">
      <summary>
 Gets the source document's identifier.
 </summary>
    </member>
    <member name="P:Flame.Compiler.SourceDocument.Source">
      <summary>
 Gets the source document's source code.
 </summary>
    </member>
    <member name="T:Flame.Compiler.LogEntry">
      <summary>
 Describes a compiler log entry.
 </summary>
    </member>
    <member name="M:Flame.Compiler.LogEntry.#ctor(System.String)">
      <summary>
 Creates a new log entry from the given name.
 </summary>
    </member>
    <member name="M:Flame.Compiler.LogEntry.#ctor(System.String,System.String)">
      <summary>
 Creates a new log entry from the given name and message.
 </summary>
    </member>
    <member name="M:Flame.Compiler.LogEntry.#ctor(System.String,Flame.Compiler.SourceLocation)">
      <summary>
 Creates a new log entry from the given name and source location.
 </summary>
    </member>
    <member name="M:Flame.Compiler.LogEntry.#ctor(System.String,System.String,Flame.Compiler.SourceLocation)">
      <summary>
 Creates a new log entry from the given name, message and source
 location.
 </summary>
    </member>
    <member name="M:Flame.Compiler.LogEntry.WithLocation(Flame.Compiler.SourceLocation)">
      <summary>
 Creates a new log entry that includes diagnostics information for
 the given source location.
 </summary>
    </member>
    <member name="P:Flame.Compiler.LogEntry.Message">
      <summary>
 Gets the log entry's entire error message.
 </summary>
    </member>
    <member name="P:Flame.Compiler.LogEntry.Name">
      <summary>
 Gets the log entry's name.
 </summary>
    </member>
    <member name="P:Flame.Compiler.LogEntry.Contents">
      <summary>
 Gets the log entry's contents.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CompilerLogExtensions.LogError(Flame.Compiler.ICompilerLog,System.String)">
      <summary>
 Logs an error to the compiler log based on the given error message.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CompilerLogExtensions.LogEvent(Flame.Compiler.ICompilerLog,System.String)">
      <summary>
 Logs an event to the compiler log based on the given event name.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CompilerLogExtensions.LogException(Flame.Compiler.ICompilerLog,System.Exception)">
      <summary>
 Logs an exception to the compiler log as an error.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CompilerLogExtensions.Concat(Flame.Compiler.SourceLocation,Flame.Compiler.SourceLocation)">
      <summary>
 "Concatenates" two source locations.
 The resulting source location is a source location that contains every
 position the argument locations contain, as well as every position inbetween.
 The resulting location's source document is the right-hand argument's document
 if the left-hand's document is null. Otherwise, it is the left-hand argument's
 document.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CompilerLogExtensions.CreateRemarkDiagnosticsNode(Flame.Compiler.SourceLocation,System.String)">
      <summary>
 Creates a remark node with the given title that contains
 source code diagnostics for this source location.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CompilerLogExtensions.CreateDiagnosticsNode(Flame.Compiler.SourceLocation)">
      <summary>
 Creates a source code diagnostics node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.SourceLocation">
      <summary>
 Defines a region of text in a source document.
 </summary>
    </member>
    <member name="M:Flame.Compiler.SourceLocation.#ctor(Flame.Compiler.ISourceDocument)">
      <summary>
 Creates a new source location from the given document.
 </summary>
    </member>
    <member name="M:Flame.Compiler.SourceLocation.#ctor(Flame.Compiler.ISourceDocument,System.Int32)">
      <summary>
 Creates a new source location from the given document and position.
 </summary>
    </member>
    <member name="M:Flame.Compiler.SourceLocation.#ctor(Flame.Compiler.ISourceDocument,System.Int32,System.Int32)">
      <summary>
 Creates a new source location from the given document, position and length.
 </summary>
    </member>
    <member name="P:Flame.Compiler.SourceLocation.HasLocation">
      <summary>
 Finds out if this source location actually identifies a location,
 instead of only specifying a source document.
 </summary>
    </member>
    <member name="P:Flame.Compiler.SourceLocation.GridPosition">
      <summary>
 Gets the source location's position in the source document's row-column grid.
 </summary>
    </member>
    <member name="P:Flame.Compiler.SourceLocation.Document">
      <summary>
 Gets the source document this source location is associated with.
 </summary>
    </member>
    <member name="P:Flame.Compiler.SourceLocation.Position">
      <summary>
 Gets the position in the source document.
 </summary>
    </member>
    <member name="P:Flame.Compiler.SourceLocation.Length">
      <summary>
 Gets the source location's length.
 </summary>
    </member>
    <member name="M:Flame.Compiler.SilentLog.LogError(Flame.Compiler.LogEntry)">
      <summary>
 Writes an error message to the compiler log.
 </summary>
    </member>
    <member name="M:Flame.Compiler.SilentLog.LogWarning(Flame.Compiler.LogEntry)">
      <summary>
 Writes a warning message to the compiler log.
 </summary>
    </member>
    <member name="M:Flame.Compiler.SilentLog.LogMessage(Flame.Compiler.LogEntry)">
      <summary>
 Writes an informative message to the compiler log.
 </summary>
    </member>
    <member name="M:Flame.Compiler.SilentLog.LogEvent(Flame.Compiler.LogEntry)">
      <summary>
 Writes an event message to the compiler log.
 </summary>
    </member>
    <member name="T:Flame.Compiler.MethodGroupExtensions">
      <summary>
 Provides extensions for method groups:
 groups of methods that are contained in an expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.MethodGroupExtensions.GetMethodGroup(Flame.Compiler.IExpression)">
      <summary>
 Gets the method group contained in this expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.MethodGroupExtensions.GetDelegateParameterTypes(Flame.Compiler.IExpression)">
      <summary>
 Gets an expression's delegate parameter types.
 </summary>
    </member>
    <member name="M:Flame.Compiler.MethodGroupExtensions.FilterBaseDelegates(System.Collections.Generic.IEnumerable`1{Flame.Compiler.IExpression})">
      <summary>
 Filters out all delegates in the given sequence of method that have
 an override or implementation which is also present in the given array.
 </summary>
    </member>
    <member name="M:Flame.Compiler.MethodGroupExtensions.GetBestDelegates(System.Collections.Generic.IEnumerable`1{Flame.Compiler.IExpression},Flame.IType[])">
      <summary>
 Gets the delegates that match the specified parameter types best.
 </summary>
      <param name="ParameterTypes" />
      <returns />
    </member>
    <member name="M:Flame.Compiler.MethodGroupExtensions.GetBestDelegate(System.Collections.Generic.IEnumerable`1{Flame.Compiler.IExpression},Flame.IType[])">
      <summary>
 Gets the delegate expression that matches the specifies parameter
 types best.
 </summary>
    </member>
    <member name="T:Flame.Compiler.WarningDescription">
      <summary>
 Describes a type of warning or warning group.
 </summary>
    </member>
    <member name="M:Flame.Compiler.WarningDescription.#ctor(System.String)">
      <summary>
 Creates a warning description with the given name.
 This warning is turned off by default.
 </summary>
    </member>
    <member name="M:Flame.Compiler.WarningDescription.#ctor(System.String,System.Boolean)">
      <summary>
 Creates a warning description with the given name.
 A boolean flag determines whether the warning is turned
 on or off by default.
 </summary>
    </member>
    <member name="M:Flame.Compiler.WarningDescription.#ctor(System.String,Flame.Compiler.WarningDescription)">
      <summary>
 Creates a warning description with the given name and parent
 warning description. Its default behavior is inherited from
 the parent warning description.
 </summary>
    </member>
    <member name="M:Flame.Compiler.WarningDescription.#ctor(System.String,Flame.Compiler.WarningDescription,System.Boolean)">
      <summary>
 Creates a warning description with the given name and parent
 warning description. A boolean flag determines whether
 the warning is turned on or off by default.
 </summary>
    </member>
    <member name="M:Flame.Compiler.WarningDescription.#ctor(System.String,System.String,Flame.Compiler.WarningDescription,System.Boolean)">
      <summary>
 Creates a warning description with the positive and negative options,
 as well as a parent warning description. A boolean flag determines
 whether the warning is turned on or off by default.
 </summary>
    </member>
    <member name="M:Flame.Compiler.WarningDescription.CreateMessage(Pixie.IMarkupNode)">
      <summary>
 Creates a warning message node for this warning, which consists
 of the given message node, and a cause node for this warning.
 </summary>
    </member>
    <member name="M:Flame.Compiler.WarningDescription.CreateMessage(System.String)">
      <summary>
 Creates a warning message node this warning, which consists
 of the given message node, and a cause node for this warning.
 </summary>
    </member>
    <member name="M:Flame.Compiler.WarningDescription.TryUseWarning(Flame.Compiler.ICompilerOptions,System.Boolean@)">
      <summary>
 Tries to find a boolean value that determines whether this
 warning should be used. Returns true if this can be done,
 otherwise false. The result, if any, is stored in a boolean reference.
 </summary>
    </member>
    <member name="M:Flame.Compiler.WarningDescription.UseWarning(Flame.Compiler.ICompilerOptions)">
      <summary>
 Determines if this warning should be used according to the
 given set of compiler options.
 </summary>
    </member>
    <member name="P:Flame.Compiler.WarningDescription.IsRoot">
      <summary>
 Checks if this warning is a "root" warning: i.e. it is not
 dependent on any other warnings or warning groups.
 This implies that its "parent" is null.
 </summary>
    </member>
    <member name="P:Flame.Compiler.WarningDescription.HasWarningOption">
      <summary>
 Gets a boolean flag that tells if this warning has a non-null,
 non-empty (positive) warning option.
 </summary>
    </member>
    <member name="P:Flame.Compiler.WarningDescription.HasNegatedWarningOption">
      <summary>
 Gets a boolean flag that tells if this warning has a non-null,
 non-empty negated warning option.
 </summary>
    </member>
    <member name="P:Flame.Compiler.WarningDescription.CauseNode">
      <summary>
 Gets a cause node for this warning.
 </summary>
    </member>
    <member name="P:Flame.Compiler.WarningDescription.WarningOption">
      <summary>
 Gets this warning's (positive) warning option, which enables
 the warning if it is set to true.
 </summary>
    </member>
    <member name="P:Flame.Compiler.WarningDescription.NegatedWarningOption">
      <summary>
 Gets this warning's negated warning option, which disables
 the warning if it is set to true. The positive warning option
 takes precedence over this option.
 </summary>
    </member>
    <member name="P:Flame.Compiler.WarningDescription.Parent">
      <summary>
 Gets this warning or warning group's "parent": if this warning has
 not been explicitly turned on or off, then the parent's value is
 used by this instance.
 </summary>
    </member>
    <member name="P:Flame.Compiler.WarningDescription.IsDefault">
      <summary>
 Gets a boolean value that tells if this warning is turned on by
 default. This behavior can be overriden by the parent warning group.
 </summary>
    </member>
    <member name="F:Flame.Compiler.WarningDescription.WarningOptionPrefix">
      <summary>
 Gets the prefix string for warning options.
 </summary>
    </member>
    <member name="F:Flame.Compiler.WarningDescription.NegatedWarningOptionPrefix">
      <summary>
 Gets the prefix string for negated warning options.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Warnings.Everything">
      <summary>
 The root warning group, which covers all warnings.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Warnings.All">
      <summary>
 The "conventional" warning group, which is turned on by default.
 It corresponds to -Wall and -Wno-all.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Warnings.Build">
      <summary>
 The "build" warning group, which is turned on by default.
 This warning group contains warnings that relate to the build
 process, such as missing dependencies or unused options.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Warnings.Extra">
      <summary>
 The "extra" warning group, which contains a number of possibly
 useful warnings that are not turned on by default.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Warnings.PedanticRoot">
      <summary>
 The -pedantic option, which turns on non-essential warnings that typically
 relate to language-level constructs, especially non-standard extensions.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Warnings.Pedantic">
      <summary>
 The -Wpedantic and -Wno-pedantic options. These two are a sub-warning
 group of -pedantic. If you want to create a warning that fires
 only in pedantic mode, use these as a parent warning description,
 rather than -pedantic.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Warnings.Shadow">
      <summary>
 The warning description for shadowed locals.
 </summary>
      <example>
 for (int i = 0; i &lt; 5; i++)
 {
     for (int i = 0; i &lt; 5; i++)
              ^~~~~
     {

     }
 }
 </example>
    </member>
    <member name="P:Flame.Compiler.Warnings.GenericOperators">
      <summary>
 The warning name for undefined operators on generic parameters.
 </summary>
      <example>
 T z = x + y;
       ^~~~~
 </example>
    </member>
    <member name="P:Flame.Compiler.Warnings.Operators">
      <summary>
 The warning name for undefined operators.
 </summary>
      <example>
 bool x = true, y = false;
 bool z = x + y;
          ^~~~~
 </example>
    </member>
    <member name="P:Flame.Compiler.Warnings.Bitcast">
      <summary>
 The warning description for bitcasts.
 </summary>
      <example>
 int x = -5;
 bit32 y = (bit32)x;
 bit16 z = (bit16)y;
            ^~~~~
 x = (int)(bit32)z;
 </example>
    </member>
    <member name="P:Flame.Compiler.Warnings.MeaninglessCast">
      <summary>
 The warning description for meaningless casts.
 </summary>
      <example>
 int x = 5;
 int y = (int)x;
          ^~~
 </example>
    </member>
    <member name="P:Flame.Compiler.Warnings.ConstantDiscarded">
      <summary>
 The warning name for discarded constants.
 </summary>
      <example>
 5;
  ^
 </example>
    </member>
    <member name="P:Flame.Compiler.Warnings.ConstantAssert">
      <summary>
 The warning name for constant assertions.
 </summary>
      <example>
 assert(true);
 ^~~~~~
 </example>
    </member>
    <member name="P:Flame.Compiler.Warnings.CSharpUsingAlias">
      <summary>
 The warning name for C# style alias directives, which are technically
 not legal D#.
 </summary>
      <example>
 using x = y;
 ^~~~~
 </example>
    </member>
    <member name="P:Flame.Compiler.Warnings.CppUsingNamespace">
      <summary>
 The warning name for C++ style directives, which are not legal D#.
 </summary>
      <example>
 using namespace x;
       ^~~~~~~~~
 </example>
    </member>
    <member name="P:Flame.Compiler.Warnings.EmptyBody">
      <summary>
 The warning name for control flow statements with empty bodies.
 </summary>
      <example>
 while (flag);
             ^
 </example>
    </member>
    <member name="P:Flame.Compiler.Warnings.DanglingElse">
      <summary>
 The warning name for dangling else statements.
 </summary>
      <example>
 if (x)
 if (y) return x;
 else return y;
 ^~~~
 </example>
    </member>
    <member name="P:Flame.Compiler.Warnings.LonelyTry">
      <summary>
 The warning name for try statements without associated catch or finally blocks.
 </summary>
      <example>
 try { Console.WriteLine("Hi"); }
 ^~~
 return 0;
 </example>
    </member>
    <member name="P:Flame.Compiler.Warnings.HiddenNullCheck">
      <summary>
 The warning name for hidden or convoluted null checks.
 </summary>
      <example>
 public static int Derp(object x)
 {
     if (x is object) return 0;
           ^~~~~~~~~
     else return 1;
 }
 </example>
    </member>
    <member name="P:Flame.Compiler.Warnings.IncompleteInitialization">
      <summary>
 The warning name for incomplete initialization of container types.
 </summary>
      <example>
 public static int[] Herp(int First, int Second)
 {
     return new int[2] { First };
                       ^~~~~~~~~
 }
 </example>
    </member>
    <member name="P:Flame.Compiler.Warnings.VariableLengthInitialization">
      <summary>
 The warning name for constant initialization of variable-length container types.
 </summary>
      <example>
 public static int[] Derp(int Size, int First)
 {
     return new int[Size] { First };
                          ^~~~~~~~~
 }
 </example>
    </member>
    <member name="P:Flame.Compiler.Warnings.UnusedOption">
      <summary>
 A warning name for unused compiler options. Note, however, that
 this warning does not belong to the more general unused member
 warning group for source-level constructs (-Wunused). Instead,
 it belongs to -Wbuild, as this warning concerns the build process,
 rather than the source code.
 </summary>
      <example>
 compiler File.src -unknown-option
                   ^~~~~~~~~~~~~~~
 </example>
    </member>
    <member name="P:Flame.Compiler.Warnings.MissingDependency">
      <summary>
 A warning name for missing library dependencies.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Warnings.UnknownRuntime">
      <summary>
 A warning name for unknown/unresolved runtime specifications.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Warnings.UnknownEnvironment">
      <summary>
 A warning name for unknown/unresolved environment specifications.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Warnings.Unused">
      <summary>
 A warning group for declarations that are never used.
 </summary>
    </member>
    <member name="T:Flame.Compiler.ICodeGenerator">
      <summary>
 Provides common functionality for code generators. Code generators take care of the generation of individual blocks of code.
 </summary>
      <remarks>
 All code generators must implement this interface.
 They may, however, refuse certain block creation/emit requests by returning null.
 It is up to the client to use some workaround for the issue, or log an error/throw an exception if it can't.
 For example: a code generator may choose to refuse to generate binary blocks for non-intrinsic types.
 A binary expression will then likely try to circumvent the issue by emitting a call an the operator overload.
 </remarks>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitVoid">
      <summary>
 Creates a void block, which is the equivalent of the empty statement.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitSequence(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a block that executes that given blocks in sequence.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitTagged(Flame.Compiler.UniqueTag,Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a tagged block: a block that supports "break" and "continue".
 "break" means: jump to the end of this block; "continue" means:
 jump to the start of this block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitIfElse(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a block that executes and returns the given if body if the
 given condition block evaluates to true. Otherwise, the given else
 block is executed.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitPop(Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a block that 'pops' a value: the value of the given code block
 is discarded, and replaced by void.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitReturn(Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a return block: a block that terminates the containing
 function's exection and transfers control back to the calling block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitBreak(Flame.Compiler.UniqueTag)">
      <summary>
 Creates a break block: a block that 'breaks' out of the given enclosing block:
 control is transferred to the block that trails said block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitContinue(Flame.Compiler.UniqueTag)">
      <summary>
 Creates a continue block: a block that stops the execution of the
 given enclosing block's body, and starts the next iteration.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitBoolean(System.Boolean)">
      <summary>
 Creates a boolean constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitChar(System.Char)">
      <summary>
 Creates a character constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitUInt8(System.UInt8)">
      <summary>
 Creates an 8-bit unsigned integer constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitInt8(System.Int8)">
      <summary>
 Creates an 8-bit signed integer constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitBit8(System.Bit8)">
      <summary>
 Creates an 8-bit constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitUInt16(System.UInt16)">
      <summary>
 Creates a 16-bit unsigned integer constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitInt16(System.Int16)">
      <summary>
 Creates a 16-bit signed integer constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitBit16(System.Bit16)">
      <summary>
 Creates a 16-bit constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitUInt32(System.UInt32)">
      <summary>
 Creates a 32-bit unsigned integer constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitInt32(System.Int32)">
      <summary>
 Creates a 32-bit signed integer constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitBit32(System.Bit32)">
      <summary>
 Creates a 32-bit constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitFloat32(System.Float32)">
      <summary>
 Creates a 32-bit floating point number constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitUInt64(System.UInt64)">
      <summary>
 Creates a 64-bit unsigned integer constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitInt64(System.Int64)">
      <summary>
 Creates a 64-bit signed integer constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitBit64(System.Bit64)">
      <summary>
 Creates a 64-bit constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitFloat64(System.Float64)">
      <summary>
 Creates a 64-bit floating point number constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitString(System.String)">
      <summary>
 Creates a string constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitNull">
      <summary>
 Creates a null constant block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitBinary(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Operator)">
      <summary>
 Creates a binary operation block that performs the given operation
 on the given values.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitUnary(Flame.Compiler.ICodeBlock,Flame.Operator)">
      <summary>
 Creates a unary operation block that performs the given operation
 on the given value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitTypeBinary(Flame.Compiler.ICodeBlock,Flame.IType,Flame.Operator)">
      <summary>
 Emits a binary operation that takes a value and a type as arguments.
 Casts, conversions and isinstance tests all use this format.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitDefaultValue(Flame.IType)">
      <summary>
 Creates a block that contains the default value for the given type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitMethod(Flame.IMethod,Flame.Compiler.ICodeBlock,Flame.Operator)">
      <summary>
 Creates a block that contains a delegate to the given method with the given caller.
 Said caller may be null, if the method is static. The given operator
 is used to create the method with, which may encode information such
 as virtualness.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitInvocation(Flame.Compiler.ICodeBlock,System.Collections.Generic.IEnumerable`1{Flame.Compiler.ICodeBlock})">
      <summary>
 Creates a block that invokes the given method with the given
 arguments.
 </summary>
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitNewArray(Flame.IType,System.Collections.Generic.IEnumerable`1{Flame.Compiler.ICodeBlock})">
      <summary>
 Creates a new array of the specified element type with the specified dimensions.
 </summary>
      <param name="Dimensions" />
    </member>
    <member name="M:Flame.Compiler.ICodeGenerator.EmitNewVector(Flame.IType,System.Collections.Generic.IReadOnlyList`1{System.Int32})">
      <summary>
 Creates a new vector of the specified element type with the specified dimensions.
 </summary>
      <param name="Dimensions" />
    </member>
    <member name="T:Flame.Compiler.IWhileCodeGenerator">
      <summary>
 A code generator that supports creating 'while' blocks.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IWhileCodeGenerator.EmitWhile(Flame.Compiler.UniqueTag,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a block that repeats the given body as long as the given condition
 block evaluates to true.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IDoWhileCodeGenerator">
      <summary>
 A code generator that supports creating 'do...while' blocks.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IDoWhileCodeGenerator.EmitDoWhile(Flame.Compiler.UniqueTag,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a block that executes the given body once, and then keeps on executing
 it as long as the given condition block evaluates to true.
 </summary>
    </member>
    <member name="T:Flame.Compiler.ICodeBlock">
      <summary>
 Defines a code block: an atomic unit of code that was created by a code
 generator.
 </summary>
    </member>
    <member name="P:Flame.Compiler.ICodeBlock.CodeGenerator">
      <summary>
 Gets the code generator that created this code block.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IUnmanagedCodeGenerator">
      <summary>
 Defines an unmanaged code generator interface: a code generator
 that can also perform a number of low-level tricks.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IUnmanagedCodeGenerator.EmitDereferencePointer(Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a code block that dereferences the given pointer block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IUnmanagedCodeGenerator.EmitStoreAtAddress(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a code block that stores the value in a code block
 in the given pointer block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IUnmanagedCodeGenerator.GetUnmanagedElement(Flame.Compiler.ICodeBlock,System.Collections.Generic.IEnumerable`1{Flame.Compiler.ICodeBlock})">
      <summary>
 Gets an unmanaged emit variable that represents an element of
 a container type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IUnmanagedCodeGenerator.GetUnmanagedField(Flame.IField,Flame.Compiler.ICodeBlock)">
      <summary>
 Gets an unmanaged emit variable that represents the given field
 of the value represented by the given target code block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IUnmanagedCodeGenerator.EmitSizeOf(Flame.IType)">
      <summary>
 Creates a block that contains the run-time size of a variable of the
 given type.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IBranchingCodeGenerator">
      <summary>
 Defines common functionality for code generators that use branches.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IBranchingCodeGenerator.CreateLabel">
      <summary>
 Creates a new label.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeGeneratorExtensions.EmitAdd(Flame.Compiler.ICodeGenerator,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a block that adds the given values.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeGeneratorExtensions.EmitSubtract(Flame.Compiler.ICodeGenerator,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a block that subtracts the given values.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeGeneratorExtensions.EmitMultiply(Flame.Compiler.ICodeGenerator,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a block that multiplies the given values.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeGeneratorExtensions.EmitDivide(Flame.Compiler.ICodeGenerator,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a block that divides the given values.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeGeneratorExtensions.EmitInvocation(Flame.Compiler.ICodeGenerator,Flame.IMethod,Flame.Compiler.ICodeBlock,System.Collections.Generic.IEnumerable`1{Flame.Compiler.ICodeBlock})">
      <summary>
 Creates a block that invokes the given method on the given
 calling block. Virtual methods are called virtually, nonvirtual methods
 are called directly.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeGeneratorExtensions.EmitInvocation(Flame.Compiler.ICodeGenerator,Flame.IMethod,Flame.Compiler.ICodeBlock,Flame.Operator,System.Collections.Generic.IEnumerable`1{Flame.Compiler.ICodeBlock})">
      <summary>
 Creates a block that invokes the given method on the given
 calling block and arguments. An operator is given that tells
 how the calling block is used.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeGeneratorExtensions.GetOrDeclareLocal(Flame.Compiler.Emit.IMethodStructureGenerator,Flame.Compiler.UniqueTag,Flame.Compiler.IVariableMember)">
      <summary>
 Gets the local variable with the given tag if it exists already, or
 creates one with the given tag based on the given variable
 member if it doesn't.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeGeneratorExtensions.GetOrDeclareUnmanagedLocal(Flame.Compiler.Emit.IUnmanagedMethodStructureGenerator,Flame.Compiler.UniqueTag,Flame.Compiler.IVariableMember)">
      <summary>
 Gets the unmanaged local variable with the given tag if it
 exists already, or creates one with the given tag based on
 the given variable member if it doesn't.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IVariableMember">
      <summary>
 Defines a variable member: a (fairly) complete description of a variable.
 </summary>
    </member>
    <member name="P:Flame.Compiler.IVariableMember.VariableType">
      <summary>
 Gets the variable's type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeBuilder.AddFormattedLine(System.String)">
      <summary>
 Adds a line to the code builder that has already been formatted.
 The current indentation is adjusted to fit the line.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeBuilder.GetCodeLine(System.Int32,System.Int32)">
      <summary>
 Gets the code builder's first non-whitespace line of code,
 starting at the given start line and ending after having examined the given number of lines.
 If no matching line is found, a whiteline is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeBuilder.GetLastCodeLine(System.Int32,System.Int32)">
      <summary>
 Gets the code builder's last non-whitespace last of code,
 starting at the given start line and ending after having examined the given number of lines.
 If no matching line is found, a whiteline is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeBuilder.GetCodeLine(System.Int32)">
      <summary>
 Gets the code builder's first non-whitespace line of code,
 starting at the given start line.
 If matching line is found, a whiteline is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeBuilder.GetLastCodeLine(System.Int32)">
      <summary>
 Gets the code builder's last non-whitespace line of code,
 starting at the given start line.
 If matching line is found, a whiteline is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeBuilder.GetCodeLineCount(System.Int32,System.Int32)">
      <summary>
 Counts the number of non-whitespace code lines in a region
 with the given length, starting at the given start line.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeBuilder.GetCodeLineCount(System.Int32)">
      <summary>
 Counts the number of non-whitespace code lines in a region
 from the given start index to the end of the code builder.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeBuilder.InsertLine(System.Int32,Flame.Compiler.CodeLine)">
      <summary>
 Inserts a code line at the given index.
 </summary>
    </member>
    <member name="P:Flame.Compiler.CodeBuilder.FirstCodeLine">
      <summary>
 Gets the code builder's first non-whitespace line of code.
 </summary>
    </member>
    <member name="P:Flame.Compiler.CodeBuilder.LastCodeLine">
      <summary>
 Gets the code builder's last non-whitespace line of code.
 </summary>
    </member>
    <member name="P:Flame.Compiler.CodeBuilder.CodeLineCount">
      <summary>
 Gets the total amount of non-whitespace code lines in the code builder.
 </summary>
    </member>
    <member name="P:Flame.Compiler.CodeBuilder.LineCount">
      <summary>
 Gets the number of lines the code builder currently has.
 </summary>
    </member>
    <member name="P:Flame.Compiler.CodeBuilder.IsWhitespace">
      <summary>
 Gets a boolean value that tells if this code builder consists of whitespace only.
 </summary>
    </member>
    <member name="P:Flame.Compiler.CodeBuilder.this">
      <summary>
 Gets or sets the code line at the given index.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeLine.GetTotalLength(System.Int32)">
      <summary>
 Gets the code line's total length. This includes the line's
 indentation.
 </summary>
    </member>
    <member name="P:Flame.Compiler.CodeLine.IsWhiteline">
      <summary>
 Gets a boolean flag that indicates if this code line is a line of whitespace, i.e. contains only a single null character ('\0').
 A truly empty code line (text "") will not be output by a CodeBuilder. A whiteline, however, will be.
 </summary>
    </member>
    <member name="P:Flame.Compiler.CodeLine.IsEmpty">
      <summary>
 Gets a boolean value that indicates if this code line corresponds to the empty line pattern.
 </summary>
    </member>
    <member name="P:Flame.Compiler.CodeLine.IsWhitespace">
      <summary>
 Gets a boolean value that indicates if this code line is whitespace.
 </summary>
    </member>
    <member name="P:Flame.Compiler.CodeLine.Length">
      <summary>
 Gets the code line's text length.
 </summary>
    </member>
    <member name="P:Flame.Compiler.CodeLine.Text">
      <summary>
 Gets or sets the code line's text.
 </summary>
    </member>
    <member name="P:Flame.Compiler.CodeLine.Indentation">
      <summary>
 Gets or sets this code line's indentation.
 </summary>
    </member>
    <member name="M:Flame.Compiler.DescribedBodyMethod.GetMethodBody">
      <summary>
 Gets the method's body statement.
 </summary>
      <returns />
    </member>
    <member name="T:Flame.Compiler.DescribedInvariant">
      <summary>
 Defines an artifical invariant member.
 </summary>
    </member>
    <member name="T:Flame.Compiler.IInvariantType">
      <summary>
 Defines common functionality for types with type invariants.
 </summary>
    </member>
    <member name="M:Flame.Compiler.IInvariantType.GetInvariants">
      <summary>
 Gets the type's invariants as expressions that must all evaluate to true.
 </summary>
    </member>
    <member name="P:Flame.Compiler.IInvariant.Invariant">
      <summary>
 Gets the invariant member's invariant as an expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.ISourceMember">
      <summary>
 Defines common functionality for members that expose their source locations.
 </summary>
    </member>
    <member name="P:Flame.Compiler.ISourceMember.Location">
      <summary>
 Gets the member's source location.
 </summary>
    </member>
    <member name="T:Flame.Compiler.SourceLocationAttribute">
      <summary>
 An attribute that encodes a source location. This is a convenient
 alternative to implementing ISourceMember, but it is less flexible,
 because the source location cannot be computed on request when
 using this attribute.
 </summary>
    </member>
    <member name="P:Flame.Compiler.SourceLocationAttribute.Location">
      <summary>
 Gets the actual source location stored in this
 attribute.
 </summary>
    </member>
    <member name="M:Flame.Compiler.SourceMemberExtensions.GetSourceLocation(Flame.IMember)">
      <summary>
 Tries to get the given member's source location.
 </summary>
    </member>
    <member name="M:Flame.Compiler.InvariantExtensions.GetAllInvariants(System.Collections.Generic.IEnumerable`1{Flame.IType})">
      <summary>
 Gets the union of all invariants the given types have, both directly and indirectly.
 </summary>
    </member>
    <member name="M:Flame.Compiler.InvariantExtensions.GetAllInvariants(Flame.IType)">
      <summary>
 Gets the union of all invariants the given type has, both directly and indirectly.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IMethodStructureGenerator.GetLocal(Flame.Compiler.UniqueTag)">
      <summary>
 Gets the local variable with the given unique tag, if there is
 such a variable. Otherwise, null is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IMethodStructureGenerator.DeclareLocal(Flame.Compiler.UniqueTag,Flame.Compiler.IVariableMember)">
      <summary>
 Declares a new local variable based on the given unique tag and
 variable member. Declaring two variables with the same tag
 results in an exception.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IMethodStructureGenerator.GetThis">
      <summary>
 Gets the "this" argument.
 </summary>
      <returns />
    </member>
    <member name="P:Flame.Compiler.Emit.IMethodStructureGenerator.Method">
      <summary>
 Gets the method this code generator belongs to.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Emit.IUnmanagedMethodStructureGenerator">
      <summary>
 Defines a method structure generator interface that supports creating
 and retrieving unmanaged variables.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IUnmanagedMethodStructureGenerator.GetUnmanagedLocal(Flame.Compiler.UniqueTag)">
      <summary>
 Gets the local variable with the given unique tag, if there is
 such an unmanaged variable. Otherwise, null is returned.
 </summary>
      <remarks>
 It is up to the implementation to decide if this method returns null
 for locals declared via DeclareLocal instead of DeclareUnmanagedLocal.
 </remarks>
    </member>
    <member name="M:Flame.Compiler.Emit.IUnmanagedMethodStructureGenerator.DeclareUnmanagedLocal(Flame.Compiler.UniqueTag,Flame.Compiler.IVariableMember)">
      <summary>
 Declares an unmanaged local variable with the given unique tag, and
 based on the given variable member. Declaring two variables with the
 same tag results in an exception.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IUnmanagedMethodStructureGenerator.GetUnmanagedArgument(System.Int32)">
      <summary>
 Gets the nth argument as an unmanaged variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IUnmanagedMethodStructureGenerator.GetUnmanagedThis">
      <summary>
 Gets the "this" argument.
 </summary>
      <returns />
    </member>
    <member name="T:Flame.Compiler.Emit.IEmitVariable">
      <summary>
 Describes common functionality for codegen-level variables.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IEmitVariable.EmitGet">
      <summary>
 Creates a block that gets this variable's value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IEmitVariable.EmitSet(Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a block that sets this variable's value to the given value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IEmitVariable.EmitRelease">
      <summary>
 Creates a block that flags this variable for re-use.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Emit.IUnmanagedEmitVariable">
      <summary>
 Describes common functionality for codegen-level variables whose address
 can be taken.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IUnmanagedEmitVariable.EmitAddressOf">
      <summary>
 Creates a block that gets this variable's address, as a (reference) pointer.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.ILambdaCodeGenerator.EmitLambdaHeader(Flame.IMethod,System.Collections.Generic.IEnumerable`1{Flame.Compiler.ICodeBlock})">
      <summary>
 Creates a lambda header block for a lambda that has the given
 method signature and sequence of captured values.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.ILambdaCodeGenerator.EmitLambda(Flame.Compiler.Emit.ILambdaHeaderBlock,Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a lambda from the given header and body block.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Emit.ILambdaHeaderBlock">
      <summary>
 An common interface for lambda header blocks.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.ILambdaHeaderBlock.EmitGetCapturedValue(System.Int32)">
      <summary>
 Creates a code block that gets the lambda's captured value with
 the given index.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Emit.ILambdaHeaderBlock.ThisLambdaBlock">
      <summary>
 Gets a code block that represents a delegate for this lambda function.
 This construct is designed to support recursion within a lambda function.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Emit.ILambdaHeaderBlock.LambdaCodeGenerator">
      <summary>
 Gets a code generator that should be used to construct the lambda's
 body.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Emit.RetypedVariableMember.Name">
      <summary>
 Gets the member's name.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Emit.RetypedVariableMember.FullName">
      <summary>
 Gets the member's full name.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Emit.RetypedVariableMember.Attributes">
      <summary>
 Gets the member's attributes.
 </summary>
      <returns />
    </member>
    <member name="P:Flame.Compiler.Emit.TypeVariableMember.Name">
      <summary>
 Gets the member's name.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Emit.TypeVariableMember.FullName">
      <summary>
 Gets the member's full name.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Emit.TypeVariableMember.Attributes">
      <summary>
 Gets the member's attributes.
 </summary>
      <returns />
    </member>
    <member name="T:Flame.Compiler.Emit.DescribedVariableMember">
      <summary>
 Implements a described variable member: a veriable member that can be
 constructed one member at a time.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.DescribedVariableMember.#ctor(System.String,Flame.IType)">
      <summary>
 Creates a new described variable member from the given name and variable
 type.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Emit.DescribedVariableMember.VariableType">
      <summary>
 Gets the variable member's variable type.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Emit.LocalManagerBase`1">
      <summary>
 Defines a base class for objects that manage a code generator's locals.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.LocalManagerBase`1.CreateLocal(Flame.Compiler.IVariableMember)">
      <summary>
 Creates a new local variable from the given variable member.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.LocalManagerBase`1.ContainsLocal(Flame.Compiler.UniqueTag)">
      <summary>
 Tests if a local with the given unique tag exists
 in this local manager.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.LocalManagerBase`1.GetOrDefault(Flame.Compiler.UniqueTag)">
      <summary>
 Gets the local associated with the given tag,
 or returns the default value for locals
 if no such local exists. This is typically null.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.LocalManagerBase`1.Declare(Flame.Compiler.UniqueTag,Flame.Compiler.IVariableMember)">
      <summary>
 Declares a new local with the given tag, based on the
 given variable member.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Emit.LocalManagerBase`1.Tags">
      <summary>
 Gets a sequence of all unique tags that are currently
 associated with variables in this local manager.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Emit.LocalManagerBase`1.Locals">
      <summary>
 Gets a sequence containing all locals that are being managed
 by this local manager.
 </summary>
    </member>
    <member name="F:Flame.Compiler.Emit.LocalManagerBase`1.locals">
      <summary>
 A dictionary that stores all locals.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Emit.LocalManager`1">
      <summary>
 A class for objects that manage a code generator's locals.
 This is a simple and straightforward implementation.
 Locals are never recycled.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.LocalManager`1.#ctor(T(Flame.Compiler.IVariableMember))">
      <summary>
 Creates a new local manager from the given
 local-creating function.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.LocalManager`1.CreateLocal(Flame.Compiler.IVariableMember)">
      <summary>
 Creates a new local variable from the given variable member.
 </summary>
    </member>
    <member name="F:Flame.Compiler.Emit.LocalManager`1.createNewLocal">
      <summary>
 A function that creates locals from variable members.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IInitializingCodeGenerator.EmitInitializedArray(Flame.IType,Flame.Compiler.ICodeBlock[])">
      <summary>
 Creates and initializes a new array.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IInitializingCodeGenerator.EmitInitializedVector(Flame.IType,Flame.Compiler.ICodeBlock[])">
      <summary>
 Creates and initializes a new vector.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Emit.IForCodeGenerator">
      <summary>
 Provides an interface for code generators that support C-family style for loops.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IForCodeGenerator.EmitForBlock(Flame.Compiler.UniqueTag,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a for loop block from the given initialization, condition, delta and body blocks.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Emit.IForeachCodeGenerator">
      <summary>
 Provides a common interface for code generators that support foreach loops.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IForeachCodeGenerator.EmitCollectionBlock(Flame.Compiler.IVariableMember,Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a collection block: a block that captures one element of the
 given collection block at a time.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IForeachCodeGenerator.EmitForeachHeader(Flame.Compiler.UniqueTag,System.Collections.Generic.IEnumerable`1{Flame.Compiler.Emit.ICollectionBlock})">
      <summary>
 Creates a foreach block header based on the given collection blocks.
 </summary>
      <remarks>
 This method has a high likelihood of returning null, especially
 when confronted with multiple collections.
 </remarks>
    </member>
    <member name="M:Flame.Compiler.Emit.IForeachCodeGenerator.EmitForeachBlock(Flame.Compiler.Emit.IForeachBlockHeader,Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a foreach block based on the given foreach header and the
 given body block.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Emit.IForeachBlockHeader">
      <summary>
 Defines a "header" for a foreach block: a definition of all element variables
 that a foreach block captures.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Emit.IForeachBlockHeader.Elements">
      <summary>
 Gets a read-only list that contains variables representing the collections' elements on each iteration.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Emit.ICollectionBlock">
      <summary>
 Defines a collection block: a block that captures a collection's elements
 one at a time.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Emit.ICollectionBlock.Member">
      <summary>
 Gets the variable member of the collection block's element variable.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Emit.ICommentedCodeGenerator">
      <summary>
 Defines common functionality for code generators that can emit comments.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.ICommentedCodeGenerator.EmitComment(System.String)">
      <summary>
 Creates a new comment block.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Emit.IExceptionCodeGenerator">
      <summary>
 Defines an interface for code generators that can deal with exceptions.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IExceptionCodeGenerator.EmitCatchHeader(Flame.Compiler.IVariableMember)">
      <summary>
 Creates a new catch header based on the given exception variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IExceptionCodeGenerator.EmitCatchClause(Flame.Compiler.Emit.ICatchHeader,Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a new catch clause based on the given header and body.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IExceptionCodeGenerator.EmitTryBlock(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,System.Collections.Generic.IEnumerable`1{Flame.Compiler.Emit.ICatchClause})">
      <summary>
 Creates a try/catch/finally block from a try body, a finally body and
 zero or more catch clauses.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IExceptionCodeGenerator.EmitThrow(Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a block that throws the given exception.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IExceptionCodeGenerator.EmitAssert(Flame.Compiler.ICodeBlock)">
      <summary>
 Emits an assertion on the given code block.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Emit.ICatchHeader">
      <summary>
 Defines a header for a catch clause, which contains the variable that
 will hold the exception if one is thrown.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Emit.ICatchHeader.ExceptionVariable">
      <summary>
 Gets the catch header's exception variable.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Emit.ICatchClause">
      <summary>
 Defines a catch clause.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Emit.ICatchClause.Header">
      <summary>
 Gets the catch clause's header.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Emit.IContractCodeGenerator">
      <summary>
 Provides a common interface for design by contract method code generators.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IContractCodeGenerator.EmitContractBlock(System.Collections.Generic.IEnumerable`1{Flame.Compiler.ICodeBlock},System.Collections.Generic.IEnumerable`1{Flame.Compiler.ICodeBlock},Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a code block that enforces the given precondition and postcondition blocks
 on the given body block.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Emit.IContractCodeGenerator.ReturnVariable">
      <summary>
 Gets the contract method's return value variable.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Emit.IInvariantGenerator">
      <summary>
 Provides a common interface for invariant generation.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Emit.IInvariantGenerator.EmitInvariant(Flame.Compiler.ICodeBlock)">
      <summary>
 Emits an invariant: the given block must evaluate to true.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Emit.IInvariantGenerator.CodeGenerator">
      <summary>
 Gets this invariant generator's code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConstantExpression`1.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ConstantExpression`1.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ConstantExpression`1.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConstantExpression`1.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.Bit8Expression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.Bit16Expression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.Bit32Expression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.Bit64Expression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.Int8Expression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.Int16Expression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.Int32Expression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.Int64Expression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.UInt8Expression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.UInt16Expression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.UInt32Expression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.UInt64Expression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.BooleanExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.StringExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DefaultValueExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DefaultValueExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DefaultValueExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.DefaultValueExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.DefaultValueExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.Float32Expression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.Float64Expression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.NullExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.NullExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.NullExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.NullExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.BinaryExpression">
      <summary>
 A base class for expressions that apply some binary
 operator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.BinaryExpression.#ctor(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression from the given operand expressions.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.BinaryExpression.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.BinaryExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.BinaryExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.BinaryExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.BinaryExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.BinaryExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.BinaryExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="P:Flame.Compiler.Expressions.BinaryExpression.Op">
      <summary>
 Gets this binary expression's operator.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.BinaryExpression.Type">
      <summary>
 Gets this binary expression's type.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.BinaryExpression.IsConstant">
      <summary>
 Checks if this binary expression is constant.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.BinaryExpression.LeftOperand">
      <summary>
 Gets the binary expression's left operand.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.BinaryExpression.RightOperand">
      <summary>
 Gets the binary expression's right operand.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.PrimitiveBinaryExpression">
      <summary>
 Defines a binary expression that does not know how to evaluate itself,
 and simply instructs the code generator to create a binary block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.PrimitiveBinaryExpression.#ctor(Flame.Compiler.IExpression,Flame.Operator,Flame.Compiler.IExpression)">
      <summary>
 Creates a primitive binary expression from the given operands and
 operator. The result type is assumed to be the type of the left
 operand.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.PrimitiveBinaryExpression.#ctor(Flame.Compiler.IExpression,Flame.Operator,Flame.Compiler.IExpression,Flame.IType)">
      <summary>
 Creates a primitive binary expression from the given operands,
 operator and result type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.PrimitiveBinaryExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.PrimitiveBinaryExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.PrimitiveBinaryExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.DirectBinaryExpression">
      <summary>
 A helper class that can be used to create optimal built-in
 binary expressions.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DirectBinaryExpression.Create(Flame.Compiler.IExpression,Flame.Operator,Flame.Compiler.IExpression)">
      <summary>
 Creates a new binary expression from the given left operand,
 operator and right operand.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedExpression.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.DereferencePointerExpression">
      <summary>
 A unary expression that dereferences a pointer expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DereferencePointerExpression.#ctor(Flame.Compiler.IExpression)">
      <summary>
 Creates an expression that dereferences the pointer created by the
 given expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DereferencePointerExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DereferencePointerExpression.GetVariable">
      <summary>
 Gets the variable node's underlying variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DereferencePointerExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.DereferencePointerExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.DereferencePointerExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.DereferencePointerExpression.Expression">
      <summary>
 Gets this pointer-dereferencing expression's operand.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.DelegateInstanceExpression">
      <summary>
 Defines an expression type that provides delegate expression functionality
 to a normal expression that yields a delegate instance.
 Delegate instance expressions cannot be used to create generic instance delegates.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DelegateInstanceExpression.#ctor(Flame.Compiler.IExpression)">
      <summary>
 Creates a new delegate instance expression from the given delegate.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DelegateInstanceExpression.Lower">
      <summary>
 Lowers this expression to a semantically equivalent expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DelegateInstanceExpression.CreateInvocationExpression(System.Collections.Generic.IEnumerable`1{Flame.Compiler.IExpression})">
      <summary>
 Creates an invocation expression based on this delegate expression and
 the given arguments.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DelegateInstanceExpression.MakeGenericExpression(System.Collections.Generic.IEnumerable`1{Flame.IType})">
      <summary>
 Creates a generic delegate instantiation.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.DelegateInstanceExpression.Signature">
      <summary>
 Gets the delegate signature of the delegate instance expression.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.DelegateInstanceExpression.ParameterTypes">
      <summary>
 Gets the delegate expression's parameter types.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.DelegateInstanceExpression.ReturnType">
      <summary>
 Gets the return type of the delegate expression's delegate.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.DelegateInstanceExpression.Delegate">
      <summary>
 Gets the delegate instance expression's delegate instance expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ThisGetExpression.GetVariable">
      <summary>
 Gets the variable node's underlying variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ThisGetExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ThisGetExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ThisGetExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ThisGetExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ThisGetExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.ConversionExpressionBase">
      <summary>
 A base class for conversion expressions.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConversionExpressionBase.#ctor(Flame.Compiler.IExpression,Flame.IType)">
      <summary>
 Creates a conversion expression that converts the given value
 to the given type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConversionExpressionBase.Create(Flame.Compiler.IExpression,Flame.IType)">
      <summary>
 Creates a new conversion expression that converts the given
 value to the given type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConversionExpressionBase.Evaluate">
      <summary>
 Evaluates this conversion expression at compile-time.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ConversionExpressionBase.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block for this conversion expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConversionExpressionBase.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConversionExpressionBase.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConversionExpressionBase.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConversionExpressionBase.Optimize">
      <summary>
 Optimizes this conversion expression.
 </summary>
      <returns />
    </member>
    <member name="P:Flame.Compiler.Expressions.ConversionExpressionBase.Type">
      <summary>
 Gets the conversion expression's type, which is the same as its
 target type.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.ConversionExpressionBase.IsConstant">
      <summary>
 Tells if this conversion expression is a compile-time constant.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.ConversionExpressionBase.Value">
      <summary>
 Gets the value that is to be converted to the given type.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.ConversionExpressionBase.TargetType">
      <summary>
 Gets the type the value is to be converted to.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.ConversionExpression">
      <summary>
 A helper class that creates conversion expressions.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConversionExpression.Create(Flame.Compiler.IExpression,Flame.IType)">
      <summary>
 Creates an expression that converts the given value to the given type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConversionExpression.UseDynamicCast(Flame.IType,Flame.IType)">
      <summary>
 Tests if a value of the given source type can be cast dynamically to a value
 of the given target type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConversionExpression.UseReinterpretCast(Flame.IType,Flame.IType)">
      <summary>
 Tests if a value of the given source type can safely be cast to a value
 of the given target type using a reinterpret cast.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.VariableGetExpressionBase`1.GetVariable">
      <summary>
 Gets the variable node's underlying variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.VariableGetExpressionBase`1.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.VariableGetExpressionBase`1.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.VariableGetExpressionBase`1.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.VariableGetExpressionBase`1.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LateBoundVariableGetExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LateBoundVariableGetExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.LateBoundVariableGetExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LateBoundVariableGetPointerExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LateBoundVariableGetPointerExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.FieldGetExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.FieldGetExpression.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.FieldGetExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.FieldGetExpression.GetVariable">
      <summary>
 Gets the variable node's underlying variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.FieldGetExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.FieldGetExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.FieldGetExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.FieldGetPointerExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.FieldGetPointerExpression.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.FieldGetPointerExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.FieldGetPointerExpression.GetVariable">
      <summary>
 Gets the variable node's underlying variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.FieldGetPointerExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.FieldGetPointerExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.FieldGetPointerExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.InvocationExpression">
      <summary>
 A type of expression that invokes a delegate expression by passing
 it a list of arguments.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InvocationExpression.#ctor(Flame.Compiler.IExpression,System.Collections.Generic.IEnumerable`1{Flame.Compiler.IExpression})">
      <summary>
 Creates an invocation expression that invokes the given delegate
 expression with the given argument list.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InvocationExpression.#ctor(Flame.IMethod,Flame.Compiler.IExpression,System.Collections.Generic.IEnumerable`1{Flame.Compiler.IExpression})">
      <summary>
 Creates an invocation expression that calls the given method
 with the given argument list. Virtual methods will be called
 through dynamic invocation, nonvirtual methods will result in a
 direct call.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InvocationExpression.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InvocationExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InvocationExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.InvocationExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.InvocationExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.InvocationExpression.Method">
      <summary>
 Gets the method signature of the delegate expression to invoke.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.InvocationExpression.Target">
      <summary>
 Gets the delegate expression that is invoked by passing it
 an argument list.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.InvocationExpression.Arguments">
      <summary>
 Gets the argument list to invoke the delegate with.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ContainerElementGetExpression.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ContainerElementGetExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ContainerElementGetExpression.GetVariable">
      <summary>
 Gets the variable node's underlying variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ContainerElementGetExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ContainerElementGetExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ContainerElementGetExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ContainerElementAddressOfExpression.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ContainerElementAddressOfExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ContainerElementAddressOfExpression.GetVariable">
      <summary>
 Gets the variable node's underlying variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ContainerElementAddressOfExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ContainerElementAddressOfExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ContainerElementAddressOfExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.NewArrayExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.NewArrayExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.NewArrayExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.NewArrayExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.NewArrayExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.NewVectorExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.NewVectorExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.NewVectorExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.NewVectorExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.NewVectorExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.NewObjectExpression">
      <summary>
 A type of expression that creates new object instances,
 based on a type and a sequence of arguments.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.NewObjectExpression.#ctor(Flame.IType)">
      <summary>
 Creates an expression that produces an instance of the given
 type, by invoking its parameterless constructor (or by taking its
 default value, if the type is a value type).
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.NewObjectExpression.#ctor(Flame.IType,System.Collections.Generic.IEnumerable`1{Flame.Compiler.IExpression})">
      <summary>
 Creates an expression that produces an instance of the given
 type, by invoking one of its constructors with the given arguments
 (or by taking its default value, if the type is a value type,
 and the sequence of arguments is empty).
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.NewObjectExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.NewObjectExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.NewObjectExpression.LowerSoft">
      <summary>
 Attempts to lower this new-object expression.
 If that cannot be done, then this instance
 is simply returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.NewObjectExpression.Lower">
      <summary>
 Lowers this new-object expression.
 If that cannot be done, then an exception is thrown.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.NewObjectExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.NewObjectExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.NewObjectExpression.Constructor">
      <summary>
 Gets the constructor this new-object expression will use when
 lowering itself. If no such constructor can be found, then null
 is returned.
 </summary>
      <remarks>
 This expression can still be semantically valid, even if the
 constructor is null, provided the instance type is a value type,
 and the argument list is empty.
 </remarks>
    </member>
    <member name="P:Flame.Compiler.Expressions.NewObjectExpression.IsConstructorCall">
      <summary>
 Tests if this new-object expression will be lowered to a constructor
 call expression.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.NewObjectExpression.IsDefaultValue">
      <summary>
 Tests if this new-object expression will be lowered to a default
 value expression.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.NewObjectExpression.IsError">
      <summary>
 Tests if this new-object expression is erroneous: it cannot be
 lowered to another expression.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.NewObjectExpression.Arguments">
      <summary>
 Gets this new-object expression's argument list.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.NewObjectExpression.Type">
      <summary>
 Gets the type this new-object expression will create an instance
 of.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.IsExpression">
      <summary>
 Defines an is-expression, which is an expression that tests if a value
 is an instance of a given type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.IsExpression.#ctor(Flame.Compiler.IExpression,Flame.IType)">
      <summary>
 Creates an is-expression from the given expression and type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.IsExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.IsExpression.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.IsExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.IsExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.IsExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.IsExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.IsExpression.Target">
      <summary>
 Gets the value that is tested against the given type.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.IsExpression.TestType">
      <summary>
 Gets the type to test against.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.LambdaHeader">
      <summary>
 Represents a lambda's "header": its signature and capture list.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.LambdaHeader.Signature">
      <summary>
 Gets this lambda expression's signature.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.LambdaHeader.CaptureList">
      <summary>
 Gets the lambda expression's list of captured variables.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.LambdaBoundHeaderBlock">
      <summary>
 A type that contains a bound emit lambda header block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaBoundHeaderBlock.#ctor">
      <summary>
 Creates a bound header block that has not been bound to any block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaBoundHeaderBlock.#ctor(Flame.Compiler.Emit.ILambdaHeaderBlock)">
      <summary>
 Creates a bound header block that is already bound to the given block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaBoundHeaderBlock.Bind(Flame.Compiler.Emit.ILambdaHeaderBlock)">
      <summary>
 Binds the given emit lambda header block to this instance.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaBoundHeaderBlock.Release">
      <summary>
 Releases the bound emit lambda header block.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.LambdaBoundHeaderBlock.IsBound">
      <summary>
 Tests if an emit lambda header block has been bound to this instance.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.LambdaBoundHeaderBlock.BoundBlock">
      <summary>
 Gets this lambda expression's bound header block, which is non-null
 only during a call to `Emit`.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.LambdaExpression">
      <summary>
 A type of expression that describes an anonymous function with explicit,
 by-value capture: variables outside the lambda are not permitted within.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaExpression.AcceptFlow``2(Flame.Compiler.IFlowVisitor`2{TState,TFlow})">
      <summary>
 Accepts and interacts with a flow visitor.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaExpression.IsCapturedValueExpression(Flame.Compiler.IExpression)">
      <summary>
 Tests if the given argument is a captured value expression
 that gets one of this lambda expression's captured values.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaExpression.IsThisDelegateExpression(Flame.Compiler.IExpression)">
      <summary>
 Tests if the given argument is a lambda delegate expression
 that creates a delegate for this lambda function.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaExpression.IsDependentExpression(Flame.Compiler.IExpression)">
      <summary>
 Checks if the given expression depends on this lambda expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaExpression.Copy">
      <summary>
 Creates a copy of this lambda expression that is not dependent on
 any of this expression instance's data.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.LambdaExpression.Header">
      <summary>
 Gets the lambda expression's header.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.LambdaExpression.Body">
      <summary>
 Gets the lambda expression's body.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.LambdaExpression.BoundHeaderBlock">
      <summary>
 Gets this lambda expression's bound header block, which is non-null
 only during a call to `Emit`.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.LambdaCapturedValueExpression">
      <summary>
 An expression that accesses one of the values that a lambda
 has captured.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaCapturedValueExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaCapturedValueExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaCapturedValueExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaCapturedValueExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.LambdaCapturedValueExpression.Header">
      <summary>
 Gets the lambda header that this captured value
 expression is associated with.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.LambdaCapturedValueExpression.BoundHeaderBlock">
      <summary>
 Gets the bound lambda header block this captured value expression is
 associated with.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.LambdaCapturedValueExpression.Index">
      <summary>
 Gets the index in the lambda capture list of the captured value
 that is accessed by this expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.LambdaDelegateExpression">
      <summary>
 An expression that yields a delegate to the enclosing lambda.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaDelegateExpression.#ctor(Flame.Compiler.Expressions.LambdaHeader,Flame.Compiler.Expressions.LambdaBoundHeaderBlock)">
      <summary>
 Creates a new lambda delegate expression from the given lambda header
 and bound header block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaDelegateExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaDelegateExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaDelegateExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LambdaDelegateExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.LambdaDelegateExpression.Header">
      <summary>
 Gets the lambda header that this lambda delegate expression
 is associated with.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.LambdaDelegateExpression.BoundHeaderBlock">
      <summary>
 Gets the bound lambda header block this lambda delegate expression is
 associated with.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.CharExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.CodeBlockExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.CodeBlockExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.CodeBlockExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.CodeBlockExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.UnaryExpression">
      <summary>
 Defines a base class for expressions that take a single operand.
 </summary>
      <remarks>
 Not all unary expressions are associated with a specific unary operator.
 </remarks>
    </member>
    <member name="M:Flame.Compiler.Expressions.UnaryExpression.#ctor(Flame.Compiler.IExpression)">
      <summary>
 Initializes this unary expression with the given operand.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.UnaryExpression.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.UnaryExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.UnaryExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.UnaryExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.UnaryExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.UnaryExpression.Value">
      <summary>
 The value the unary expression will be performed on.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.UnaryOperatorExpression">
      <summary>
 Defines a base class for expressions that apply an operator to a single
 operand.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.UnaryOperatorExpression.#ctor(Flame.Compiler.IExpression)">
      <summary>
 Initializes this unary operator expression with the given expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.UnaryOperatorExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.UnaryOperatorExpression.Op">
      <summary>
 Gets the unary operator that this expression applies to its operand.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.PrimitiveUnaryExpression">
      <summary>
 Defines a unary expression that does not know how to evaluate itself,
 and simply instructs the code generator to create a unary operator block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.PrimitiveUnaryExpression.#ctor(Flame.Operator,Flame.Compiler.IExpression)">
      <summary>
 Initializes this unary operator expression with the given expression
 and operator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.PrimitiveUnaryExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="P:Flame.Compiler.Expressions.PrimitiveUnaryExpression.Op">
      <summary>
 Gets the unary operator that this expression applies to its operand.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.DirectUnaryExpression">
      <summary>
 A helper class that can be used to create optimal built-in
 unary expressions.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DirectUnaryExpression.Create(Flame.Operator,Flame.Compiler.IExpression)">
      <summary>
 Creates a unary expression from the given operation and operand.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.UnknownExpression">
      <summary>
 Defines an unknown expression: an expression that cannot be represented by
 a code sequence, and thus does not support `Emit`. Instead, it acts
 as a non-constant expression that can be used to stop certain optimizations
 from performing their task overly aggressively.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.UnknownExpression.#ctor(Flame.IType)">
      <summary>
 Creates an unknown expression with the given type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.UnknownExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.UnknownExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.UnknownExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.UnknownExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.UnknownExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.UnknownExpression.Type">
      <summary>
 Gets the unknown expression's type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.NegateExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.NegateExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.NegateExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.NotExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.NotExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="T:Flame.Compiler.Expressions.AddExpression">
      <summary>
 A type that represents addition expressions.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.AddExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.AddExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.AddExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.AddExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.SubtractExpression">
      <summary>
 A type of expression that subtracts its right-hand operand from
 its left-hand operand.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SubtractExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.SubtractExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SubtractExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.MemberlessExpression.Lower">
      <summary>
 Lowers this expression to a semantically equivalent expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.MemberlessExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.MultiplyExpression">
      <summary>
 A type of expression that computes the product of its operands.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.MultiplyExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.MultiplyExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.MultiplyExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.MultiplyExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.DivideExpression">
      <summary>
 Defines a type of expression that computes the quotient of its
 operands.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DivideExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.DivideExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.DivideExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DivideExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.DynamicCastExpression">
      <summary>
 An expression that represents a dynamic cast.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DynamicCastExpression.#ctor(Flame.Compiler.IExpression,Flame.IType)">
      <summary>
 Creates a dynamic cast from the given value and type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DynamicCastExpression.Create(Flame.Compiler.IExpression,Flame.IType)">
      <summary>
 Creates a new conversion expression that converts the given
 value to the given type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.DynamicCastExpression.Evaluate">
      <summary>
 Evaluates this conversion expression at compile-time.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.DynamicCastExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block for this conversion expression.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.DynamicCastExpression.IsConstant">
      <summary>
 Tells if this conversion expression is a compile-time constant.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.ConditionalExpression">
      <summary>
 Defines a base type for condition expressions: expressions with
 a boolean return type, regardless of their argument types.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.LessThanExpression">
      <summary>
 A type of expression that tests if its left-hand operand is less
 than its right operand.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LessThanExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.LessThanExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LessThanExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.LessThanOrEqualsExpression">
      <summary>
 A type of expression that tests if its left-hand operand is less
 than or equal to its right operand.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LessThanOrEqualsExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.LessThanOrEqualsExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LessThanOrEqualsExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.GreaterThanExpression">
      <summary>
 A type of expression that tests if its left-hand operand is greater
 than its right operand.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.GreaterThanExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.GreaterThanExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.GreaterThanExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.GreaterThanOrEqualsExpression">
      <summary>
 A type of expression that tests if its left-hand operand is greater
 than or equal to its right operand.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.GreaterThanOrEqualsExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.GreaterThanOrEqualsExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.GreaterThanOrEqualsExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.EqualityExpression">
      <summary>
 Defines a type of expression that compares its arguments for equality.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.EqualityExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.EqualityExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.EqualityExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.LogEntryExpression">
      <summary>
 A base class for expression that contain log entries.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LogEntryExpression.#ctor(Flame.Compiler.IExpression,Flame.Compiler.LogEntry)">
      <summary>
 Creates a new log entry expression from the given value and message.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LogEntryExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.LogEntry)">
      <summary>
 Creates a new instance of this expression type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LogEntryExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.LogEntryExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LogEntryExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.LogEntryExpression.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LogEntryExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.LogEntryExpression.IsConstant">
      <summary>
 This property always returns false because otherwise people could get the
 wrong idea and constant-fold this object into oblivion, based on the (invalid)
 assumption that this expression is perfectly legal.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.LogEntryExpression.Message">
      <summary>
 Gets the message associated with this expression.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.LogEntryExpression.Value">
      <summary>
 Gets this expression's inner expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.ErrorExpression">
      <summary>
 A class for expressions that represent an invalid expression node, which
 contain an error message.
 An inner expression is provided to make instances of this type "play nice"
 with other nodes, but said expression may not be semantically valid.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ErrorExpression.#ctor(Flame.Compiler.IExpression,Flame.Compiler.LogEntry)">
      <summary>
 Creates a new error expression from the given value and error message.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ErrorExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.LogEntry)">
      <summary>
 Creates a new instance of this expression type.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.WarningExpression">
      <summary>
 A class for expressions that represent a semantically valid, but somewhat
 fishy expression, which contains a warning message.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.WarningExpression.#ctor(Flame.Compiler.IExpression,Flame.Compiler.LogEntry)">
      <summary>
 Creates a new warning expression from the given value and warning message.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.WarningExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.LogEntry)">
      <summary>
 Creates a new instance of this expression type.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.AndExpression">
      <summary>
 Defines a type of expression that computes the bitwise 'and' of its
 operands.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.AndExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.AndExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.AndExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.AsInstanceExpression">
      <summary>
 An expression that represents an as-instance expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.AsInstanceExpression.#ctor(Flame.Compiler.IExpression,Flame.IType)">
      <summary>
 Creates an as-instance expression from the given value and type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.AsInstanceExpression.Create(Flame.Compiler.IExpression,Flame.IType)">
      <summary>
 Creates a new conversion expression that converts the given
 value to the given type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.AsInstanceExpression.Evaluate">
      <summary>
 Evaluates this conversion expression at compile-time.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.AsInstanceExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block for this conversion expression.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.AsInstanceExpression.IsConstant">
      <summary>
 Tells if this conversion expression is a compile-time constant.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.OrExpression">
      <summary>
 Defines a type of expression that computes the bitwise 'or' of its
 operands.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.OrExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.OrExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.OrExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.XorExpression">
      <summary>
 A type of expression that computes the bitwise exclusive 'or' of its
 operands.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.XorExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.XorExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.XorExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.ShortCircuitBinaryExpression">
      <summary>
 A base class for short-circuiting binary expressions.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ShortCircuitBinaryExpression.AcceptFlow``2(Flame.Compiler.IFlowVisitor`2{TState,TFlow})">
      <summary>
 Accepts and interacts with a flow visitor.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.LazyAndExpression">
      <summary>
 Defines a short-circuiting boolean 'and' operator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LazyAndExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.LazyAndExpression.GetFlattenedOperands">
      <summary>
 Gets a "flattened" sequence of operands of this logical and expression and
 its children, if any.
 For example, `a &amp;&amp; b &amp;&amp; c` would return the following
 sequence of operands: [a, b, c].
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LazyAndExpression.Simplify">
      <summary>
 "Simplifies" this lazy-and expression by applying
 a number of simplification rules. Child nodes are not simplified.
 This is a lot like a non-recursive version of Optimize.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LazyAndExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.LazyAndExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LazyAndExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.LazyOrExpression">
      <summary>
 Defines a short-circuiting boolean 'or' operator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LazyOrExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.LazyOrExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.LazyOrExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LazyOrExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.PropertyGetExpression.GetVariable">
      <summary>
 Gets the variable node's underlying variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.PropertyGetExpression.Lower">
      <summary>
 Lowers this expression to a semantically equivalent expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.PropertyGetExpression.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.ReinterpretCastExpression">
      <summary>
 An expression that represents a reinterpret cast, which is a cast that
 returns a reference or pointer of a given type based on a pointer or
 reference of any other type. The cast is assumed to always succeed,
 and does not mandate a runtime check.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ReinterpretCastExpression.#ctor(Flame.Compiler.IExpression,Flame.IType)">
      <summary>
 Creates a reinterpret cast from the given value and type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ReinterpretCastExpression.Create(Flame.Compiler.IExpression,Flame.IType)">
      <summary>
 Creates a new conversion expression that converts the given
 value to the given type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ReinterpretCastExpression.Evaluate">
      <summary>
 Evaluates this conversion expression at compile-time.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ReinterpretCastExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block for this conversion expression.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.ReinterpretCastExpression.IsConstant">
      <summary>
 Tells if this conversion expression is a compile-time constant.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.GetExtensionMethodExpression.CreateInvocationExpression(System.Collections.Generic.IEnumerable`1{Flame.Compiler.IExpression})">
      <summary>
 Creates an invocation expression based on this delegate expression and
 the given arguments.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.GetExtensionMethodExpression.MakeGenericExpression(System.Collections.Generic.IEnumerable`1{Flame.IType})">
      <summary>
 Creates a generic delegate instantiation.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.GetExtensionMethodExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.GetExtensionMethodExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.GetExtensionMethodExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.GetExtensionMethodExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.GetExtensionMethodExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.GetMethodExpression">
      <summary>
 A type of expression that creates a delegate that wraps a method and its
 calling expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.GetMethodExpression.#ctor(Flame.IMethod,Flame.Compiler.IExpression,Flame.Operator)">
      <summary>
 Creates a get-method expression from the given method and calling expression.
 The resulting delegate is created by the given operator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.GetMethodExpression.#ctor(Flame.IMethod,Flame.Compiler.IExpression)">
      <summary>
 Creates a get-method expression from the given method and calling
 expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.GetMethodExpression.CreateInvocationExpression(System.Collections.Generic.IEnumerable`1{Flame.Compiler.IExpression})">
      <summary>
 Creates an invocation expression based on this delegate expression and
 the given arguments.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.GetMethodExpression.MakeGenericExpression(System.Collections.Generic.IEnumerable`1{Flame.IType})">
      <summary>
 Creates a generic delegate instantiation.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.GetMethodExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.GetMethodExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.GetMethodExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.GetMethodExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.GetMethodExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.GetMethodExpression.Caller">
      <summary>
 Gets the get-method expression's calling expression.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.GetMethodExpression.Target">
      <summary>
 Gets the method that is wrapped in a delegate.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.GetMethodExpression.Op">
      <summary>
 Gets the operator that creates the resulting delegate.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SizeOfExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SizeOfExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SizeOfExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.SizeOfExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.SizeOfExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.SourceExpression">
      <summary>
 An expression that contains a location in a source document, for diagnostics
 and debugging purposes.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SourceExpression.#ctor(Flame.Compiler.IExpression,Flame.Compiler.SourceLocation)">
      <summary>
 Creates a new source expression from the given statement and location.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SourceExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.SourceExpression.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SourceExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SourceExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.SourceExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.SourceExpression.Value">
      <summary>
 Gets the source expression's inner expression.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.SourceExpression.Location">
      <summary>
 Gets the source statement's location.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.StaticCastExpression">
      <summary>
 An expression that represents a static cast.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.StaticCastExpression.#ctor(Flame.Compiler.IExpression,Flame.IType)">
      <summary>
 Creates a static cast from the given value and type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.StaticCastExpression.Create(Flame.Compiler.IExpression,Flame.IType)">
      <summary>
 Creates a new conversion expression that converts the given
 value to the given type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.StaticCastExpression.Evaluate">
      <summary>
 Evaluates this conversion expression at compile-time.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.StaticCastExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block for this conversion expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.InequalityExpression">
      <summary>
 Defines a type of expression that ascertains if its operands
 are not equal.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InequalityExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.InequalityExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InequalityExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.RemainderExpression">
      <summary>
 A type of expression that computes the remainder of its operands.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.RemainderExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.RemainderExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.RemainderExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.HashExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.HashExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedArrayExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedArrayExpression.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedArrayExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedArrayExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedArrayExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedArrayExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedVectorExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedVectorExpression.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedVectorExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedVectorExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedVectorExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.InitializedVectorExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.LeftShiftExpression">
      <summary>
 Defines a type of expression that shifts its left-hand operand to the
 left by the number of positions indicated by its right-hand operand.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LeftShiftExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.LeftShiftExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.LeftShiftExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.RightShiftExpression">
      <summary>
 Defines a type of expression that shifts its left-hand operand to the
 right by the number of positions indicated by its right-hand operand.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.RightShiftExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.RightShiftExpression.EmitPrimitive(Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeBlock,Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates an operator application code block from the given
 operands, with the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.RightShiftExpression.Create(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a binary expression of this expression type from the given
 operands. These expressions are guaranteed to have the same type
 as the operands of this expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConcatExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConcatExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ConcatExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ConcatExpression.Reduce">
      <summary>
 Reduces the concatenation expression to a simpler expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConcatExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SingletonGetExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SingletonGetExpression.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SingletonGetExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SingletonGetExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.SingletonGetExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.SingletonGetExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConstantVariableGetExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConstantVariableGetExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ConstantVariableGetExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ConstantVariableGetExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ThisAddressOfExpression.GetVariable">
      <summary>
 Gets the variable node's underlying variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ThisAddressOfExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ThisAddressOfExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ThisAddressOfExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ThisAddressOfExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ThisAddressOfExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="T:Flame.Compiler.Expressions.RelaxedInvocation">
      <summary>
 An invocation that invokes a method based on a sequence of arguments that may include the method's caller.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.RelaxedInvocation.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.RelaxedInvocation.Lower">
      <summary>
 Lowers this expression to a semantically equivalent expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.ComplexExpressionBase">
      <summary>
 A base class for high-level expressions that lower themselves to
 lower-level expressions.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ComplexExpressionBase.#ctor">
      <summary>
 Initializes a complex expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ComplexExpressionBase.Lower">
      <summary>
 Lowers this expression to a semantically equivalent expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ComplexExpressionBase.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ComplexExpressionBase.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ComplexExpressionBase.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ComplexExpressionBase.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression. If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="P:Flame.Compiler.Expressions.ComplexExpressionBase.LoweredExpression">
      <summary>
 Gets this expression's semantically equivalent lowered expression.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Expressions.ComplexExpressionBase.IsConstant">
      <summary>
 Gets a boolean value that indicates if the expression is a constant expression. A constant expression can be evaluated at compile-time.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ReturnValueGetExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ReturnValueGetExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ReturnValueGetExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ReturnValueGetExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.ReturnValueGetExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SelectExpression.AcceptFlow``2(Flame.Compiler.IFlowVisitor`2{TState,TFlow})">
      <summary>
 Accepts and interacts with a flow visitor.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SelectExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SelectExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.SelectExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.SelectExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Expressions.VoidExpression">
      <summary>
 The void expression singleton, which is a constant expression of type `void`.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.VoidExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.VoidExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.VoidExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.VoidExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.IntersectionExpression.Evaluate">
      <summary>
 Performs a compile-time evaluation of the expression.
 If it cannot be evaluated, null is returned.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.IntersectionExpression.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.IntersectionExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.IntersectionExpression.Optimize">
      <summary>
 Returns an optimized version of the expression.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Expressions.IntersectionExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.SourceExpression.Static_Singleton.Create(Flame.Compiler.IExpression,Flame.Compiler.SourceLocation)">
      <summary>
 Creates a source expression based on the given expression and location.
 If the expression argument is null, null is returned.
 If the source location is null, the statement is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Expressions.ConcatExpression.Static_Singleton.ReduceBinary(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Reduces the binary concatenation expression to a simpler expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.GlobalFlowStatementBase">
      <summary>
 Defines common functionality for statements that end a function call.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.GlobalFlowStatementBase.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.GlobalFlowStatementBase.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.GlobalFlowStatementBase.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.GlobalFlowStatementBase.AcceptFlow``2(Flame.Compiler.IFlowVisitor`2{TState,TFlow})">
      <summary>
 Accepts and interacts with a flow visitor.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.ReturnStatement">
      <summary>
 Defines a statement that sets the function's return value,
 and then terminates the function's execution.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ReturnStatement.#ctor">
      <summary>
 Creates a return statement that returns `void`.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ReturnStatement.#ctor(Flame.Compiler.IExpression)">
      <summary>
 Creates a return statement that returns the given value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ReturnStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ReturnStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.ReturnStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.ReturnStatement.Value">
      <summary>
 Gets the value that is returned by this statement.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.IfElseStatement">
      <summary>
 Defines an if-else statement, which selects a path to execute at run-time,
 based on the result of a condition expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.IfElseStatement.#ctor(Flame.Compiler.IExpression,Flame.Compiler.IStatement)">
      <summary>
 Creates an if-else statement based on the given condition and 'if' body.
 The 'else' body is assumed to be the empty statement.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.IfElseStatement.#ctor(Flame.Compiler.IExpression,Flame.Compiler.IStatement,Flame.Compiler.IStatement)">
      <summary>
 Creates an if-else statement based on the given condition, 'if' body
 and 'else' body.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.IfElseStatement.Simplify">
      <summary>
 Tries to determine statically which path will be taken.
 If this can be done, the selected path is returned.
 Otherwise, this statement is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.IfElseStatement.AcceptFlow``2(Flame.Compiler.IFlowVisitor`2{TState,TFlow})">
      <summary>
 Accepts and interacts with a flow visitor.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.IfElseStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.IfElseStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.IfElseStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.IfElseStatement.Condition">
      <summary>
 Gets the if-else statement's condition expression, which determines
 which path is taken.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.IfElseStatement.IfBody">
      <summary>
 Gets the if-else statement's 'if' body. This path will be taken
 if the condition expression evaluates to `true`.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.IfElseStatement.ElseBody">
      <summary>
 Gets the if-else statement's 'else' body. This path will be taken
 if the condition expression evaluates to `false`.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.WhileStatement.AcceptFlow``2(Flame.Compiler.IFlowVisitor`2{TState,TFlow})">
      <summary>
 Accepts and interacts with a flow visitor.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.WhileStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.WhileStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.WhileStatement.Lower">
      <summary>
 Lowers this while block to an equivalent tagged block IR tree.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.WhileStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.StoreAtAddressStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.StoreAtAddressStatement.GetVariable">
      <summary>
 Gets the variable node's underlying variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.StoreAtAddressStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.StoreAtAddressStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ThisSetStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ThisSetStatement.GetVariable">
      <summary>
 Gets the variable node's underlying variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ThisSetStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.ThisSetStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.VariableSetStatementBase`1.GetVariable">
      <summary>
 Gets the variable node's underlying variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.VariableSetStatementBase`1.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.VariableSetStatementBase`1.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.VariableSetStatementBase`1.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.VariableReleaseStatementBase`1.GetVariable">
      <summary>
 Gets the variable node's underlying variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.VariableReleaseStatementBase`1.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.VariableReleaseStatementBase`1.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.VariableReleaseStatementBase`1.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.EmptyStatement">
      <summary>
 The empty statement singleton, which compiles down to the same code block
 as a void expression. It does not have any side-effects.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.EmptyStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.EmptyStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.EmptyStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ForStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.ForStatement.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ForStatement.AcceptFlow``2(Flame.Compiler.IFlowVisitor`2{TState,TFlow})">
      <summary>
 Accepts and interacts with a flow visitor.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ForStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ForStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ComplexStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ComplexStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.ComplexStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.BlockStatement">
      <summary>
 Defines block statements, i.e. statements which execute a number of child
 statements in sequence.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.BlockStatement.#ctor(Flame.Compiler.IStatement)">
      <summary>
 Creates a new block statement from the given child statement.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.BlockStatement.#ctor(System.Collections.Generic.IEnumerable`1{Flame.Compiler.IStatement})">
      <summary>
 Creates a block statement from the given sequence of child statements.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.BlockStatement.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.BlockStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.BlockStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.BlockStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="P:Flame.Compiler.Statements.BlockStatement.Children">
      <summary>
 Gets this block statement's sequence of child statements.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.ExpressionStatement">
      <summary>
 Defines a type of statement that evaluates its inner expression, and then
 discards its value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ExpressionStatement.#ctor(Flame.Compiler.IExpression)">
      <summary>
 Creates an expression statement that wraps the given expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ExpressionStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ExpressionStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.ExpressionStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.ExpressionStatement.Expression">
      <summary>
 Gets the expression statement's inner expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.LateBoundVariableSetStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.LateBoundVariableSetStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.LateBoundVariableSetStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.LateBoundVariableReleaseStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.FieldSetStatement.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.FieldSetStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.FieldSetStatement.GetVariable">
      <summary>
 Gets the variable node's underlying variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.FieldSetStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.FieldSetStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ContainerElementSetStatement.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ContainerElementSetStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ContainerElementSetStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.CodeBlockStatement">
      <summary>
 Defines a type of statement that wraps a code block directly, which is
 returned when calling `Emit`.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.CodeBlockStatement.#ctor(Flame.Compiler.ICodeBlock)">
      <summary>
 Creates a code block statement from the given code block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.CodeBlockStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.CodeBlockStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.CodeBlockStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.CodeBlockStatement.Block">
      <summary>
 Gets the code block that is wrapped by this code block statement.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.LocalFlowStatementBase">
      <summary>
 Defines common functionality for statements that terminate the current
 iteration of a tagged local flow block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.LocalFlowStatementBase.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.LocalFlowStatementBase.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.LocalFlowStatementBase.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.LocalFlowStatementBase.AcceptFlow``2(Flame.Compiler.IFlowVisitor`2{TState,TFlow})">
      <summary>
 Accepts and interacts with a flow visitor.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.LocalFlowStatementBase.Target">
      <summary>
 Gets the tag of the tagged block whose iteration is to be terminated.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.BreakStatement">
      <summary>
 A statement type that represents the notion of a "break" statement that
 targets a specific tagged block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.BreakStatement.#ctor(Flame.Compiler.UniqueTag)">
      <summary>
 Creates a "break" statement that targets the given block tag.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.BreakStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.ContinueStatement">
      <summary>
 A statement type that represents the notion of a "continue" statement that
 targets a specific tagged block.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ContinueStatement.#ctor(Flame.Compiler.UniqueTag)">
      <summary>
 Creates a "continue" statement that targets the given block tag.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ContinueStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.DoWhileStatement">
      <summary>
 Describes a control-flow statement that executes a statement once,
 and in successive iterations, executes it only if a condition evaluates
 to `true`. This is equivalent to a `do...while` statement in the C family
 of languages.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.DoWhileStatement.AcceptFlow``2(Flame.Compiler.IFlowVisitor`2{TState,TFlow})">
      <summary>
 Accepts and interacts with a flow visitor.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.DoWhileStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.DoWhileStatement.RewriteContinueToBreak(Flame.Compiler.UniqueTag,System.Boolean)">
      <summary>
 Rewrites the do...while statement's body by replacing `continue` statements
 with `break` statements to an outer tagged statement, which has the
 given tag.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.DoWhileStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.DoWhileStatement.Lower">
      <summary>
 Lowers this do...while block to an equivalent tagged block IR tree.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.DoWhileStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.DoWhileStatement.Tag">
      <summary>
 Gets the do...while statement's block tag.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.DoWhileStatement.Condition">
      <summary>
 Gets the do...while statement's condition. After the initial iteration,
 the loop's body will be executed as long as this condition evaluates to
 true.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.DoWhileStatement.Body">
      <summary>
 Gets the do...while statement's body.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.TaggedStatement">
      <summary>
 Defines a tagged statement: the statement equivalent of a
 code generator's tagged block.
 Tagged statements are potential targets for "break" and "continue"
 statements.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.TaggedStatement.#ctor(Flame.Compiler.UniqueTag,Flame.Compiler.IStatement)">
      <summary>
 Creates a new tagged statement from the given tag and body.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.TaggedStatement.AcceptFlow``2(Flame.Compiler.IFlowVisitor`2{TState,TFlow})">
      <summary>
 Accepts and interacts with a flow visitor.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.TaggedStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.TaggedStatement.Simplify">
      <summary>
 Tries to simplify this tagged statement into sequential flow.
 If there are no 'break' and 'continue' statements to this tagged statement,
 it is converted into sequenial flow. Otherwise, this tagged statement
 is returned unchanged.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.TaggedStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.TaggedStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.TaggedStatement.Tag">
      <summary>
 Gets the tag that identifies this tagged statement.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.TaggedStatement.Body">
      <summary>
 Gets this tagged statement's body.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.YieldReturnStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.YieldReturnStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.YieldReturnStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.YieldBreakStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.YieldBreakStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.YieldBreakStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ForeachStatement.Copy">
      <summary>
 Copies this node. A new node is returned that does not depend
 on this node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ForeachStatement.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ForeachStatement.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ForeachStatement.AcceptFlow``2(Flame.Compiler.IFlowVisitor`2{TState,TDelta})">
      <summary>
 Accepts and interacts with a flow visitor.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ForeachStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ForeachStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.ForeachStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ForeachStatement.Lower">
      <summary>
 Reduces the foreach statements to more primitive statements.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.CollectionElement">
      <summary>
 A collection element in a foreach loop.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.CommentedStatement">
      <summary>
 A statement that has a comment attached to it.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.CommentedStatement.#ctor(System.String,Flame.Compiler.IStatement)">
      <summary>
 Creates a new commented statement.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.CommentedStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.CommentedStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.CommentedStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.CommentedStatement.Comment">
      <summary>
 Gets the comment to print.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.CommentedStatement.Statement">
      <summary>
 Gets the actual statement to emit.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.RawExpressionStatement">
      <summary>
 A statement wrapper for expressions.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.RawExpressionStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.RawExpressionStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.RawExpressionStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.LateBoundLabelBranchStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.LateBoundLabelBranchStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.LateBoundLabelBranchStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.LateBoundLabelMarkStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.LateBoundLabelMarkStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.LateBoundLabelMarkStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.ThrowStatement">
      <summary>
 Defines a type of statement that throws the given exception expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ThrowStatement.#ctor(Flame.Compiler.IExpression)">
      <summary>
 Creates a new throw statement from the given exception expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ThrowStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ThrowStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.ThrowStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.ThrowStatement.Exception">
      <summary>
 Gets the expression that creates the exception object this statement
 throws.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.AssertStatement">
      <summary>
 Defines a statement that checks if an expression evaluates to `true`.
 If not, the user is notified in an implementation-defined manner.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.AssertStatement.#ctor(Flame.Compiler.IExpression)">
      <summary>
 Creates an assertion statement from the given expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.AssertStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.AssertStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.AssertStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.AssertStatement.Expression">
      <summary>
 Gets the expression that is tested for equality to `true`.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Statements.SourceStatement">
      <summary>
 A statement that contains a location in the source document, for diagnostics
 and debugging purposes.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.SourceStatement.#ctor(Flame.Compiler.IStatement,Flame.Compiler.SourceLocation)">
      <summary>
 Creates a new source statement from the given statement and location.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.SourceStatement.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.SourceStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.SourceStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.SourceStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.SourceStatement.Value">
      <summary>
 Gets the source statement's inner statement.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.SourceStatement.Location">
      <summary>
 Gets the source statement's location.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.TryStatement.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.TryStatement.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.TryStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.TryStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.TryStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ContractBodyStatement.AcceptPredicate(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts the predicate node visitor.
 Said visitor promises not to modify this node or any of its contents.
 Furthermore, calling 'AcceptPredicate' must always produce the same state changes
 as calling 'Accept' when using the same visitor, but may do so
 more efficiently.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ContractBodyStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.ContractBodyStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.ContractBodyStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Statements.ContractBodyStatement.IsEmptyContract">
      <summary>
 Tests if this contract's preconditions and postconditions are
 actually both empty.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.EmitVariableSetStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.EmitVariableSetStatement.Optimize">
      <summary>
 Returns an optimized version of the statement.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Statements.EmitVariableSetStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Statements.SourceStatement.Static_Singleton.Create(Flame.Compiler.IStatement,Flame.Compiler.SourceLocation)">
      <summary>
 Creates a source statement based on the given statement and location.
 If the statement argument is null, null is returned.
 If the source location is null, the statement is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ThisVariable.CreateAddressOfExpression">
      <summary>
 Creates an expression that returns the address in memory of this variable.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Variables.ThisVariable.CreateGetExpression">
      <summary>
 Creates an expression that returns this variable's value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ThisVariable.CreateSetStatement(Flame.Compiler.IExpression)">
      <summary>
 Creates a statement that assigns the given value to this variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ThisVariable.CreateReleaseStatement">
      <summary>
 Creates a release statement for this variable. Release statements
 flag this variable for re-use within the scope of the current method.
 The actual re-use of the variable is the variable and the code generator's
 prerogative.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Variables.ExpressionVariable">
      <summary>
 Defines a variable that supports creating a get-expression, which returns
 the expression variable's underlying expression.
 set-statements and release-statements can be created by this expression variables,
 but they will always be empty.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ExpressionVariable.#ctor(Flame.Compiler.IExpression)">
      <summary>
 Creates an expression variable from the given underlying expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ExpressionVariable.CreateGetExpression">
      <summary>
 Creates an expression that returns this variable's value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ExpressionVariable.CreateSetStatement(Flame.Compiler.IExpression)">
      <summary>
 Returns an error expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ExpressionVariable.CreateReleaseStatement">
      <summary>
 Returns an empty statement.
 </summary>
      <remarks>
 Returning an empty statement is the right thing to do here. We don't
 want to generate null statements simply because somebody tried to
 release an expression variable. release-statements are mostly a performance
 thing anyway, and have no guarantee of succeeding.
 </remarks>
    </member>
    <member name="P:Flame.Compiler.Variables.ExpressionVariable.Expression">
      <summary>
 Gets the expression variable's underlying expression.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Variables.ArgumentVariable">
      <summary>
 A type of variable that represents an argument to a function.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ArgumentVariable.#ctor(Flame.IParameter,System.Int32)">
      <summary>
 Creates a new argument variable from the given parameter and index.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ArgumentVariable.CreateGetExpression">
      <summary>
 Creates an expression that returns this variable's value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ArgumentVariable.CreateSetStatement(Flame.Compiler.IExpression)">
      <summary>
 Creates a statement that assigns the given value to this variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ArgumentVariable.CreateReleaseStatement">
      <summary>
 Creates a release statement for this variable. Release statements
 flag this variable for re-use within the scope of the current method.
 The actual re-use of the variable is the variable and the code generator's
 prerogative.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ArgumentVariable.CreateAddressOfExpression">
      <summary>
 Creates an expression that returns the address in memory of this variable.
 </summary>
      <returns />
    </member>
    <member name="P:Flame.Compiler.Variables.ArgumentVariable.Parameter">
      <summary>
 Gets this argument variable's associated parameter.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Variables.ArgumentVariable.Index">
      <summary>
 Gets the zero-based index of this variable's associated parameter in
 the parameter list.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ArgumentGetExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ArgumentGetExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ArgumentGetExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ArgumentAddressOfExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ArgumentAddressOfExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ArgumentAddressOfExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ArgumentSetStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ArgumentSetStatement.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ArgumentSetStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Variables.ManuallyBoundVariable">
      <summary>
 A type of variable that can be bound to another variable, which it
 then uses to generate code blocks.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ManuallyBoundVariable.BindVariable(Flame.Compiler.Emit.IMethodStructureGenerator)">
      <summary>
 Automatically assigns a real variable to this late-bound variable,
 based on the given method structure generator.
 </summary>
      <param name="Generator" />
    </member>
    <member name="M:Flame.Compiler.Variables.ManuallyBoundVariable.BindVariable(Flame.Compiler.Emit.IEmitVariable)">
      <summary>
 Assigns an emit variable to this late-bound variable.
 </summary>
      <param name="Generator" />
    </member>
    <member name="M:Flame.Compiler.Variables.ManuallyBoundVariable.BindVariable(Flame.Compiler.IVariable)">
      <summary>
 Assigns a "real" variable to this late-bound variable.
 </summary>
      <param name="Generator" />
    </member>
    <member name="M:Flame.Compiler.Variables.ManuallyBoundVariable.CreateGetExpression">
      <summary>
 Creates an expression that returns this variable's value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ManuallyBoundVariable.CreateSetStatement(Flame.Compiler.IExpression)">
      <summary>
 Creates a statement that assigns the given value to this variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ManuallyBoundVariable.CreateAddressOfExpression">
      <summary>
 Creates an expression that returns the address in memory of this variable.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Variables.ManuallyBoundVariable.CreateReleaseStatement">
      <summary>
 Creates a release statement for this variable. Release statements
 flag this variable for re-use within the scope of the current method.
 The actual re-use of the variable is the variable and the code generator's
 prerogative.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Variables.LocalVariable">
      <summary>
 A type for local variables.
 </summary>
      <remarks>
 This type of variable replaces LateBoundVariable.
 </remarks>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalVariable.#ctor(Flame.Compiler.IVariableMember,Flame.Compiler.UniqueTag)">
      <summary>
 Creates a new local variable from the given variable member and
 unique tag.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalVariable.#ctor(Flame.Compiler.IVariableMember)">
      <summary>
 Creates a new local variable from the given variable member.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalVariable.#ctor(Flame.IType)">
      <summary>
 Creates a new local variable from the given type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalVariable.#ctor(System.String,Flame.IType)">
      <summary>
 Creates a new local variable from the given name and type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalVariable.GetEmitVariable(Flame.Compiler.ICodeGenerator)">
      <summary>
 Gets the emit variable for this local variable, in
 the given code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalVariable.ConvertType(Flame.Compiler.MemberConverter)">
      <summary>
 Converts this local variable's type by applying the given
 member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalVariable.CreateGetExpression">
      <summary>
 Creates an expression that returns this variable's value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalVariable.CreateSetStatement(Flame.Compiler.IExpression)">
      <summary>
 Creates a statement that assigns the given value to this variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalVariable.CreateAddressOfExpression">
      <summary>
 Creates an expression that returns the address in memory of this variable.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Variables.LocalVariable.CreateReleaseStatement">
      <summary>
 Creates a release statement for this variable. Release statements
 flag this variable for re-use within the scope of the current method.
 The actual re-use of the variable is the variable and the code generator's
 prerogative.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Variables.LocalVariable.Type">
      <summary>
 Gets this local variable's type.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Variables.LocalVariable.Tag">
      <summary>
 Gets this local variable's unique tag.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Variables.LocalVariable.Member">
      <summary>
 Gets this local variable's associated variable member.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalGetExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalGetExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalGetExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalAddressOfExpression.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalAddressOfExpression.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalAddressOfExpression.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalSetStatement.Accept(Flame.Compiler.INodeVisitor)">
      <summary>
 Accepts a node visitor.
 This method is applies the visitor to this node's children and
 returns a new node with the same structure as this node, but with
 the updated children.
 If this node has no children, this node is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalSetStatement.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalSetStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalReleaseStatement.ConvertMembers(Flame.Compiler.MemberConverter)">
      <summary>
 Converts the node's members with the given member converter.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.LocalReleaseStatement.Emit(Flame.Compiler.ICodeGenerator)">
      <summary>
 Creates a code block that captures this code node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Variables.FieldVariable">
      <summary>
 A type of variable that represents a field of a target value. This value can
 be either a value or reference type. If said target value is a value type,
 however, setting the field's value will be a no-op.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.FieldVariable.CreateGetExpression">
      <summary>
 Creates an expression that returns this variable's value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.FieldVariable.CreateSetStatement(Flame.Compiler.IExpression)">
      <summary>
 Creates a statement that assigns the given value to this variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.FieldVariable.CreateAddressOfExpression">
      <summary>
 Creates an expression that returns the address in memory of this variable.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Variables.FieldVariable.CreateReleaseStatement">
      <summary>
 Creates a release statement for this variable. Release statements
 flag this variable for re-use within the scope of the current method.
 The actual re-use of the variable is the variable and the code generator's
 prerogative.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Variables.ValueTypeFieldVariable">
      <summary>
 A type of variable that represents a field of a target variable, which
 is a value type. If one requests to set the field's value, the target
 variable's address is loaded, and said address is used when addressing
 the field, as opposed to using the target's value. What this means is
 that the field's value will actually change when a set-statement is executed.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ValueTypeFieldVariable.#ctor(Flame.IField,Flame.Compiler.IVariable)">
      <summary>
 Creates a new value type field variable from the given field
 and target variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ValueTypeFieldVariable.CreateGetExpression">
      <summary>
 Creates an expression that returns this variable's value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ValueTypeFieldVariable.CreateSetStatement(Flame.Compiler.IExpression)">
      <summary>
 Creates a statement that assigns the given value to this variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ValueTypeFieldVariable.CreateAddressOfExpression">
      <summary>
 Creates an expression that returns the address in memory of this variable.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Variables.ValueTypeFieldVariable.CreateReleaseStatement">
      <summary>
 Creates a release statement for this variable. Release statements
 flag this variable for re-use within the scope of the current method.
 The actual re-use of the variable is the variable and the code generator's
 prerogative.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Variables.PropertyVariable">
      <summary>
 Defines a type of variable that operates analogously to a property:
 get-expressions call the 'get' accessor, and set-statements call the
 'set' accessor.
 </summary>
      <remarks>
 In the past, property variables were actually associated with a single
 property, but this doesn't work well with asymmetric property overrides.
 Consider the following snippet of code:
 <code>
 public abstract VectorBase
 {
     double Length { virtual get { ... } virtual set { ... } }
 }

 public class Vector
 {
     public double Length { override get { ... } }
     public double LengthSquared { get { return Length * Length; } }
                                                ^~~~~~ refers to `Vector.Length`
     public void SetLength(double Value)
     {
         Length = Value;
         ^~~~~~ refers to `VectorBase.Length`
     }
 }
 </code></remarks>
    </member>
    <member name="M:Flame.Compiler.Variables.PropertyVariable.CreateGetExpression">
      <summary>
 Creates an expression that returns this variable's value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.PropertyVariable.CreateSetStatement(Flame.Compiler.IExpression)">
      <summary>
 Creates a statement that assigns the given value to this variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.PropertyVariable.CreateReleaseStatement">
      <summary>
 Creates a release statement for this variable. Release statements
 flag this variable for re-use within the scope of the current method.
 The actual re-use of the variable is the variable and the code generator's
 prerogative.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Variables.PropertyVariable.HasGetter">
      <summary>
 Gets a boolean flag that indicates whether this property variable has a
 getter.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Variables.PropertyVariable.HasSetter">
      <summary>
 Gets a boolean flag that indicates whether this property variable has a
 setter.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Variables.PropertyVariable.Getter">
      <summary>
 Gets the property variable's 'get' accessor.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Variables.PropertyVariable.Setter">
      <summary>
 Gets the property variable's 'set' accessor.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Variables.PropertyVariable.IndexerArguments">
      <summary>
 Gets the property's indexer arguments.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Variables.ElementVariable">
      <summary>
 A type of variable that represents an expression indexed by a sequence
 of arguments. Said expression's type can be either a container type, or
 a type with a user-defined indexer.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ElementVariable.#ctor(Flame.Compiler.IExpression,System.Collections.Generic.IEnumerable`1{Flame.Compiler.IExpression})">
      <summary>
 Creates a new element variable from the given target and argument
 expressions.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ElementVariable.CreateAddressOfExpression">
      <summary>
 Creates an expression that returns the address in memory of this variable.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Variables.ElementVariable.CreateGetExpression">
      <summary>
 Creates an expression that returns this variable's value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ElementVariable.CreateSetStatement(Flame.Compiler.IExpression)">
      <summary>
 Creates a statement that assigns the given value to this variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ElementVariable.CreateReleaseStatement">
      <summary>
 Creates a release statement for this variable. Release statements
 flag this variable for re-use within the scope of the current method.
 The actual re-use of the variable is the variable and the code generator's
 prerogative.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Variables.ElementVariable.IndexArgumentTypes">
      <summary>
 Gets the types of the index arguments, as an array.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Variables.ElementVariable.IndexerProperty">
      <summary>
 Gets the user-defined indexer property this element variable relies on.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Variables.ElementVariable.CanResolve">
      <summary>
 Gets a boolean value that tells if this element variable could be
 resolved, i.e., is well-formed.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Variables.ElementVariable.IsContainerElement">
      <summary>
 Gets a boolean flag that indicates whether this element variable's
 target is a container element.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Variables.ElementVariable.Target">
      <summary>
 Gets the expression that is indexed.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Variables.ElementVariable.IndexArguments">
      <summary>
 Gets the sequence of arguments that is used to index the target
 variable.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Variables.AtAddressVariable">
      <summary>
 Accesses the underlying value of a pointer.
 It acts like a reference ('ref' in C#, 'T&amp;' in C++, 'ByRef' in VB) by using
 pointer indirection to modify a variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.AtAddressVariable.CreateAddressOfExpression">
      <summary>
 Creates an expression that returns the address in memory of this variable.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Variables.AtAddressVariable.CreateGetExpression">
      <summary>
 Creates an expression that returns this variable's value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.AtAddressVariable.CreateSetStatement(Flame.Compiler.IExpression)">
      <summary>
 Creates a statement that assigns the given value to this variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.AtAddressVariable.CreateReleaseStatement">
      <summary>
 Creates a release statement for this variable. Release statements
 flag this variable for re-use within the scope of the current method.
 The actual re-use of the variable is the variable and the code generator's
 prerogative.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.SingletonVariable.CreateGetExpression">
      <summary>
 Creates an expression that returns this variable's value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.SingletonVariable.CreateSetStatement(Flame.Compiler.IExpression)">
      <summary>
 Creates a statement that assigns the given value to this variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.SingletonVariable.CreateReleaseStatement">
      <summary>
 Creates a release statement for this variable. Release statements
 flag this variable for re-use within the scope of the current method.
 The actual re-use of the variable is the variable and the code generator's
 prerogative.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Variables.ConstantVariable">
      <summary>
 Describes a variable that has a constant value which may be evaluated at compile time by get expressions.
 This value is also assumed to be stored in the underlying variable object once get expressions or address-of expressions are created.
 Essentially, substituting variable access for value access should not have a result on the program's output.
 This is a useful property for certain optimizations.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ConstantVariable.CreateGetExpression">
      <summary>
 Creates an expression that returns this variable's value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ConstantVariable.CreateSetStatement(Flame.Compiler.IExpression)">
      <summary>
 Creates a statement that assigns the given value to this variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ConstantVariable.CreateAddressOfExpression">
      <summary>
 Creates an expression that returns the address in memory of this variable.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Variables.ConstantVariable.CreateReleaseStatement">
      <summary>
 Creates a release statement for this variable. Release statements
 flag this variable for re-use within the scope of the current method.
 The actual re-use of the variable is the variable and the code generator's
 prerogative.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ReturnValueVariable.CreateGetExpression">
      <summary>
 Creates an expression that returns this variable's value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ReturnValueVariable.CreateSetStatement(Flame.Compiler.IExpression)">
      <summary>
 Creates a statement that assigns the given value to this variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ReturnValueVariable.CreateReleaseStatement">
      <summary>
 Creates a release statement for this variable. Release statements
 flag this variable for re-use within the scope of the current method.
 The actual re-use of the variable is the variable and the code generator's
 prerogative.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.TypedEmitVariable.CreateAddressOfExpression">
      <summary>
 Creates an expression that returns the address in memory of this variable.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Variables.TypedEmitVariable.CreateGetExpression">
      <summary>
 Creates an expression that returns this variable's value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.TypedEmitVariable.CreateSetStatement(Flame.Compiler.IExpression)">
      <summary>
 Creates a statement that assigns the given value to this variable.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.TypedEmitVariable.CreateReleaseStatement">
      <summary>
 Creates a release statement for this variable. Release statements
 flag this variable for re-use within the scope of the current method.
 The actual re-use of the variable is the variable and the code generator's
 prerogative.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ThisVariable.Static_Singleton.GetThisType(Flame.IType)">
      <summary>
 Gets the type of the 'this' variable, if the given type is the
 declaring type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ThisVariable.Static_Singleton.IsThisVariable(Flame.Compiler.IVariable)">
      <summary>
 Gets a boolean value that indicates whether the given variable refers directly or indirectly to a ThisVariable reference.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ExpressionVariable.Static_Singleton.Create(Flame.Compiler.IExpression)">
      <summary>
 Creates a variable that corresponds to the given expression.
 If said expression itself refers to a variable, said underlying
 variable is returned. Otherwise, an expression variable containing
 the given expression is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Variables.ElementVariable.Static_Singleton.GetElementType(Flame.IType,System.Collections.Generic.IEnumerable`1{Flame.IType})">
      <summary>
 Gets the return type of an indexing operation on the given
 target type with the given sequence of argument types.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.AggregatePass`1">
      <summary>
 Defines an aggregate pass, which applies two passes in sequence.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.AggregatePass`1.#ctor(Flame.Compiler.Visitors.IPass`2{T,T},Flame.Compiler.Visitors.IPass`2{T,T})">
      <summary>
 Creates a new aggregate pass from the given passes.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.AggregatePass`1.Apply(T)">
      <summary>
 Applies this pass to the given value.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.AggregatePass`1.First">
      <summary>
 Gets the first pass to apply to the input.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.AggregatePass`1.Second">
      <summary>
 Gets the second pass to apply to the input.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.AggregateVisitor">
      <summary>
 Defines a node visitor that applies two visitors in sequence.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.AggregateVisitor.#ctor(Flame.Compiler.INodeVisitor,Flame.Compiler.INodeVisitor)">
      <summary>
 Creates a new aggregate visitor from the given visitors.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.AggregateVisitor.Visit(Flame.Compiler.IExpression)">
      <summary>
 "Visits" an expression: an expression is taken as input and transformed into another expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.AggregateVisitor.Visit(Flame.Compiler.IStatement)">
      <summary>
 "Visits" a statement: an statement is taken as input and transformed into another statement.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.AggregateVisitor.First">
      <summary>
 Gets the first visitor to apply to the input.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.AggregateVisitor.Second">
      <summary>
 Gets the second visitor to apply to the input.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.AggregateMatchVisitor">
      <summary>
 Defines a node visitor that applies two visitors in sequence.
 These two visitors must be `NodeVisitorBase` visitors, as their
 `Matches` method is used when visiting nodes.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.AggregateMatchVisitor.#ctor(Flame.Compiler.Visitors.NodeVisitorBase,Flame.Compiler.Visitors.NodeVisitorBase)">
      <summary>
 Creates a new aggregate visitor from the given visitors.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.AggregateMatchVisitor.First">
      <summary>
 Gets the first visitor to apply to the input.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.AggregateMatchVisitor.Second">
      <summary>
 Gets the second visitor to apply to the input.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.AnyPredicateVisitorBase">
      <summary>
 Provides a base class for node visitors that check whether
 a node visitor satisfies a condition. Once said condition has been
 satisfied, the visitor will ignore future nodes and try to
 return as quickly as possible. Basically, it will say that the predicate
 has been satisfied if a single node does.
 </summary>
      <remarks>
 This class inherits from 'NodeVisitorBase' to provide a common 'Matches' API,
 which is a useful property creating an aggregate visitor.
 </remarks>
    </member>
    <member name="M:Flame.Compiler.Visitors.AnyPredicateVisitorBase.Satisfies(Flame.Compiler.INode)">
      <summary>
 Finds out whether the given node satisfies the predicate.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.AnyPredicateVisitorBase.IsSatisfied">
      <summary>
 Gets a boolean value that indicates whether the predicate has been
 satisfied.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.FunctionPredicateVisitor">
      <summary>
 Defines a predicate visitor based on a function/delegate.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.FunctionPredicateVisitor.Satisfies(Flame.Compiler.INode)">
      <summary>
 Finds out whether the given node satisfies the predicate.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.IBodyPassEnvironment">
      <summary>
 Describes an environment for body passes.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.IBodyPassEnvironment.GetMethodBody(Flame.IMethod)">
      <summary>
 Tries to retrieve the method body of the given method.
 If this cannot be done, null is returned.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.IBodyPassEnvironment.Environment">
      <summary>
 Gets the target environment.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.IBodyPassEnvironment.Log">
      <summary>
 Gets the body pass environment's log.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.BodyPassArgument">
      <summary>
 Contains a body pass' arguments.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.BodyPassArgument.#ctor(Flame.Compiler.Visitors.IBodyPassEnvironment,Flame.Compiler.Visitors.PassMetadata,Flame.IMethod,Flame.Compiler.IStatement)">
      <summary>
 Creates a new body pass argument from the given values.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.BodyPassArgument.#ctor(Flame.Compiler.Visitors.BodyPassArgument,Flame.Compiler.IStatement)">
      <summary>
 Creates a new body pass argument from the given previous body
 pass argument and new method body.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.BodyPassArgument.Environment">
      <summary>
 Gets the target method's environment.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.BodyPassArgument.DeclaringType">
      <summary>
 Gets the declaring method's declaring type.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.BodyPassArgument.PassEnvironment">
      <summary>
 Gets the body pass' environment.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.BodyPassArgument.Metadata">
      <summary>
 Gets the pass' metadata.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.BodyPassArgument.DeclaringMethod">
      <summary>
 Gets the declaring method.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.BodyPassArgument.Body">
      <summary>
 Gets the target method's body statement.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.BodyPassBase">
      <summary>
 Defines a base class for method body passes.
 A method body pass is allowed to create new members within the
 method's declaring type, but cannot remove, rename or otherwise
 modify members.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.BodyPassBase.#ctor">
      <summary>
 Creates a new body pass.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.BodyPassBase.Apply(Flame.IEnvironment,Flame.IMethod,Flame.Compiler.IStatement)">
      <summary>
 Applies this pass to the given method, method body, type builder and environment.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.BodyPassBase.Apply(Flame.Compiler.Visitors.BodyPassArgument)">
      <summary>
 Applies this pass to the given method, method body, type builder and environment.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.FatBodyPass">
      <summary>
 Defines a "fat" body pass: a pass that executes a body pass, and subsequently
 combines the pass' output statement with the pass' other arguments.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.FatBodyPass.#ctor(Flame.Compiler.Visitors.IPass`2{Flame.Compiler.Visitors.BodyPassArgument,Flame.Compiler.IStatement})">
      <summary>
 Creates a new fat body pass based on the given body pass.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.FatBodyPass.Apply(Flame.Compiler.Visitors.BodyPassArgument)">
      <summary>
 Applies this pass to the given value.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.FatBodyPass.Pass">
      <summary>
 Gets the fat body pass' inner body pass.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.SlimBodyPass">
      <summary>
 Defines a "slim" body pass: a body pass that uses a "fat" body
 pass under the hood.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.SlimBodyPass.#ctor(Flame.Compiler.Visitors.IPass`2{Flame.Compiler.Visitors.BodyPassArgument,Flame.Compiler.Visitors.BodyPassArgument})">
      <summary>
 Creates a new slim body pass based on the given fat body pass.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.SlimBodyPass.Apply(Flame.Compiler.Visitors.BodyPassArgument)">
      <summary>
 Applies this pass to the given value.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.SlimBodyPass.Pass">
      <summary>
 Gets the slim body pass' inner fat body pass.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.AggregateBodyPass">
      <summary>
 Defines an aggregate body pass.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.AggregateBodyPass.#ctor(Flame.Compiler.Visitors.IPass`2{Flame.Compiler.Visitors.BodyPassArgument,Flame.Compiler.IStatement},Flame.Compiler.Visitors.IPass`2{Flame.Compiler.Visitors.BodyPassArgument,Flame.Compiler.IStatement})">
      <summary>
 Creates a new aggregate pass from the given passes.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.AggregateBodyPass.Apply(Flame.Compiler.Visitors.BodyPassArgument)">
      <summary>
 Applies this pass to the given value.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.AggregateBodyPass.First">
      <summary>
 Gets the first body pass to apply to the input.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.AggregateBodyPass.Second">
      <summary>
 Gets the second body pass to apply to the input.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.CloningVisitor">
      <summary>
 Defines a visitor that creates a copy, recursively removing any dependencies
 on the original node tree.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.ContextlessVisitorBase">
      <summary>
 A visitor base class for visitors that do not in any way depend on
 the context, i.e. which method owns the nodes being visited.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.ContextlessVisitorBase.VisitBody(Flame.Compiler.IExpression,Flame.IMethod)">
      <summary>
 Visits the given expression, which logically belongs to the given method.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.ContextlessVisitorBase.VisitBody(Flame.Compiler.IStatement,Flame.IMethod)">
      <summary>
 Visits the given statement, which logically belongs to the given method.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.ContinueRewriter">
      <summary>
 A node visitor that replaces all `continue` statements to a specific block
 with a given statement.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.ContinueRewriter.#ctor(Flame.Compiler.UniqueTag,Flame.Compiler.IStatement)">
      <summary>
 Creates a continue rewriter that replaces all `continue` statements to the given block
 with the given statement.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.ContinueRewriter.Target">
      <summary>
 Gets the block target of all `continue` statements that are to be rewritten.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.ContinueRewriter.RewrittenContinue">
      <summary>
 Gets the statement every `continue` statement to the block target
 is replaced with.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.ContinueRewriter.HasRewritten">
      <summary>
 Gets a boolean value that tells whether at least one `continue` statement
 has been rewritten or not.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.DeadCodeVisitor">
      <summary>
 Defines a flow visitor that trims dead code.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.DeadCodeVisitor.CreateCollapsedFlow(System.Boolean,System.Boolean)">
      <summary>
 Computes the "sum" of a flow state and a control flow delta.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.DeadCodeVisitor.CreateDeltaFlow(System.Boolean,System.Boolean)">
      <summary>
 Computes the "difference" between two flow states, such that
 the "sum" of the first flow state and the result of this operation
 results in the second state.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.DeadCodeVisitor.CreateSequenceFlow(System.Boolean,System.Boolean)">
      <summary>
 Creates a flow delta that represents the sequential execution of
 two flow deltas.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.DeadCodeVisitor.CreateSelectFlow(System.Boolean,System.Boolean)">
      <summary>
 Selects precisely one of two flow paths.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.DeadCodeVisitor.CreateLoopFlow(Flame.Compiler.UniqueTag,System.Boolean)">
      <summary>
 Creates a flow state that "loops", i.e. will be executed zero or more
 times.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.DeadCodeVisitor.SimplifyStatement(Flame.Compiler.IStatement)">
      <summary>
 Tries to simplify the given statement.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.DeadCodeVisitor.VisitBody(Flame.Compiler.IExpression,Flame.IMethod)">
      <summary>
 Visits the given expression, which logically belongs to the given method.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.DeadCodeVisitor.VisitBody(Flame.Compiler.IStatement,Flame.IMethod)">
      <summary>
 Visits the given statement, which logically belongs to the given method.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.DeadCodeVisitor.TerminatedFlow">
      <summary>
 Gets a flow delta that represents flow termination:
 sequential flow that trails it will never be executed.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.EmptyPass`1">
      <summary>
 Defines a generic empty pass, which merely returns its input argument.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.EmptyPass`1.Apply(T)">
      <summary>
 Applies this pass to the given value.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.EmptyVisitor">
      <summary>
 Defines an empty visitor, which does not in any way modify its input.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.ExpressionRewriter">
      <summary>
 A node visitor that matches and then replaces expressions.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.ExpressionRewriter.#ctor(System.Boolean(Flame.Compiler.IExpression),Flame.Compiler.IExpression(Flame.Compiler.IExpression))">
      <summary>
 Creates a final flow visitor from the given delegates.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.ExpressionRewriter.MatchesExpression">
      <summary>
 Finds out whether a given statement matches a set of criteria.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.ExpressionRewriter.TransformExpression">
      <summary>
 Transforms a matched statement.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.IPass`2">
      <summary>
 Defines a generic "pass": a transformation of a value that may or may not
 leave the old value in an undefined state.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.IPass`2.Apply(TIn)">
      <summary>
 Applies this pass to the given value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.PassExtensions.Aggregate``1(System.Collections.Generic.IEnumerable`1{Flame.Compiler.Visitors.IPass`2{T,T}})">
      <summary>
 Creates the aggregate of the given sequence of passes.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.PassExtensions.Aggregate(System.Collections.Generic.IEnumerable`1{Flame.Compiler.Visitors.IPass`2{Flame.Compiler.Visitors.BodyPassArgument,Flame.Compiler.IStatement}})">
      <summary>
 Creates the aggregate of the given sequence of passes.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.LocationVisitorBase">
      <summary>
 A node visitor that takes source location nodes into account when
 visiting a node tree.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.LocationVisitorBase.#ctor">
      <summary>
 Creates a new location visitor base.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.LocationVisitorBase.CurrentLocation">
      <summary>
 Gets the location visitor's current location, obtained from source statements
 and expressions.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.LoggingVisitor">
      <summary>
 A node visitor that visits all error and warning nodes, and logs their
 contents.
 Said nodes are optionally simplified to their inner nodes.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.LoggingVisitor.#ctor(Flame.Compiler.ICompilerLog,System.Boolean,System.Boolean)">
      <summary>
 Creates a new logging visitor from the given compiler log and a
 flag that tells if error and warning nodes are to be
 simplified to their inner nodes, and another that determines whether
 source nodes are to be reduced to their contents, as well.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.LoggingVisitor.Log">
      <summary>
 Gets the compiler log that is used to write errors and warnings to.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.LoggingVisitor.StripMessages">
      <summary>
 Gets a boolean value that tells if error and warning nodes are to be
 stripped away, replaced by their inner nodes.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.LoggingVisitor.StripSource">
      <summary>
 Gets a boolean value that tells if source nodes are to be removed,
 and replaced by their inner nodes.
 </summary>
    </member>
    <member name="F:Flame.Compiler.Visitors.LoggingVisitor.currentLocation">
      <summary>
 The logging visitor's current location, obtained from source statements
 and expressions.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.LowerContractPass">
      <summary>
 A method body pass that lowers contract statements into assertions.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.LowerContractPass.Apply(Flame.Compiler.Visitors.BodyPassArgument)">
      <summary>
 Applies this pass to the given value.
 </summary>
    </member>
    <member name="F:Flame.Compiler.Visitors.LowerContractPass.LowerContractPassName">
      <summary>
 Stores the lower contract pass' name.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.LowerContractVisitor">
      <summary>
 A node visitor that lowers contract statements into assertions.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.LowerContractVisitor.LowerContractStatement(Flame.Compiler.Statements.ContractBodyStatement)">
      <summary>
 Lowers the given contract statement.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.PostconditionInsertingVisitor">
      <summary>
 A statement visitor that inserts postcondition checks whenever
 a value is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.PostconditionInsertingVisitor.#ctor(System.Collections.Generic.IEnumerable`1{Flame.Compiler.IExpression})">
      <summary>
 Creates a new postcondition inserting visitor from the given
 sequence of postconditions.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.PostconditionInsertingVisitor.Postconditions">
      <summary>
 Gets a sequence of postconditions to insert.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.ReturnValueRewritingVisitor">
      <summary>
 Defines a return value access rewriting visitor that replaces
 return value access expressions with get-expressions from the given
 variables.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.ReturnValueRewritingVisitor.#ctor(Flame.Compiler.IVariable)">
      <summary>
 Creates a return value access rewriting visitor that replaces
 return value access expressions with get-expressions from the given
 variables.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.ReturnValueRewritingVisitor.ReturnValueVariable">
      <summary>
 Gets the return value variable that is used to replace return value
 access expressions with.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.LowerLambdaPass">
      <summary>
 Lowers `LambdaExpression`s to closure classes.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.LowerLambdaPass.Apply(Flame.Compiler.Visitors.BodyPassArgument)">
      <summary>
 Applies this pass to the given value.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.SubstituteLambdaDependentExprClosure.ThisDelegate">
      <summary>
 Gets an expression that creates a delegate for this
 lambda function.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.SubstituteLambdaDependentExprClosure.CapturedValues">
      <summary>
 Gets the captured value list.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.LowerYieldPassBase">
      <summary>
 A pass that reduces methods with yield return/yield break statements to
 enumerable/enumerator implementations.

 Requirements for this pass to run:
  * The enclosing type of the method must be a namespace (implements INamespace).
  * The output assembly's code generators must support labels.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.LowerYieldPassBase.ImplementEnumerable(Flame.IEnvironment,Flame.Build.DescribedType,Flame.IType,Flame.Compiler.IStatement)">
      <summary>
 Implements the enumerable pattern for the given type based on the
 given implementation for the get enumerator method.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.LowerYieldPassBase.ImplementEnumerator(Flame.IEnvironment,Flame.Build.DescribedType,Flame.IType,Flame.Compiler.IStatement,Flame.Compiler.IStatement)">
      <summary>
 Implements the enumerator pattern for the given type based on the
 provided implementations for the move next method and current item property.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.LowerYieldPassBase.Apply(Flame.IEnvironment,Flame.IMethod,Flame.Compiler.IStatement)">
      <summary>
 Applies this pass to the given method, method body, type builder and environment.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.YieldNodeFindingVisitor.Satisfies(Flame.Compiler.INode)">
      <summary>
 Finds out whether the given node satisfies the predicate.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.MemberNodeVisitor.VisitBody(Flame.Compiler.IExpression,Flame.IMethod)">
      <summary>
 Visits the given expression, which logically belongs to the given method.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.MemberNodeVisitor.VisitBody(Flame.Compiler.IStatement,Flame.IMethod)">
      <summary>
 Visits the given statement, which logically belongs to the given method.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.MemberSignaturePassArgument`1">
      <summary>
 Defines a data structure that holds information
 pertaining to member signature passes.
 </summary>
      <typeparam name="T" />
    </member>
    <member name="M:Flame.Compiler.Visitors.MemberSignaturePassArgument`1.#ctor(T,Flame.Compiler.Visitors.IBodyPassEnvironment)">
      <summary>
 Creates a new member signature pass argument
 from the given member and pass environment.
 </summary>
      <param name="PassEnvironment" />
    </member>
    <member name="P:Flame.Compiler.Visitors.MemberSignaturePassArgument`1.Log">
      <summary>
 Gets the compiler log.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.MemberSignaturePassArgument`1.Environment">
      <summary>
 Gets the environment.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.MemberSignaturePassArgument`1.Member">
      <summary>
 Gets the member signature this pass is
 being applied to.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.MemberSignaturePassArgument`1.PassEnvironment">
      <summary>
 Gets the pass environment for this pass.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.MemberSignaturePassResult">
      <summary>
 Gets the result of a member signature pass.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.MemberSignaturePassResult.#ctor">
      <summary>
 Creates a member signature pass result with a null name
 and no additional attributes.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.MemberSignaturePassResult.#ctor(System.String)">
      <summary>
 Creates a member signature pass result from the given
 name.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.MemberSignaturePassResult.#ctor(System.String,System.Collections.Generic.IEnumerable`1{Flame.IAttribute})">
      <summary>
 Creates a member signature pass result from the given
 name and additional attributes.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.MemberSignaturePassResult.Combine(Flame.Compiler.Visitors.MemberSignaturePassResult)">
      <summary>
 Combines the given member signature pass result with this one.
 The other's name is preferred over this instance's name.
 </summary>
      <param name="Other" />
      <returns />
    </member>
    <member name="P:Flame.Compiler.Visitors.MemberSignaturePassResult.Name">
      <summary>
 Gets the member's (new) name, if any.
 Otherwise, null.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.MemberSignaturePassResult.AdditionalAttributes">
      <summary>
 Gets a sequence of additional attributes that have
 been inferred.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.NodeVisitorBase.Visit(Flame.Compiler.IExpression)">
      <summary>
 "Visits" an expression: an expression is taken as input and transformed into another expression.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.NodeVisitorBase.Visit(Flame.Compiler.IStatement)">
      <summary>
 "Visits" a statement: an statement is taken as input and transformed into another statement.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.PassMetadata">
      <summary>
 Defines metadata for a pass.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.PassMetadata.#ctor(Flame.Compiler.IRandomAccessOptions,Flame.Compiler.IRandomAccessOptions,Flame.Compiler.IRandomAccessOptions)">
      <summary>
 Creates a new pass metadata object.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.PassMetadata.GlobalMetadata">
      <summary>
 Gets pass metadata that is associated with the current compilation unit.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.PassMetadata.TypeMetadata">
      <summary>
 Gets pass metadata that is local to the current type.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.PassMetadata.MethodMetadata">
      <summary>
 Gets pass metadata that is local to the current method.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.StatementPass">
      <summary>
 Defines a statement pass based on a node visitor.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.StatementPass.#ctor(Flame.Compiler.INodeVisitor)">
      <summary>
 Creates a new statement pass instance based on the given node visitor.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.StatementPass.Apply(Flame.Compiler.IStatement)">
      <summary>
 Applies this pass to the given statement.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Visitors.StatementPass.Visitor">
      <summary>
 Gets the statement pass' node visitor.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.StatementVisitorBase">
      <summary>
 Defines a base class for node visitors that care only about statements.
 Expressions are ignored.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.StripAssertPass">
      <summary>
 A pass that removes all assertions, as well as any
 precondition and postcondition checks from a method's body.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.StripAssertPass.Apply(Flame.Compiler.Visitors.BodyPassArgument)">
      <summary>
 Applies this pass to the given value.
 </summary>
    </member>
    <member name="F:Flame.Compiler.Visitors.StripAssertPass.StripAssertPassName">
      <summary>
 Stores the assertion-stripping pass' name.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Visitors.StripAssertVisitor">
      <summary>
 A node visitor that removes all assertions, as well as any
 precondition and postcondition checks.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.VariableCapturingVisitor.SubstituteVariableRecursivelyOrNull(Flame.Compiler.IVariable)">
      <summary>
 Tries to substitute the given variable. If this cannot be done,
 null is returned.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.VariableCapturingVisitor.CanSubstituteVariable(Flame.Compiler.IVariable)">
      <summary>
 Determines whether the given variable can be substituted or not.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.VariableCapturingVisitor.SubstituteVariable(Flame.Compiler.IVariable)">
      <summary>
 Substitutes the given variable.
 </summary>
      <pre>
 CanSubstituteVariable(Variable) == true
 </pre>
    </member>
    <member name="T:Flame.Compiler.Visitors.VariableSubstitutingVisitorBase">
      <summary>
 Defines a base class for node visitors that substitute variable nodes.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.VariableSubstitutingVisitorBase.CanSubstituteVariable(Flame.Compiler.IVariable)">
      <summary>
 Determines whether the given variable can be substituted or not.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.VariableSubstitutingVisitorBase.SubstituteVariable(Flame.Compiler.IVariable)">
      <summary>
 Substitutes the given variable.
 </summary>
      <pre>
 CanSubstituteVariable(Variable) == true
 </pre>
    </member>
    <member name="M:Flame.Compiler.Visitors.VariableSubstitutingVisitorBase.SubstituteVariableRecursivelyOrNull(Flame.Compiler.IVariable)">
      <summary>
 Tries to substitute the given variable. If this cannot be done,
 null is returned.
 </summary>
      <remarks>
        <para>
 Default substitution behavior is as follows: first, the visitor will try to
 chase late-bound variable indirection: if a late-bound variable
 is bound to another variable and said other variable can be substituted,
 the result of that substitution is returned. Otherwise,
 the variable's candidacy for substitution is considered. If
 `CanSubstituteVariable(Variable) == true`, `SubstituteVariable(Variable)`
 is returned.
 </para>
        <para>
 This has the following implications:
 <list><item>
     A late-bound variable that is bound to another variable which
     cannot be substituted, but is itself a candidate for substitution,
     will indeed be substituted.
     </item><item>
     A manually-bound variable that is bound to a variable which can
     be substituted, will be substituted, as manually-bound variables are
     themselves late-bound variables.
     </item></list></para>
      </remarks>
    </member>
    <member name="M:Flame.Compiler.Visitors.VariableSubstitutingVisitor.CanSubstituteVariable(Flame.Compiler.IVariable)">
      <summary>
 Determines whether the given variable can be substituted or not.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.VariableSubstitutingVisitor.SubstituteVariable(Flame.Compiler.IVariable)">
      <summary>
 Substitutes the given variable.
 </summary>
      <pre>
 CanSubstituteVariable(Variable) == true
 </pre>
    </member>
    <member name="M:Flame.Compiler.Visitors.LocalTypeSubstitutingVisitor.CanSubstituteVariable(Flame.Compiler.IVariable)">
      <summary>
 Determines whether the given variable can be substituted or not.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.LocalTypeSubstitutingVisitor.SubstituteVariable(Flame.Compiler.IVariable)">
      <summary>
 Substitutes the given variable.
 </summary>
      <pre>
 CanSubstituteVariable(Variable) == true
 </pre>
    </member>
    <member name="M:Flame.Compiler.Visitors.LocalTypeSubstitutingVisitor.VisitBody(Flame.Compiler.IExpression,Flame.IMethod)">
      <summary>
 Visits the given expression, which logically belongs to the given method.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.LocalTypeSubstitutingVisitor.VisitBody(Flame.Compiler.IStatement,Flame.IMethod)">
      <summary>
 Visits the given statement, which logically belongs to the given method.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.ContinueRewriter.Static_Singleton.RewriteContinue(Flame.Compiler.UniqueTag,Flame.Compiler.IStatement,Flame.Compiler.IStatement)">
      <summary>
 Rewrites the given statement by replacing every `continue` to a given specific block
 by another statement.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Visitors.YieldNodeFindingVisitor.Static_Singleton.UsesYield(Flame.Compiler.IStatement)">
      <summary>
 Finds out whether the given statement uses yield break or yield return.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.FieldPrototypeTemplate">
      <summary>
 Defines a field signature template that is based on a prototype field.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.FieldPrototypeTemplate.#ctor(Flame.IField)">
      <summary>
 Creates a field prototype template from the given prototype.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.FieldPrototypeTemplate.CreateFieldType(Flame.IField)">
      <summary>
 Creates the field signature's field type.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.FieldSignatureInstance">
      <summary>
 An instantiation of a field signature template.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.FieldSignatureInstance.#ctor(Flame.Compiler.Build.IFieldSignatureTemplate,Flame.IField)">
      <summary>
 Instantiates the given field signature template with the given field.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.FieldSignatureInstance.Name">
      <summary>
 Gets the field signature instance's name.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.FieldSignatureInstance.IsStatic">
      <summary>
 Gets a boolean value that tells if this type member template is static.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.FieldSignatureInstance.Template">
      <summary>
 Gets the field signature template this instance is based on.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.FieldSignatureInstance.Field">
      <summary>
 Gets the field the signature template is instantiated with.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.FieldSignatureInstance.Attributes">
      <summary>
 Gets the field signature instance's attributes.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.FieldSignatureInstance.FieldType">
      <summary>
 Gets the field signature instance's field type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IAssemblyBuilder.Save(Flame.Compiler.Build.IOutputProvider)">
      <summary>
 Saves the assembly to the output provider.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.IMethodBuilder">
      <summary>
 Defines common functionality for methods whose body can be set.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IMethodBuilder.GetBodyGenerator">
      <summary>
 Gets the method body's code generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IMethodBuilder.SetMethodBody(Flame.Compiler.ICodeBlock)">
      <summary>
 Sets this method builder's body to the given code block.
 Note that this code block must be generated by this method builder's
 code generator.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.IMethodSignatureTemplate">
      <summary>
 Defines a template for method signatures, which can be instantiated.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IMethodSignatureTemplate.CreateGenericParameters(Flame.IMethod)">
      <summary>
 Creates the method signature's generic parameters.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IMethodSignatureTemplate.CreateBaseMethods(Flame.IMethod)">
      <summary>
 Creates the method signature's base methods.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IMethodSignatureTemplate.CreateReturnType(Flame.IMethod)">
      <summary>
 Creates the method signature's return type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IMethodSignatureTemplate.CreateParameters(Flame.IMethod)">
      <summary>
 Creates the method signature's parameters.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.IMethodSignatureTemplate.IsConstructor">
      <summary>
 Gets a boolean value that tells if this method template is a constructor.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IFieldBuilder.SetValue(Flame.Compiler.IExpression)">
      <summary>
 Sets the field's initial value.
 </summary>
      <param name="Value" />
    </member>
    <member name="T:Flame.Compiler.Build.IFieldSignatureTemplate">
      <summary>
 Defines a template for field signatures, which can be instantiated.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IFieldSignatureTemplate.CreateFieldType(Flame.IField)">
      <summary>
 Creates the field signature's field type.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.IPropertyBuilder">
      <summary>
 Defines a common interface for properties that can declare new accessors.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IPropertyBuilder.DeclareAccessor(Flame.AccessorType,Flame.Compiler.Build.IMethodSignatureTemplate)">
      <summary>
 Declares an accessor based on the given accessor kind and method signature template.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.IPropertySignatureTemplate">
      <summary>
 Defines a template for property signatures, which can be instantiated.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IPropertySignatureTemplate.CreatePropertyType(Flame.IProperty)">
      <summary>
 Creates the property signature's property type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IPropertySignatureTemplate.CreateIndexerParameters(Flame.IProperty)">
      <summary>
 Creates the property signature's indexer parameters.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.INamespaceBuilder">
      <summary>
 A common interface for namespaces that can declare child namespaces
 and types.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.INamespaceBuilder.DeclareNamespace(System.String)">
      <summary>
 Declares a child namespace with the given name.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.INamespaceBuilder.DeclareType(Flame.Compiler.Build.ITypeSignatureTemplate)">
      <summary>
 Declares a type based on the given type signature template.
 </summary>
      <param name="Template" />
      <returns />
    </member>
    <member name="T:Flame.Compiler.Build.IMemberBuilder`1">
      <summary>
 Defines a base interface for member builders.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IMemberBuilder`1.Initialize">
      <summary>
 "Initializes" this instance. This is method is typically
 added after declaring and registering the member builder,
 and gives it the opportunity to perform eager evaluation of
 its signature template.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IMemberBuilder`1.Build">
      <summary>
 "Builds" this member builder. This signifies the end of interaction
 with the member builder interaction, and allows the member builder
 to store all the data it has acquired.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.IMemberSignatureTemplate`1">
      <summary>
 Defines a template for member signatures, which can be instantiated.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IMemberSignatureTemplate`1.CreateAttributes(T)">
      <summary>
 Creates the member signature's attributes.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.IMemberSignatureTemplate`1.Name">
      <summary>
 Gets the member signature's name.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.ITypeMemberSignatureTemplate`1">
      <summary>
 Defines a template for type member signatures, which can be instantiated.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.ITypeMemberSignatureTemplate`1.IsStatic">
      <summary>
 Gets a boolean flag that determines whether this type member is static.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.IOutputProvider">
      <summary>
 Describes a provider of output streams.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IOutputProvider.Create(System.String,System.String)">
      <summary>
 Creates an output file for the specified name.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IOutputProvider.Create">
      <summary>
 Creates the default output file.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IOutputProvider.Exists(System.String,System.String)">
      <summary>
 Gets a boolean value that indicates whether an output stream with the specified name and extension exists.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.IOutputProvider.PreferSingleOutput">
      <summary>
 Gets a boolean value that indicates if the client prefers a single output over many.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.IOutputFile">
      <summary>
 Represents a file that can be opened for writing.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.IOutputFile.OpenOutput">
      <summary>
 Opens an output stream to this file.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.IInvariantTypeBuilder">
      <summary>
 Specifies functionality for type builders that support the creation of invariants.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.IInvariantTypeBuilder.InvariantGenerator">
      <summary>
 Gets the type builder's invariant generator.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.ITypeBuilder.DeclareMethod(Flame.Compiler.Build.IMethodSignatureTemplate)">
      <summary>
 Declares a method that is based on the information provided by the specified method template.
 </summary>
      <param name="Template">
 A method template that will be used to construct a method builder.
 </param>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Build.ITypeBuilder.DeclareField(Flame.Compiler.Build.IFieldSignatureTemplate)">
      <summary>
 Declares a field that is based on the information provided by the specified field template.
 </summary>
      <param name="Template">
 A field template that will be used to construct a field builder.
 </param>
      <returns />
    </member>
    <member name="M:Flame.Compiler.Build.ITypeBuilder.DeclareProperty(Flame.Compiler.Build.IPropertySignatureTemplate)">
      <summary>
 Declares a property that is based on the information provided by the specified property template.
 </summary>
      <param name="Template">
 A property template that will be used to construct a property builder.
 </param>
      <returns />
    </member>
    <member name="T:Flame.Compiler.Build.ITypeSignatureTemplate">
      <summary>
 Defines a template for type signatures, which can be instantiated.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.ITypeSignatureTemplate.CreateGenericParameters(Flame.IType)">
      <summary>
 Creates the type signature's generic parameters.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.ITypeSignatureTemplate.CreateBaseTypes(Flame.IType)">
      <summary>
 Creates the type signature's base types.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.MemberPrototypeTemplate`1">
      <summary>
 A base class for member signature templates that use a prototype member.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.MemberPrototypeTemplate`1.#ctor(T)">
      <summary>
 Creates a member prototype template from the given prototype member.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.MemberPrototypeTemplate`1.CreateAttributes(T)">
      <summary>
 Creates this member prototype's attributes.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.MemberPrototypeTemplate`1.Name">
      <summary>
 Gets this member prototype's name.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.MemberPrototypeTemplate`1.Prototype">
      <summary>
 Gets this member prototype template's prototype member.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.TypeMemberPrototypeTemplate`1">
      <summary>
 A base class for type member signature templates that use a prototype member.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.TypeMemberPrototypeTemplate`1.#ctor(T)">
      <summary>
 Creates a type member prototype from the given prototype member.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.TypeMemberPrototypeTemplate`1.IsStatic">
      <summary>
 Tells if this type member prototype is static.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.MethodPrototypeTemplate">
      <summary>
 Defines a method signature template that is based on a prototype method.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.MethodPrototypeTemplate.#ctor(Flame.IMethod)">
      <summary>
 Creates a method prototype template from the given prototype.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.MethodPrototypeTemplate.CreateGenericParameters(Flame.IMethod)">
      <summary>
 Creates the method signature's generic parameters.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.MethodPrototypeTemplate.CreateBaseMethods(Flame.IMethod)">
      <summary>
 Creates the method signature's base methods.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.MethodPrototypeTemplate.CreateReturnType(Flame.IMethod)">
      <summary>
 Creates the method signature's return type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.MethodPrototypeTemplate.CreateParameters(Flame.IMethod)">
      <summary>
 Creates the method signature's parameters.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.MethodSignatureInstance">
      <summary>
 An instantiation of a method signature template.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.MethodSignatureInstance.#ctor(Flame.Compiler.Build.IMethodSignatureTemplate,Flame.IMethod)">
      <summary>
 Instantiates the given method signature template with the given method.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.MethodSignatureInstance.Name">
      <summary>
 Gets the method signature instance's name.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.MethodSignatureInstance.IsConstructor">
      <summary>
 Gets a boolean value that tells if this method signature instance is a constructor.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.MethodSignatureInstance.Template">
      <summary>
 Gets the method signature template this instance is based on.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.MethodSignatureInstance.Method">
      <summary>
 Gets the method the signature template is instantiated with.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.MethodSignatureInstance.Attributes">
      <summary>
 Gets the method signature instance's attributes.
 These should be evaluated lazily. Specifically, they cannot be
 evaluated during the creation of a new method builder based on this
 template. Doing so anyway will result in undefined behavior.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.MethodSignatureInstance.GenericParameters">
      <summary>
 Gets the method signature instance's generic parameters.
 These should be evaluated lazily. Specifically, they cannot be
 evaluated during the creation of a new method builder based on this
 template. Doing so anyway will result in undefined behavior.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.MethodSignatureInstance.BaseMethods">
      <summary>
 Gets the method signature instance's base methods.
 These should be evaluated lazily. Specifically, they cannot be
 evaluated during the creation of a new method builder based on this
 template. Doing so anyway will result in undefined behavior.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.MethodSignatureInstance.ReturnType">
      <summary>
 Gets the method signature instance's return type.
 These should be evaluated lazily. Specifically, they cannot be
 evaluated during the creation of a new method builder based on this
 template. Doing so anyway will result in undefined behavior.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.MethodSignatureInstance.Parameters">
      <summary>
 Gets the method signature instance's parameters.
 These should be evaluated lazily. Specifically, they cannot be
 evaluated during the creation of a new method builder based on this
 template. Doing so anyway will result in undefined behavior.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.PropertyPrototypeTemplate">
      <summary>
 Defines a property signature template that is based on a prototype property.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.PropertyPrototypeTemplate.#ctor(Flame.IProperty)">
      <summary>
 Creates a property signature template from the given prototype property.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.PropertyPrototypeTemplate.CreatePropertyType(Flame.IProperty)">
      <summary>
 Creates the property signature's property type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.PropertyPrototypeTemplate.CreateIndexerParameters(Flame.IProperty)">
      <summary>
 Creates the property signature's indexer parameters.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.PropertySignatureInstance">
      <summary>
 An instantiation of a property signature template.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.PropertySignatureInstance.#ctor(Flame.Compiler.Build.IPropertySignatureTemplate,Flame.IProperty)">
      <summary>
 Instantiates the given property signature template with the given property.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.PropertySignatureInstance.Name">
      <summary>
 Gets the property signature instance's name.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.PropertySignatureInstance.Template">
      <summary>
 Gets the property signature template this instance is based on.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.PropertySignatureInstance.Property">
      <summary>
 Gets the property the signature template is instantiated with.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.PropertySignatureInstance.Attributes">
      <summary>
 Gets the property signature instance's attributes.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.PropertySignatureInstance.PropertyType">
      <summary>
 Gets the property signature instance's property type.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.PropertySignatureInstance.IndexerParameters">
      <summary>
 Gets the property signature instance's indexer parameters.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.TypePrototypeTemplate">
      <summary>
 Defines a type signature template that is based on a prototype type.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.TypePrototypeTemplate.#ctor(Flame.IType)">
      <summary>
 Creates a type prototype template from the given prototype.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.TypePrototypeTemplate.CreateGenericParameters(Flame.IType)">
      <summary>
 Creates the type signature's generic parameters.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.TypePrototypeTemplate.CreateBaseTypes(Flame.IType)">
      <summary>
 Creates the type signature's base types.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Build.TypeSignatureInstance">
      <summary>
 An instantiation of a type signature template.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Build.TypeSignatureInstance.#ctor(Flame.Compiler.Build.ITypeSignatureTemplate,Flame.IType)">
      <summary>
 Instantiates the given type signature template with the given type.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.TypeSignatureInstance.Name">
      <summary>
 Gets the type signature instance's name.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.TypeSignatureInstance.Template">
      <summary>
 Gets the type signature template this instance is based on.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.TypeSignatureInstance.Type">
      <summary>
 Gets the type the signature template is instantiated with.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.TypeSignatureInstance.Attributes">
      <summary>
 Gets the type signature instance's attributes.
 These should be evaluated lazily. Specifically, they cannot be
 evaluated during the creation of a new type builder based on this
 template. Doing so anyway will result in undefined behavior.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.TypeSignatureInstance.GenericParameters">
      <summary>
 Gets the type signature instance's generic parameters.
 These should be evaluated lazily. Specifically, they cannot be
 evaluated during the creation of a new type builder based on this
 template. Doing so anyway will result in undefined behavior.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Build.TypeSignatureInstance.BaseTypes">
      <summary>
 Gets the type signature instance's base types.
 These should be evaluated lazily. Specifically, they cannot be
 evaluated during the creation of a new type builder based on this
 template. Doing so anyway will result in undefined behavior.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Projects.IProjectSourceItem.GetSource(System.String)">
      <summary>
 Gets the source item's source document.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Projects.IProjectSourceItem.SourceIdentifier">
      <summary>
 The source item's identifier. This is usually the file's path.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Projects.IMutableProjectNode.SetName(System.String)">
      <summary>
 Sets the project node's name.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Projects.IMutableProjectNode.AddChild(Flame.Compiler.Projects.IProjectItem)">
      <summary>
 Adds a child to the project node.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Projects.IMutableProject.SetAssemblyName(System.String)">
      <summary>
 Sets the project's assembly name.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Projects.IMutableProject.SetBuildTargetIdentifier(System.String)">
      <summary>
 Sets the project's build target identifier.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Projects.IMutableProject.CreateSourceItem(System.String,System.String)">
      <summary>
 Creates a source item for the provided source path.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Projects.IMutableProject.CreateReferenceItem(System.String,System.Boolean)">
      <summary>
 Creates a reference item for the provided reference identifier.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Projects.IMutableProject.CreateOptionItem(System.String,System.String)">
      <summary>
 Creates an option item for the given option key and value.
 </summary>
    </member>
    <member name="M:Flame.Compiler.Projects.IMutableProject.CreateNode">
      <summary>
 Creates a new project node.
 </summary>
    </member>
    <member name="T:Flame.Compiler.Projects.IProjectOptionItem">
      <summary>
 Describes a project item that specifies a compiler option.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Projects.IProjectOptionItem.Key">
      <summary>
 Gets the option's key.
 </summary>
    </member>
    <member name="P:Flame.Compiler.Projects.IProjectOptionItem.Value">
      <summary>
 Gets the value associated with the option.
 </summary>
    </member>
    <member name="P:Flame.Compiler.AbortCompilationException.Static_Singleton.DefaultFatalErrorEntry">
      <summary>
 Gets the default log entry for fatal errors.
 </summary>
    </member>
    <member name="M:Flame.Compiler.CodeBuilder.Static_Singleton.GetIndentationString(System.Collections.Generic.IEnumerable`1{System.String})">
      <summary>
 Gets the best match for an indentation that suits the given indented lines.
 An indentation string is defined as a sequence of tab or space characters that precede every line in the given sequence zero or more times.
 </summary>
    </member>
  </members>
</doc>