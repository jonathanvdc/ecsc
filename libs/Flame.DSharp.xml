<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Flame.DSharp</name>
  </assembly>
  <members>
    <member name="T:Flame.DSharp.Box`1">
      <summary>
 Wraps a read-write reference to a value.
 </summary>
    </member>
    <member name="M:Flame.DSharp.Box`1.#ctor">
      <summary>
 Creates a new box containing the default value of `T`.
 </summary>
    </member>
    <member name="M:Flame.DSharp.Box`1.#ctor(T)">
      <summary>
 Creates a new box from the given value of `T`.
 </summary>
    </member>
    <member name="T:Flame.DSharp.Lexer.TokenType">
      <summary>
 Tokens is an enumeration of all possible token values.
 </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.ITokenStream.Next">
      <summary>
 Gets the next token in queue.
 </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.ITokenStream.Peek(Flame.DSharp.Lexer.TokenIdentifier)">
      <summary>
 Returns the token that immediately trails the token with the given position.
 </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.ITokenStream.Seek(Flame.DSharp.Lexer.TokenIdentifier)">
      <summary>
 Sets the current parser position.
 </summary>
      <param name="Position" />
    </member>
    <member name="M:Flame.DSharp.Lexer.ITokenStream.Reset">
      <summary>
 Resets the token stream.
 </summary>
    </member>
    <member name="P:Flame.DSharp.Lexer.ITokenStream.CurrentPosition">
      <summary>
 Gets the token stream's current position.
 </summary>
    </member>
    <member name="T:Flame.DSharp.Lexer.PeekToken">
      <summary>
 A PeekToken object type
 </summary>
      <remarks>
 A PeekToken is a special pointer object that can be used to Peek() several
 tokens ahead in the GetToken() queue.
 </remarks>
    </member>
    <member name="T:Flame.DSharp.Lexer.Token">
      <summary>
 A Token object type
 </summary>
      <remarks>
 A Token object holds the token and token value.
 </remarks>
    </member>
    <member name="M:Flame.DSharp.Lexer.MemoryTokenStream.Next">
      <summary>
 Gets the next token in queue.
 </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.MemoryTokenStream.Reset">
      <summary>
 Resets the token stream.
 </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.MemoryTokenStream.Peek(Flame.DSharp.Lexer.TokenIdentifier)">
      <summary>
 Returns the token that immediately trails the token with the given position.
 </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.MemoryTokenStream.Seek(Flame.DSharp.Lexer.TokenIdentifier)">
      <summary>
 Sets the current parser position.
 </summary>
      <param name="Position" />
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenExtensions.IsPrefixTypeToken(Flame.DSharp.Lexer.TokenType)">
      <summary>
 Gets a boolean value that indicates if this type token is followed by another type token.
 </summary>
      <param name="Type" />
      <returns />
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenExtensions.IsTypeToken(Flame.DSharp.Lexer.TokenType)">
      <summary>
 Gets a boolean value that indicates if this token could be used to construct a type.
 </summary>
      <param name="Type" />
      <returns />
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenExtensions.IsSuffixTypeToken(Flame.DSharp.Lexer.TokenType)">
      <summary>
 Gets a boolean value that indicates if this type token can trail another type token.
 </summary>
      <param name="Type" />
      <returns />
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenExtensions.IsPrefixOrSuffixTypeToken(Flame.DSharp.Lexer.TokenType)">
      <summary>
 Gets a boolean value that indicates if this type token can trail another type token.
 </summary>
      <param name="Type" />
      <returns />
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenExtensions.Peek(Flame.DSharp.Lexer.ITokenStream)">
      <summary>
 Returns the next token, without altering the token stream's state.
 </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenExtensions.Peek(Flame.DSharp.Lexer.ITokenStream,Flame.DSharp.Lexer.PeekToken)">
      <summary>
 Returns the next token after the provided token.
 </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenExtensions.NextBlockContents(Flame.DSharp.Lexer.ITokenStream,Flame.DSharp.Lexer.TokenType,Flame.DSharp.Lexer.TokenType)">
      <summary>
 Reads the contents of a "block", delimited by a start and an end token. The end token will also be parsed by this method, but will not be added to the results.
 </summary>
      <param name="End" />
      <returns />
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenizerStream.Next">
      <summary>
 Gets the next token in queue.
 </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenizerStream.Seek(Flame.DSharp.Lexer.TokenIdentifier)">
      <summary>
 Sets the current parser position.
 </summary>
      <param name="Position" />
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenizerStream.Peek(Flame.DSharp.Lexer.TokenIdentifier)">
      <summary>
 Returns the token that immediately trails the token with the given position.
 </summary>
    </member>
    <member name="M:Flame.DSharp.Lexer.TokenizerStream.Reset">
      <summary>
 Resets the token stream.
 </summary>
    </member>
    <member name="T:Flame.DSharp.Lexer.TokenExample">
      <summary>
 Defines a token example.
 </summary>
    </member>
    <member name="P:Flame.DSharp.Lexer.TokenExample.IsExample">
      <summary>
 Gets a boolean flag that identifies whether the given example is a real-world example of the associated token type.
 </summary>
    </member>
    <member name="P:Flame.DSharp.Lexer.TokenExample.IsDescription">
      <summary>
 Gets a boolean flag that identifies whether the given example is really a description of the associated token type.
 </summary>
    </member>
    <member name="P:Flame.DSharp.Lexer.TokenExample.Value">
      <summary>
 Gets the token example's example string.
 </summary>
    </member>
    <member name="T:Flame.DSharp.Lexer.TokenExamples">
      <summary>
 A static class that maintains a collection of token examples for loggin purposes.
 </summary>
    </member>
    <member name="T:Flame.DSharp.Parser.DSharpSyntaxParser">
      <summary>
 The D# syntax parser.
 </summary>
      <remarks>
 This is where the magic happens.
 </remarks>
    </member>
    <member name="M:Flame.DSharp.Parser.DSharpSyntaxParser.ParseAmbiguousAttributes(Flame.DSharp.Lexer.ITokenStream)">
      <summary>
 Parses a list of attributes that may or may not be trailed by an enumerator, which uses the same syntax.
 </summary>
    </member>
    <member name="P:Flame.DSharp.Build.SyntaxTypeBase.AssociatedTypes">
      <summary>
 Gets all associated types for this type.
 </summary>
    </member>
    <member name="M:Flame.DSharp.Build.SyntaxAssembly.AddCompilationUnit(Flame.Syntax.ICompilationUnit,Flame.Compiler.ICompilerLog)">
      <summary>
 Adds a compilation unit to the assembly.
 </summary>
    </member>
    <member name="M:Flame.DSharp.Build.SyntaxAssembly.CreateBinder">
      <summary>
 Creates a binder for this assembly.
 </summary>
      <returns />
    </member>
    <member name="M:Flame.DSharp.Build.SyntaxAssembly.GetEntryPoint">
      <summary>
 Gets the entry point method for this assembly.
 </summary>
      <returns />
    </member>
    <member name="P:Flame.DSharp.Build.SyntaxAssembly.RootNamespace">
      <summary>
 Gets the nameless root namespace of the assembly.
 </summary>
    </member>
    <member name="P:Flame.DSharp.Build.SyntaxAssembly.AllTypes">
      <summary>
 Gets all types in the assembly.
 </summary>
    </member>
    <member name="P:Flame.DSharp.Build.SyntaxAssembly.AssemblyVersion">
      <summary>
 Gets the assembly's version.
 </summary>
    </member>
    <member name="P:Flame.DSharp.Build.SyntaxAssembly.MainNamespace">
      <summary>
 Gets the nameless root namespace of the assembly.
 </summary>
    </member>
    <member name="T:Flame.Syntax.DSharp.BaseConstructorCallSyntax">
      <summary>
 Represents a call to one of the parent type's constructors.
 </summary>
      <remarks>
 Syntax: 'base(arg1, arg2, ...)'.
 </remarks>
    </member>
    <member name="M:Flame.Syntax.DSharp.BaseConstructorCallSyntax.#ctor(Flame.DSharp.Lexer.Token,Flame.Syntax.DSharp.DelimitedList`1{Flame.Syntax.IExpressionSyntax})">
      <summary>
 Creates a new base constructor call syntax node.
 </summary>
    </member>
    <member name="P:Flame.Syntax.DSharp.BaseConstructorCallSyntax.BaseKeyword">
      <summary>
 Gets the base keyword token.
 </summary>
    </member>
    <member name="P:Flame.Syntax.DSharp.BaseConstructorCallSyntax.ArgumentList">
      <summary>
 Gets the base constructor call's argument list.
 </summary>
    </member>
    <member name="T:Flame.Syntax.DSharp.FieldProperty">
      <summary>
 Describes a property backed by a field.
 </summary>
    </member>
  </members>
</doc>