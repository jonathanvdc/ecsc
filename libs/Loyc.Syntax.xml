<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Loyc.Syntax</name>
    </assembly>
    <members>
        <member name="T:Loyc.Syntax.Les.LesIndentTokenGenerator">
            <summary>Indent postprocessor for Loyc Expression Syntax</summary>
            <remarks>
            LES's "Python mode" is comparable to Python's rules, but I want LES with 
            Python mode to be able to parse <i>most</i> of the code that was designed 
            for LES without Python mode. For example, in LES (without indentation 
            processing) you could write a statement like
            <code>
            if foo "foo "
                + "detected " +
                "here";
            </code>
            And I'd like this code to still parse OK when <c>IndentTokenGenerator</c> 
            is inserted into the pipeline. Therefore, <see cref="T:Loyc.Syntax.Les.LesIndentTokenGenerator"/>
            will allow unexpected indentation and treat it as a way of continuing 
            the previous statement.
            <para/>
            Code like
            <code>
              if condition:
                 then();
              if condition:
                 then();
              :else:
                 otherwise();
              foo
              : bar;
            </code>
            is translated to this (where [ and ] represent Indent and Dedent):
            <code>
              if condition: [
                 then(); };
              ] ;
              if condition: [
                 then();
              ] else [
                 otherwise(); 
              ] ;
              foo bar;
            </code>
            Notice that dedents are normally followed by semicolons, and that colons 
            are suppressed if they appear at the beginning of a line AND block the 
            generation of a semicolon. A colon is not suppressed if it does not have
            this effect; forexample
            <code>
            :
                hi();
                : Foo;
            </code>
            means
            <code>
            {
                hi();
                `:` Foo;
            };
            </code>
            <para/>
            Note: originally I allowed code such as
            <code>
            if foo: if bar: print(foo + bar);
                print(foo only);
            </code>
            as equivalent to
            <code>
            if foo { if bar { print(foo + bar);
                print(foo only); }; };
            </code>
            But I decided it would be better to treat code such as
            <code>
            x = a:b;
            </code>
            as a simple statement instead. This means, however, that
            <code>
            if Foo: x = 5;
            </code>
            does not have the meaning you would expect! You must use braces for this:
            <code>
            if Foo { x = 5; };
            </code>
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.IndentTokenGenerator`1">
            <summary>
            A preprocessor usually inserted between the lexer and parser that inserts
            "indent", "dedent", and "end-of-line" tokens at appropriate places in a
            token stream.
            </summary>
            <remarks>This class will not work correctly if the lexer does not implement 
            <see cref="P:Loyc.Syntax.Lexing.ILexer`1.IndentLevel"/> properly.
            <para/>
            This class is abstract because it doesn't know how to classify or create 
            tokens. The derived class must implement <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.GetTokenCategory(`0)"/>,
            <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeEndOfLineToken(`0,Loyc.Maybe{`0}@,System.Nullable{System.Int32})"/>, <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeIndentToken(`0,Loyc.Maybe{`0}@,System.Boolean)"/> and 
            <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeDedentToken(`0,Loyc.Maybe{`0}@)"/>. <see cref="T:Loyc.Syntax.Lexing.IndentTokenGenerator"/> is a 
            non-abstract version of this class based on <see cref="T:Loyc.Syntax.Lexing.Token"/> 
            structures, with several properties that can be customized.
            <para/>
            Creation of indent, dedent, and end-of-line tokens can be suppressed inside 
            brackets, i.e. () [] {}. This is accomplished by recognizing brackets inside
            your implementation of <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.GetTokenCategory(`0)"/>.
            <para/>
            <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/> can be placed in the pipeline before or after 
            this class; if it is placed afterward, anything between Indent and Dedent
            tokens will be made a child of the Indent token.
            <para/>
            Note: whitespace tokens (<see cref="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.Whitespace"/>) are passed 
            through and otherwise unprocessed.
            <para/>
            Note: EOL tokens are not generated for empty or comment lines, and are not 
            generated after a generated indent token, although they could be generated 
            after a pre-existing indent token that was already in the token stream, 
            unless that token is categorized as <see cref="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.OpenBracket"/>.
            <para/>
            Partial dedents and unexpected indents, as in
            <code>
              if Condition:
                  print("Hello")
                print("Hello again")
              else:
                  print("Goodbye")
                    print("Goodbye again")
            </code>
            will cause an error message to be written to the <see cref="P:Loyc.Syntax.Lexing.ILexer`1.ErrorSink"/> 
            of the original lexer.
            <para/>
            Please see <see cref="T:Loyc.Syntax.Lexing.IndentTokenGenerator"/> for additional remarks and examples.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerWrapper`1">
            <summary>A base class for wrappers that modify lexer behavior.
            Implements the ILexer interface, except for the NextToken() method.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ILexer`1">
            <summary>A standard interface for lexers.</summary>
            <typeparam name="Token">Type of tokens produced by the lexer (usually
            <see cref="T:Loyc.Syntax.Lexing.Token"/>).</typeparam>
        </member>
        <member name="T:Loyc.Syntax.IIndexToLine">
            <summary>Contains <see cref="M:Loyc.Syntax.IIndexToLine.IndexToLine(System.Int32)"/> method.</summary>
            <seealso cref="T:Loyc.Syntax.IIndexPositionMapper"/>
        </member>
        <member name="M:Loyc.Syntax.IIndexToLine.IndexToLine(System.Int32)">
            <summary>Returns the position in a source file of the specified index.</summary>
            <remarks>If index is negative, this should return a SourcePos where 
            Line and PosInLine are zero (signifying an unknown location). If index 
            is beyond the end of the file, this should retun the final position in 
            the file.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.ILexer`1.NextToken">
            <summary>Scans the next token and returns information about it.</summary>
            <returns>The next token, or null at the end of the source file.</returns>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.SourceFile">
            <summary>The file being lexed.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.ErrorSink">
            <summary>Event handler for errors.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.IndentLevel">
            <summary>Indentation level of the current line. This is updated after 
            scanning the first whitespaces on a new line, and may be reset to zero 
            when <see cref="M:Loyc.Syntax.Lexing.ILexer`1.NextToken"/> returns a newline.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.IndentString">
            <summary>Gets a string slice that holds the spaces or tabs that were 
            used to indent the current line.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.LineNumber">
            <summary>Current line number (1 for the first line).</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ILexer`1.InputPosition">
            <summary>Current input position (an index into SourceFile.Text).</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerWrapper`1.NextToken">
            <summary>Returns the next (postprocessed) token. This method should set
            the <c>_current</c> field to the returned value.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.#ctor(Loyc.Syntax.Lexing.ILexer{`0})">
            <summary>Initializes the indent detector.</summary>
            <param name="lexer">Original lexer (either a raw lexer or an instance of another preprocessor such as <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>.)</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.GetTokenCategory(`0)">
            <summary>Gets the category of a token for the purposes of indent processing.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeIndentToken(`0,Loyc.Maybe{`0}@,System.Boolean)">
            <summary>Returns a token to represent indentation, or null to suppress 
            generating an indent-dedent pair at this point.</summary>
            <param name="indentTrigger">The token that triggered this function call.</param>
            <param name="tokenAfterward">The token after the indent trigger, or NoValue at EOF.</param>
            <param name="newlineAfter">true if the next non-whitespace token after 
            <c>indentTrigger</c> is on a different line, or if EOF comes afterward.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeDedentToken(`0,Loyc.Maybe{`0}@)">
            <summary>Returns token(s) to represent un-indentation.</summary>
            <param name="tokenBeforeNewline">The last non-whitespace token before dedent</param>
            <param name="tokenAfterNewline">The first non-whitespace un-indented 
            token after the unindent, or NoValue at the end of the file. The 
            derived class is allowed to change this token, or delete it by 
            changing it to NoValue (<see cref="T:Loyc.Syntax.Les.LesIndentTokenGenerator"/> does this).</param>
            <remarks>This class considers the indented block to be "over" even if 
            this method returns no tokens.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeEndOfLineToken(`0,Loyc.Maybe{`0}@,System.Nullable{System.Int32})">
            <summary>Returns a token to represent the end of a line, or null to
            avoid generating such a token.</summary>
            <param name="tokenBeforeNewline">Final non-whitespace token before the newline was encountered.</param>
            <param name="tokenAfterNewline">First non-whitespace token after newline.</param>
            <param name="deltaIndent">Change of indentation after the newline, or 
            null if a dedent token is about to be inserted after the newline.</param>
            <remarks>This function is also called at end-of-file, unless there are 
            no tokens in the file.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.IndentChangedUnexpectedly(`0,Loyc.Maybe{`0}@,System.Int32@)">
            <summary>A method that is called when the indent level changed without
            a corresponding indent trigger.</summary>
            <param name="tokenBeforeNewline">Final non-whitespace token before the newline.</param>
            <param name="tokenAfterNewline">First non-whitespace token after the newline.
            Though it's a <see cref="T:Loyc.Maybe`1"/>, it always has a value, but this 
            function can suppress its emission by setting it to NoValue.Value.</param>
            <param name="deltaIndent">Amount of unexpected indentation (positive or 
            negative). On return, this parameter holds the amount by which to change
            the <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator`1.CurrentIndent"/>; the default implementation leaves this
            value unchanged, which means that subsequent lines will be expected to 
            be indented by the same (unexpected) amount.</param>
            <returns>true if <see cref="M:Loyc.Syntax.Lexing.IndentTokenGenerator`1.MakeEndOfLineToken(`0,Loyc.Maybe{`0}@,System.Nullable{System.Int32})"/> should be called as 
            usual, or false to suppress EOL genertion. EOL can only be suppressed
            in case of an unexpected indent (<c>deltaIndent&gt;0</c>), not an unindent.</returns>
            <remarks>The default implementation always returns true. It normally 
            writes an error message, but switches to a warning in case 
            <c>OuterIndents[OuterIndents.Count-1] == OuterIndents[OuterIndents.Count-2]</c>, 
            which this class interprets as a single unindent.
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.OpenBracket">
            <summary>An open bracket, inside of which indent triggers should be ignored.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.CloseBracket">
            <summary>A close bracket, whch reverses the effect of an open bracket.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.IndentTrigger">
            <summary>This token may trigger an indentation token, with an unindent
            token to be generated later, when a line is encountered that is not 
            indented in comparison to this line.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.Whitespace">
            <summary>A whitespace token, which should be passed though and 
            otherwise ignored.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator`1.TokenCategory.Other">
            <summary>None of the other categories apply to this token.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.BaseILexer`2">
            <summary>A version of <see cref="T:Loyc.Syntax.Lexing.BaseLexer`1"/> that implements 
            <see cref="T:Loyc.Syntax.Lexing.ILexer`1"/>. You should use this base class if you want to 
            wrap your lexer in a postprocessor such as <see cref="T:Loyc.Syntax.Lexing.IndentTokenGenerator"/> 
            or <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>.
            </summary>
            <remarks>
            Important: the derived class must call <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/> after
            encountering a newline (CR/LF/CRLF), in order to keep the properties 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/>,
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/> up-to-date.
            See <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.NextToken"/>.
            <para/>
            Alternately, your lexer can borrow the newline parser built into the base
            class, which is called <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Newline"/> and will call 
            <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/> for you. It is possible to have LLLPG treat 
            this method as a rule, and tell LLLPG the meaning of the rule like this:
            <code>
              extern token Newline @[ '\r' '\n'? | '\n' ];
              // BaseLexer also defines a Spaces() method, which behaves like this:
              extern token Spaces  @[ (' '|'\t')* ]; 
            </code>
            The <c>extern</c> modifier tells LLLPG not to generate code for the
            rule, but the rule must still have a body so that LLLPG can perform 
            prediction.
            </remarks>
            <typeparam name="CharSrc">A class that implements <see cref="T:Loyc.Collections.ICharSource"/>.
            In order to write lexers that can accept any source of characters, set 
            CharSrc=ICharSource. For maximum performance when parsing strings (or
            to avoid memory allocation), set CharSrc=UString (<see cref="T:Loyc.UString"/> 
            is a wrapper around <c>System.String</c> that, among other things, 
            implements <c>ICharSource</c>; please note that C# will implicitly convert 
            normal strings to <see cref="T:Loyc.UString"/> for you).</typeparam>
            <typeparam name="Token">The type of token that your lexer will produce,
            e.g. <see cref="T:Loyc.Syntax.Lexing.Token"/>.</typeparam>
        </member>
        <member name="T:Loyc.Syntax.Lexing.BaseLexer`1">
            <summary>The recommended base class for lexers generated by LLLPG,
            when not using the <c>inputSource</c> option.</summary>
            <remarks>
            If you are using the <c>inputSource</c> and <c>inputClass</c> options of,
            LLLPG, use <see cref="T:Loyc.Syntax.Lexing.LexerSource`1"/> instead. If you want to
            write a lexer that implements <see cref="T:Loyc.Syntax.Lexing.ILexer`1"/> (so it is compatible
            with postprocessors like <see cref="T:Loyc.Syntax.Lexing.IndentTokenGenerator"/> and 
            <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>), use <see cref="T:Loyc.Syntax.Lexing.BaseILexer`2"/> as 
            your base class instead.
            <para/>
            This class contains many methods required by LLLPG, such as 
            <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.NewSet(System.Int32[])"/>, <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.LA(System.Int32)"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LA0"/>, 
            <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Skip"/>, <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Match(System.Collections.Generic.HashSet{System.Int32})"/>(...), and <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.TryMatch(System.Collections.Generic.HashSet{System.Int32})"/>(...), along with a few properties that are not 
            used by LLLPG that you still might want to have around, such as 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.FileName"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.CharSource"/> and 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/>.
            <para/>
            It also implements the caching behavior for which <see cref="T:Loyc.Collections.ICharSource"/>
            was created. See the documentation of <see cref="T:Loyc.Collections.ICharSource"/> for more
            information.
            <para/>
            All lexers derived from BaseLexer should call <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.AfterNewline"/>
            at the end of their newline rule, in order to increment the current line
            number. Alternately, your lexer can borrow the newline parser built into 
            BaseLexer, which is called <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Newline"/> and calls 
            <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.AfterNewline"/> for you. It is possible to have LLLPG treat 
            this method as a rule, and tell LLLPG the meaning of the rule like this:
            <code>
              extern token Newline @[ '\r' '\n'? | '\n' ];
              // BaseLexer also defines a Spaces() method, which behaves like this:
              extern token Spaces  @[ (' '|'\t')* ]; 
            </code>
            The <c>extern</c> modifier tells LLLPG not to generate code for the
            rule, but the rule must still have a body so that LLLPG can perform 
            prediction.
            <para/>
            By default, errors are handled by throwing <see cref="T:System.FormatException"/>.
            The recommended way to alter this behavior is to change the 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.ErrorSink"/> property. For example, set it to 
            <see cref="F:Loyc.MessageSink.Console"/> to send errors to the console, or
            use <see cref="M:Loyc.MessageSink.FromDelegate(Loyc.WriteMessageFn,System.Func{Loyc.Severity,System.Boolean})"/> to provide a custom handler.
            </remarks>
            <typeparam name="CharSrc">A class that implements <see cref="T:Loyc.Collections.ICharSource"/>.
            In order to write lexers that can accept any source of characters, set 
            CharSrc=ICharSource. For maximum performance when parsing strings (or
            to avoid memory allocation), set CharSrc=UString (<see cref="T:Loyc.UString"/> 
            is a wrapper around <c>System.String</c> that, among other things, 
            implements <c>ICharSource</c>; please note that C# will implicitly convert 
            normal strings to <see cref="T:Loyc.UString"/> for you).</typeparam>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>Initializes BaseLexer.</summary>
            <param name="chars">A source of characters, e.g. <see cref="T:Loyc.UString"/>.</param>
            <param name="fileName">A file name associated with the characters, 
            which will be used for error reporting.</param>
            <param name="inputPosition">A location to start lexing (normally 0).
            Careful: If you're starting to lex in the middle of the file, the 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> still starts at 1, and (if <c>newSourceFile</c>
            is true) the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> object may or may not discover 
            line breaks prior to the starting point, depending on how it is used.</param>
            <param name="newSourceFile">Whether to create a <see cref="T:Loyc.Syntax.Lexing.LexerSourceFile`1"/>
            object (an implementation of <see cref="T:Loyc.Syntax.ISourceFile"/>) to keep track 
            of line boundaries. The <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> property will point
            to this object, and it will be null if this parameter is false. Using 
            'false' will avoid memory allocation, but prevent you from mapping 
            character positions to line numbers and vice versa. However, this
            object will still keep track of the current <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> 
            and <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/> (the index where the current line started) 
            when this parameter is false.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Reset(`0,System.String,System.Int32,System.Boolean)">
            <summary>Reinitializes the object. This method is called by the constructor.</summary>
            <remarks>
            See the constructor for documentation of the parameters.
            <para/>
            This method can be used to avoid memory allocations when you
            need to parse many small strings in a row. If that's your goal, you 
            should set the <c>newSourceFile</c> parameter to false if possible.</remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.BaseLexer`1.FormatExceptionErrorSink">
            <summary>Throws FormatException when it receives an error. Non-errors
            are sent to <see cref="P:Loyc.MessageSink.Current"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Skip">
            <summary>Increments InputPosition. Called by LLLPG when prediction 
            already verified the input (and caller doesn't save LA(0))</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.AfterNewline">
            <summary>The lexer must call this method exactly once after it advances 
            past each newline, even inside comments and strings. This method keeps
            the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> and <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/> properties
            updated.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Newline">
            <summary>Default newline parser that matches '\n' or '\r' unconditionally.</summary>
            <remarks>
            You can use this implementation in an LLLPG lexer with "extern", like so:
            <c>extern rule Newline @[ '\r' + '\n'? | '\n' ];</c>
            By using this implementation everywhere in the grammar in which a 
            newline is allowed (even inside comments and strings), you can ensure
            that <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.AfterNewline"/> is called, so that the line number
            is updated properly.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Spaces">
            <summary>Skips past any spaces at the current position. Equivalent to
            <c>rule Spaces @[ (' '|'\t')* ]</c> in LLLPG.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Error(System.Int32,System.String)">
            <summary>This method is called to handle errors that occur during lexing.</summary>
            <param name="lookaheadIndex">Index where the error occurred, relative to
            the current InputPosition (i.e. InputPosition + lookaheadIndex is the
            position of the error).</param>
            <param name="message">An error message, not including the error location.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.Error(System.Int32,System.String,System.Object[])">
            <summary>This method is called to format and handle errors that occur 
            during lexing. The default implementation sends errors to <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.ErrorSink"/>, 
            which, by default, throws a <see cref="T:System.FormatException"/>.</summary>
            <param name="lookaheadIndex">Index where the error occurred, relative to
            the current InputPosition (i.e. InputPosition + lookaheadIndex is the
            position of the error).</param>
            <param name="format">An error description with argument placeholders.</param>
            <param name="args">Arguments to insert into the error message.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.RangesToString(System.Collections.Generic.IList{System.Int32})">
            <summary>Converts a list of character ranges to a string, e.g. for input
            list {'*','*','a','z'}, the output is "'*' 'a'..'z'".</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseLexer`1.PrintChar(System.Int32,System.Text.StringBuilder)">
            <summary>Prints a character as a string, e.g. <c>'a' -> "'a'"</c>, with 
            the special value -1 representing EOF, so PrintChar(-1, ...) == "EOF".</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseLexer`1.ErrorSink">
            <summary>Gets or sets the object to which error messages are sent. The
            default object is <see cref="F:Loyc.Syntax.Lexing.BaseLexer`1.FormatExceptionErrorSink"/>, which throws
            <see cref="T:System.FormatException"/> if an error occurs.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber">
            <summary>Current line number. Starts at 1 for the first line, unless derived class changes it.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt">
            <summary>Index at which the current line started.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.BaseLexer`1.SavePosition">
            <summary>A helper class used by LLLPG for backtracking.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.BaseILexer`2._current">
            <summary>The token that will be returned from the Current property.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.Reset(`0,System.String,System.Int32,System.Boolean)">
            <summary>Reinitializes the object. This method is called by the constructor.</summary>
            <remarks>Compared to the base class version of this function, this 
            method also skips over the UTF BOM '\uFEFF', if present, and it measures
            the indentation of the first line (without skipping over it).
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.NextToken">
            <summary>Scans the next token in the character stream and returns the
            token, or null when the end of the text is reached.</summary>
            <remarks>
            The derived class must call <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/> after it
            advances past each newline (CR/LF/CRLF), in order to keep the 
            properties <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/>,
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/> up-to-date.
            This must be done even when the newline is encountered inside a comment
            or multi-line string. Note that the <see cref="M:Loyc.Syntax.Lexing.BaseLexer`1.Newline"/> rule 
            in the base class will call <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/> for you.
            <para/>
            Also, while returning, the derived class should set the <c>_current</c> 
            field to its own return value so that the <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.Current"/> property
            works reliably.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.SupportDotIndents">
            <summary>The LES and EC# languages support "dot indents", which are 
            lines that start with a dot (.) followed by a tab or spaces. If you
            overload this method to return true, then <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/>
            and <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.Reset(`0,System.String,System.Int32,System.Boolean)"/> will count dot indents as part of the 
            indentation at the beginning of each line; otherwise, only spaces and
            tabs will be counted.</summary>
            <remarks>
            A dot indent has the syntax <c>('.' ('\t' | ' '+))*</c>. This 
            indentation style is recognized only if a dot is the first character 
            on a line. Each pair of dot+(tab/spaces) prior to the first non-space 
            token is counted the same way as a tab character (\t). Dot indents are 
            useful for posting source code on "bad" blog software or forums that 
            do not preseve indentation. Since LES is a partially indent-sensitive 
            language, preserving indentation may be important, and dot indents 
            increase the likelihood of preserving indents correctly.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline">
            <summary>The lexer must call this method exactly once after it advances 
            past each newline, even inside comments and strings. This method keeps
            the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/>, <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineStartAt"/>,
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/> properties
            updated.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline(System.Boolean,System.Boolean)">
            <inheritdoc cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/>
            <param name="ignoreIndent">Causes this method not to measure the indent
            at the beginning of this line, and leave the <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/>
            and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> unchanged. You may wish to set this flag 
            when a newline is encountered inside a multiline comment.</param>
            <param name="skipIndent">This method normally scans indentation after 
            the newline character, in order to update the <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> 
            and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/> properties. If this parameter is true,
            the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.InputPosition"/> will also be increased, skipping past
            those initial spaces. If <c>supportDotIndent</c> is also true, the
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.InputPosition"/> will also skip past the dot indent, if any.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.BaseILexer`2.ScanIndent(System.Boolean)">
            <summary>Scans indentation at the beginning of a line and updates the
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/> and <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString"/> properties.
            This function is called automatically by <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline"/>,
            but should be called manually on the very first line of the file.</summary>
            <remarks>Parameters are documented at <see cref="M:Loyc.Syntax.Lexing.BaseILexer`2.AfterNewline(System.Boolean,System.Boolean)"/></remarks>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseILexer`2.SpacesPerTab">
            <summary>Number of spaces per tab, for the purpose of computing 
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel"/>. Initial value: 4</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentString">
            <summary>Gets a string slice that holds the spaces or tabs that were 
            used to indent the current line.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.BaseILexer`2.IndentLevel">
            <summary>Gets the number of spaces that were used to indent the current
            line, where a tab counts as rounding up to the next multiple of 
            <see cref="P:Loyc.Syntax.Lexing.BaseILexer`2.SpacesPerTab"/> spaces.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.IndentTokenGenerator">
            <summary>
            A preprocessor usually inserted between the lexer and parser that inserts
            "indent", "dedent", and "end-of-line" tokens at appropriate places in a
            token stream.
            </summary>
            <remarks>
            Suppose you use an <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.IndentToken"/> and <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.DedentToken"/> 
            that are equal to the token types you've chosen for <c>{ braces }</c> (e.g.  
            (<see cref="F:Loyc.Syntax.Lexing.TokenKind.LBrace"/> and <see cref="F:Loyc.Syntax.Lexing.TokenKind.RBrace"/>), the 
            only indent trigger is a colon (:), and you set <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.EolToken"/> to 
            the token type you're using for semicolons. Then the token stream from 
            input such as
            <code>
            def Sqrt(value):
            	if value == 0: return 0
            	g = 0; bshft = Log2Floor(value) &gt;&gt; 1;
            	b = 1 &lt;&lt; bshft
            	do:
            		temp = (g + g + b) &lt;&lt; bshft
            		if value &gt;= temp: g += b
            			value -= temp
            		b &gt;&gt;= 1
            	while (bshft-- &gt; 0)
            	return g
            </code>
            will be converted to a token stream equivalent to
            <code>
            def Sqrt(value): {
            	if value == 0: { return 0;
            	} g = 0; bshft = Log2Floor(value) &gt;&gt; 1;
            	b = 1 &lt;&lt; bshft;
            	do: {
            		temp = (g + g + b) &lt;&lt; bshft
            		if value &gt;= temp: { g += b;
            			value -= temp;
            		} b &gt;&gt;= 1;
            	} while (bshft-- &gt; 0);
            	return g;
            }</code>
            That is, a semicolon is added to lines that don't already have one, open 
            braces are inserted right after colons, and semicolons are <i>not</i> added 
            right after opening braces.
            <para/>
            If multiple indents occur on a single line, as in
            <code>
            if x: if y:
                Foo(x, y)
            </code>
            The output will be like this:
            <code>
            if x: { if y: {
                Foo(x, y);
            }}
            </code>
            
            <h3>Configuration for Python</h3>
            
            Newlines generally represent the end of a statement, while colons mark 
            places where a "child" block is expected. Inside parenthesis, square 
            brackets, or braces, newlines are ignored:
            <code>
            	s = ("this is a pretty long string that I'd like "
            	  + " to continue writing on the next line")
            </code>
            And, inside brackets, indentation is ignored, so this is allowed:
            <code>
            if foo:
            	s = ("this is a pretty long string that I'd like "
            + " to continue writing on the next line")
            	print(s)
            </code>
            Note that if you don't use brackets, Python 3 doesn't try to figure out if 
            you "really" meant to continue a statement on the next line:
            <code>
            	# SyntaxError after '+': invalid syntax
            	s = "this is a pretty long string that I'd like " + 
            		" to continue writing on the next line"
            </code>
            Thus OpenBrackets and CloseBrackets should be <c>( [ {</c> and <c>) ] }</c>, 
            respectively. IndentType and DedentType should be synthetic Indent and 
            Dedent tokens, since curly braces have a different meaning (they define a 
            dictionary).
            <para/>
            In Python, it appears you can't write two "block" statements on one line, 
            as in this example:
            <code>
              if True: if True: print() # SyntaxError: invalid syntax
            </code>
            You're also not allowed to indent the next line if the block statement on
            the current line is followed by another statement:
            <code>
              if True: print('a')
                  print('b') # IndentationError: unexpected indent
            </code>
            But you can switch style in different branches:
            <code>
              if True:
                  print("t")
              else: print("f")
              try: print("t")
              except: 
                  print("e")
            </code>
            Also, although you can normally separate statements with semicolons:
            <code>
              print("hell", end=""); print("o")
            </code>
            You are not allowed to write this:
            <code>
              print("?"); if True: # SyntaxError: invalid syntax
                 print("t")
            </code>
            Considering these three facts, I would say that the colon should be 
            classified as an EOL indent trigger (EolIndentTriggers), and the parser 
            should 
            1. recognize non-block statements separately from block statements,
            2. expect a colon to be followed by either an indented block of a non-block 
               statement, but
            3. recognize a non-block "statement" as a <i>list</i> of statements 
               separated by semicolons, with an optional semicolon at the end.
            <para/>
            Now, Python doesn't allow a block statement without a <c>pass</c>, e.g.:
            <code>
              if cond: # "do nothing"
              return   # IndentationError: expected an indented block
            </code>
            I'm inclined to treat this as a special case to be detected in the parser.
            And although you can write a semicolon on a line by itself, you can't 
            write any of these lines:
            <code>
              if cond: ;         # SyntaxError: invalid syntax
              print(); ; print() # SyntaxError: invalid syntax
              ; ;                # SyntaxError: invalid syntax
            </code>
            My interpretation is that a semicolon <i>by itself</i> is treated as a block 
            statement (i.e. illegal in a non-block statement context). Since a semicolon
            is not treated the same way as a newline, the <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.EolToken"/> should 
            be a special token, not a semicolon.
            
            <h3>Configuration for LES</h3>
            
            For more information about LES's indent processing, see
            <see cref="T:Loyc.Syntax.Les.LesIndentTokenGenerator"/> .
            </remarks>
            <seealso cref="T:Loyc.Syntax.Lexing.IndentTokenGenerator`1"/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.IndentTokenGenerator.#ctor(Loyc.Syntax.Lexing.ILexer{Loyc.Syntax.Lexing.Token},System.Int32[],System.Nullable{Loyc.Syntax.Lexing.Token},Loyc.Syntax.Lexing.Token,Loyc.Syntax.Lexing.Token)">
            <summary>Initializes the indent detector.</summary>
            <param name="lexer">Original lexer</param>
            <param name="allIndentTriggers">A list of all token types that could trigger the insertion of an indentation token.</param>
            <param name="eolToken">Prototype token for end-statement markers inserted when
            newlines are encountered, or null to avoid generating such markers.</param>
            <param name="indentToken">Prototype token for indentation markers</param>
            <param name="dedentToken">Prototype token for un-indent markers</param>
        </member>
        <member name="F:Loyc.Syntax.Lexing.IndentTokenGenerator._eolIndentTriggers">
            <summary>A subset of <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.AllIndentTriggers"/> that only take 
            effect at the end of a line.</summary>
            <remarks>If this list includes items that are not in 
            <see cref="P:Loyc.Syntax.Lexing.IndentTokenGenerator.AllIndentTriggers"/>, they have no effect.</remarks>
        </member>
        <member name="P:Loyc.Syntax.Lexing.IndentTokenGenerator.EolToken">
            <summary>Gets or sets the prototype token for end-statement (a.k.a. 
            end-of-line) markers, cast to an integer as required by <see cref="T:Loyc.Syntax.Lexing.Token"/>. 
            Use <c>null</c> to avoid generating such markers.</summary>
            <remarks>Note: if the last token on a line has this same type, this 
            class will not generate an extra newline token.
            <para/>
            The StartIndex is updated for each actual token emitted.</remarks>
        </member>
        <member name="P:Loyc.Syntax.Lexing.IndentTokenGenerator.IndentToken">
            <summary>Gets or sets the prototype token for indentation markers.</summary>
            <remarks>The StartIndex is updated for each actual token emitted.</remarks>
        </member>
        <member name="P:Loyc.Syntax.Lexing.IndentTokenGenerator.DedentToken">
            <summary>Gets or sets the prototype token for unindentation markers.</summary>
            <remarks>The StartIndex is updated for each actual token emitted.</remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.WhitespaceFilter`1">
            <summary>Filters out tokens whose <c>Value</c> is <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.WhitespaceFilter">
            <summary>Alias for <c>WhitespaceFilter{Token}</c></summary>
        </member>
        <member name="T:LeMP.IMacroContext">
            <summary>This interface provides services offered by the lexical macro processor (LeMP).</summary>
            <remarks>Macros receive this as their second argument (see <see cref="T:LeMP.LexicalMacro"/>)</remarks>
        </member>
        <member name="M:LeMP.IMacroContext.PreProcessChildren">
            <summary>Applies all available macros to the current node's children 
            and returns the result.</summary>
            <remarks>
            This method only processes children once. If this method is called 
            again for the same node, it returns a cached result.
            <para/>
            If the currently-running macro fails the result may be thrown away
            and the effort of processing the children will have been wasted. If
            the macro succeeds a its <see cref="T:LeMP.LexicalMacro"/> attribute does not 
            include <c>Mode = MacroMode.NoReprocessing</c>, the children will 
            (normally) be processed again after the macro returns.
            </remarks>
        </member>
        <member name="M:LeMP.IMacroContext.PreProcess(Loyc.Collections.RVList{Loyc.Syntax.LNode},System.Boolean,System.Boolean,System.Boolean)">
            <summary>Runs the macro processor on the specified node(s).</summary>
            <param name="input">The node or node list to process.</param>
            <param name="asRoot">If false, the nodes are treated as children of the 
            current node (using the current list of ancestors as a basis), otherwise
            the nodes are processed alone as if they were a separate file.</param>
            <param name="resetOpenNamespaces">If false, the set of open namespaces
            stays the same; if true it is cleared to the set of pre-opened 
            namespaces (<see cref="!:MacroProcessor.PreOpenedNamespaces"/>).</param>
            <remarks>The node(s)</remarks>
        </member>
        <member name="M:LeMP.IMacroContext.PreProcess(Loyc.Syntax.LNode,System.Boolean,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:LeMP.IMacroContext.PreProcess(Loyc.Collections.RVList{Loyc.Syntax.LNode},System.Boolean,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:LeMP.IMacroContext.Sink">
            <summary>Returns the message sink, used for writing warnings and errors.</summary>
            <remarks>For backward compatibility, IMacroContext itself implements 
            IMessageSink, but if we were starting from scratch you'd have to write 
            output through this property.</remarks>
        </member>
        <member name="P:LeMP.IMacroContext.ScopedProperties">
            <summary>Returns a table of "properties" (arbitrary key-value pairs)
            that exist in the current scope. This dictionary is "persistent" in the
            computer science sense; any changes to these properties affect only the
            current scope and child scopes. When the current scope ends, the set of 
            properties that existed in the parent scope are restored.</summary>
            <remarks>
            Scopes are bounded by curly brace nodes (Call nodes named "{}").
            </remarks>
        </member>
        <member name="P:LeMP.IMacroContext.Ancestors">
            <summary>Returns a list of ancestors of the current node being 
            processed. Normally Ancestors[0] is a #splice node that contains a list 
            of all top-level statements in the file, and Parents.Last() is the
            current node.</summary>
            <remarks>You would expect that Ancestors[N] would contain Ancestors[N+1]
            as part of the attributes, target or arguments, but this is not always
            true. The ancestor list contains original versions of each node; when a
            child node is changed by a macro, the parent is not updated in this 
            list, but macro processing continues for the descendants of that child,
            so the ancestor list may occasionally seem incoherent.</remarks>
        </member>
        <member name="P:LeMP.IMacroContext.Parent">
            <summary>Gets the logical parent of the current node, which is 
            <c>Ancestors[Ancestors.Count - 2]</c>, or null if the current node
            is the root node.</summary>
            <remarks>Please note that the current node may not actually exist in 
            the parent node due to changes made earlier to the current node by 
            other macros (or even the same macro); the Parent property still 
            returns the old version of the parent node.</remarks>
        </member>
        <member name="P:LeMP.IMacroContext.RemainingNodes">
            <summary>Gets a list of the remaining nodes (arguments/statements or 
            attributes) after this point in the code stream.</summary>
            <remarks>
            The list is null when processing a target node.
            <para/>
            For example, if your macro is called "macro" and it appears in the
            following context:
            <code>{
              a();
              macro(b());
              c();
              d();
            }</code>
            Then this list will contain two items, c() and d(). Similarly, if
            the context is <c>[a, b, macro(c), d, e]</c> then the list will contain
            the items d and e.
            </remarks>
        </member>
        <member name="P:LeMP.IMacroContext.IsAttribute">
            <summary>Returns true if the current node is in the attribute list of 
            its immediate parent.</summary>
        </member>
        <member name="P:LeMP.IMacroContext.IsTarget">
            <summary>Returns true if the current node is the target of its parent
            call node.</summary>
        </member>
        <member name="P:LeMP.IMacroContext.DropRemainingNodes">
            <summary>Gets or sets a value that indicates whether to drop all 
            remaining node after the current one when the current macro returns.
            This property has no effect if the macro rejects the input by returning 
            null.</summary>
            <remarks>See remarks at <see cref="M:LeMP.MacroContext.GetArgsAndBody(LeMP.IMacroContext,System.Boolean)"/>.</remarks>
        </member>
        <member name="P:LeMP.IMacroContext.AllKnownMacros">
            <summary>Gets information about all macros registered with the macro 
            processor, including macros whose namespace has not been opened with
            <c>#importMacros</c>.</summary>
        </member>
        <member name="T:LeMP.MacroContext">
            <summary>Standard extension methods for <see cref="T:LeMP.IMacroContext"/>.</summary>
        </member>
        <member name="M:LeMP.MacroContext.GetArgsAndBody(LeMP.IMacroContext,System.Boolean)">
            <summary>Splits the current node into a pair of "argument" and "body" 
            lists, potentially treating ctx.RemainingNodes as the "body" list.</summary>
            <param name="ctx">Context of the current macro.</param>
            <param name="orRemainingNodes">Whether to use ctx.RemainingNodes as
            the second list if there is no {braces node} at the end of 
            ctx.CurrentNode().Args.</param>
            <returns>A pair where the first item is "arguments" and the second is 
            the "body". If no body was detected then the second list is empty and
            the first list is simply ctx.CurrentNode().Args.</returns>
            <remarks>
            EC# supports a syntax specially designed for macro calls: 
            <code>macroName(args) { stmts; }</code>
            This is stored as a call node with a body, in braces, as its final parameter,
            i.e. it is equivalent to
            <code>macroName(args, { stmts; });</code>
            A similar, but more general feature called "superexpressions" exists in LES.
            <para/>
            Some macros would additionally like to apply themselves to all remaining
            nodes in the current list of statements or expressions, i.e.
            <code>macroName(args); stmts;</code>
            LeMP supports this through the <see cref="P:LeMP.IMacroContext.DropRemainingNodes"/>
            and <see cref="P:LeMP.IMacroContext.RemainingNodes"/> APIs. If your macro wants
            to apply itself to all remaining statements or expressions in the 
            current sequence of nodes, it can set the DropRemainingNodes property 
            to true and then simply incorporate RemainingNodes into its own output
            (if you need to return multiple statements from your macro, use 
            <c>list.AsLNode(CodeSymbols.Splice)</c> to convert a RVList{LNode} to an 
            LNode.)
            <para/>
            This extension method helps you by detecting whether the current node
            has a body in braces or not. If the braces are present, the returned
            pair consists of the args shortened by one (i.e.
            <c>ctx.CurrentNode().Args.WithoutLast(1)</c>) and the Args of the "{}"
            braces node. Otherwise, <c>ctx.CurrentNode().Args</c> is the first item
            in the pair.
            <para/>
            In the latter case, if <c>orRemainingNodes</c> then this method sets
            <c>ctx.DropRemainingNodes</c> to true and uses <c>ctx.RemainingNodes</c>
            as the second list. Otherwise the second list is left blank.
            </remarks>
        </member>
        <member name="M:LeMP.MacroContext.GetOptions(Loyc.Collections.RVList{Loyc.Syntax.LNode})">
            <summary>Transforms an option list in the format <c>option1(v1), option2(v2)</c> 
            or <c>option1: v1, option2: v2</c> into a sequence of (key, value) pairs.
            If the format of a given node is invalid, this function yields <c>(null, node)</c>.</summary>
            <remarks>
            <c>option1: v1, option2: v2</c> is parsed into <c>#namedArg(option1, v1), 
            #namedArg(option2, v2)</c> in EC# or <c>@:(option1, v1), @:(option2, v2)</c> in LES.
            This function recognizes both forms.
            </remarks>
        </member>
        <member name="T:LeMP.MacroInfo">
            <summary>Data returned from <see cref="P:LeMP.IMacroContext.AllKnownMacros"/></summary>
        </member>
        <member name="M:LeMP.MacroInfo.CompareTo(LeMP.MacroInfo)">
            <summary>Compare priorities of two macros.</summary>
        </member>
        <member name="T:LeMP.LexicalMacro">
            <summary>Method signature of an LeMP macro.</summary>
            <param name="node">The node that caused the macro to be invoked (includes 
            the name of the macro itself, and any attributes applied to the macro)</param>
            <param name="context">This is a dual-purpose object. Firstly, this object
            implements <see cref="T:Loyc.IMessageSink"/>. if the input does not have a valid 
            form, the macro rejects it by returning null. Before returning null, the 
            macro should explain the reason for the rejection (including a pattern that 
            the macro accepts) by writinga message to this object. Secondly, this 
            object contains additional information including the ancestors of the 
            current node and a list of "scoped properties" (see <see cref="T:LeMP.IMacroContext"/>.)
            </param>
            <returns>A node to replace the original <c>node</c>, or null if this 
            macro rejects the input node. Returning null can allow a different macro 
            to accept the node instead.</returns>
            <remarks>If there are multiple macros in scope with the same name, they 
            are <i>all</i> called. Macro expansion succeeds if exactly one macro accepts 
            the input. If no macros accept the input, the error message given by each
            macro is printed; if multiple macros accept the input, an ambiguity error
            is printed.
            <para/>
            When the macro processor scans an assembly looking for macros, it requires
            <see cref="T:LeMP.ContainsMacrosAttribute"/> on the containing class, and 
            <see cref="T:LeMP.LexicalMacroAttribute"/> on each macro in the class. The macros 
            must be public static methods.
            </remarks>
        </member>
        <member name="T:LeMP.ContainsMacrosAttribute">
            <summary>Marks a class to be searched for macros.</summary>
            <remarks>The method signature of a macro must be <see cref="T:LeMP.LexicalMacro"/> and
            it must be marked with <see cref="T:LeMP.LexicalMacroAttribute"/>.</remarks>
        </member>
        <member name="T:LeMP.LexicalMacroAttribute">
            <summary>Marks a method as an LEL simple macro.</summary>
            <remarks>
            To be recognized as a macro, the method must be public and static and its 
            signature must be <see cref="T:LeMP.LexicalMacro"/>. A class will not be automatically
            searched for macros unless the class is marked with <see cref="T:LeMP.ContainsMacrosAttribute"/>.</remarks>
        </member>
        <member name="T:LeMP.MacroMode">
            <summary>Flags that affect the way that <see cref="!:LeMP.MacroProcessor"/>
            uses a SimpleMacro. Unless otherwise specified, these flags only apply when 
            the macro accepts the input by returning a non-null result.</summary>
        </member>
        <member name="F:LeMP.MacroMode.NoReprocessing">
            <summary>The macro's result (including children) is not processed further.</summary>
        </member>
        <member name="F:LeMP.MacroMode.Normal">
            <summary>The macro's result is reprocessed directly (this is the default behavior).</summary>
        </member>
        <member name="F:LeMP.MacroMode.ProcessChildrenAfter">
            <summary>The macro's result is not reprocessed, but the result's children are processed.</summary>
        </member>
        <member name="F:LeMP.MacroMode.ProcessChildrenBefore">
            <summary>The result is pre-processed before calling the macro, and not processed afterward.</summary>
        </member>
        <member name="F:LeMP.MacroMode.Passive">
            <summary>It is normal for this macro not to change the code, so a warning should not be printed when the macro "rejects" the input by returning null.</summary>
        </member>
        <member name="F:LeMP.MacroMode.AllowDuplicates">
            <summary>If this macro is ambiguous with one or more macro of the same priority, this flag blocks the ambiguity error message if all the macros produce the same results.</summary>
        </member>
        <member name="F:LeMP.MacroMode.DropRemainingListItems">
            <summary>If this macro succeeds, all nodes after this one in the current attribute or statement/argument list are dropped.</summary>
            <remarks>Tyically this option is used by macros that splice together the list of <see cref="P:LeMP.IMacroContext.RemainingNodes"/> into their own result.</remarks>
        </member>
        <member name="F:LeMP.MacroMode.FallbackMin">
            <summary>Lowest priority. If this macro is ambiguous with another macro that doesn't have this flag, the results produced by the other macro are used (note: only one priority flag can be used at a time).</summary>
        </member>
        <member name="F:LeMP.MacroMode.Fallback">
            <summary>Low priority. If this macro is ambiguous with another macro that doesn't have this flag nor FallbackMin, the results produced by the other macro are used (note: only one priority flag can be used at a time).</summary>
        </member>
        <member name="F:LeMP.MacroMode.NormalPriority">
            <summary>Normal priority (this is the default and does not need to be specified.)</summary>
        </member>
        <member name="F:LeMP.MacroMode.Override">
            <summary>High priority. If this macro is ambiguous with another macro that doesn't have this flag nor OverrideAll, this macro takes precedence (note: only one priority flag can be used at a time).</summary>
        </member>
        <member name="F:LeMP.MacroMode.OverrideMax">
            <summary>Highest priority. If this macro is ambiguous with another macro that doesn't have this flag, the results produced by this macro are used (note: only one priority flag can be used at a time).</summary>
        </member>
        <member name="F:LeMP.MacroMode.PriorityMask">
            <summary>For internal use to isolate the priority of a macro.</summary>
        </member>
        <member name="T:Loyc.Syntax.BaseParser`2">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator). Note: this is the old (harder to use) base class design. You 
            should use <see cref="T:Loyc.Syntax.BaseParserForList`2"/> instead.
            </summary>
        </member>
        <member name="F:Loyc.Syntax.BaseParser`2.FormatExceptionErrorSink">
            <summary>Throws FormatException when it receives an error. Non-errors
            are sent to <see cref="P:Loyc.MessageSink.Current"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.EofInt">
            <summary>Returns the value used for EOF (normally 0)</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.LT(System.Int32)">
            <summary>Returns the token at lookahead i (e.g. <c>Source[InputPosition + i]</c>
            if the tokens come from a list called Source) </summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.ToString(`1)">
            <summary>Returns a string representation of the specified token type.
            These strings are used in error messages.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.LaIndexToCharIndex(System.Int32)">
            <summary>Converts a lookahead token index to a character index (used 
            for error reporting).</summary>
            <remarks>
            The default implementation does this by trying to cast 
            <c>LT(lookaheadIndex)</c> to <c>ISimpleToken{MatchType}</c>. Returns -1
            on failure.
            <para/>
            The <c>StartIndex</c> reported by an EOF token is assumed not 
            to be trustworthy: this method will ensure that the character index 
            returned for EOF is at least as large as <c>SourceFile.Text.Count</c>
            if a <see cref="P:Loyc.Syntax.BaseParser`2.SourceFile"/> was provided, or, otherwise, at least as 
            large as the last token in the file, by scanning backward to find the 
            last token in the file.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.LaIndexToSourceRange(System.Int32)">
            <summary>Converts a lookeahead token index to a <see cref="T:Loyc.Syntax.SourceRange"/>
            object using <see cref="M:Loyc.Syntax.BaseParser`2.LaIndexToCharIndex(System.Int32)"/> and <see cref="P:Loyc.Syntax.BaseParser`2.SourceFile"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.LaIndexToContext(System.Int32)">
            <summary>Converts a lookahead token index to a <see cref="T:Loyc.Syntax.SourceRange"/>
            object using <see cref="M:Loyc.Syntax.BaseParser`2.LaIndexToCharIndex(System.Int32)"/> and <see cref="P:Loyc.Syntax.BaseParser`2.SourceFile"/>.</summary>
            <remarks>If the derived class initialized <c>SourceFile</c> to null, 
            returns "At index {0}" where {0} is the character index.</remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.Error(System.Int32,System.String)">
            <summary>Records an error or throws an exception.</summary>
            <param name="lookaheadIndex">Location of the error relative to the
            current <c>InputPosition</c>. When called by BaseParser, lookaheadIndex 
            is always equal to 0.</param>
            <remarks>
            The default implementation throws a <see cref="T:System.FormatException"/>.
            When overriding this method, you can convert the lookaheadIndex
            to a <see cref="T:Loyc.Syntax.SourcePos"/> using the expression
            <c>SourceFile.IndexToLine(LT(lookaheadIndex).StartIndex)</c>. This only
            works if an <c>ISourceFile</c> object was provided to the constructor of 
            this class, and <c>Token</c> implements <see cref="T:Loyc.Syntax.Lexing.ISimpleToken"/>.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParser`2.Error(System.Int32,System.String,System.Object[])">
            <inheritdoc cref="M:Loyc.Syntax.BaseParser`2.Error(System.Int32,System.String)"/>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.ErrorSink">
            <summary>Gets or sets the object to which error messages are sent. The
            default object is <see cref="F:Loyc.Syntax.BaseParser`2.FormatExceptionErrorSink"/>, which throws
            <see cref="T:System.FormatException"/> if an error occurs.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.SourceFile">
            <summary>The <see cref="T:Loyc.Syntax.ISourceFile"/> object that was provided to the constructor, if any.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.LT0">
            <summary>Next token to parse (cached; is set to LT(0) whenever InputPosition is changed).</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.InputPosition">
            <summary>Current position of the next token to be parsed.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParser`2.LA0Int">
            <summary>Returns the token type of _lt0 (normally _lt0.TypeInt)</summary>
        </member>
        <member name="T:Loyc.Syntax.BaseParser`2.SavePosition">
            <summary>A helper class used by LLLPG for backtracking.</summary>
        </member>
        <member name="T:Loyc.Syntax.BaseParser`1">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator). Note: this is the old (harder to use) base class. You should 
            use <see cref="T:Loyc.Syntax.BaseParserForList`2"/> instead. This class is
            now an alias for BaseParser{Token,int}.
            </summary>
        </member>
        <member name="T:Loyc.Syntax.BaseParserForList`3">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator) and receive tokens from any <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            (Potentially also useful for parsers written by hand.)
            </summary>
            <remarks>
            The compiler will ensure that you use this base class correctly. All you 
            have to do is call the base class constructor and override the abstract 
            method <see cref="M:Loyc.Syntax.BaseParserForList`3.ToString(`1)"/>.
            <para/>
            This version of BaseParserForList has <c>List</c> (a token list) as a 
            generic parameter. Compared to using <c>IList{Token}</c> directly, this 
            can increase performance in case the <c>List</c> is a value type (e.g. 
            <c>InternalList&lt;Token&gt;</c>).
            </remarks>
            <typeparam name="Token">Data type of complete tokens in the token list. A 
            token contains the type of a "word" in the program (string, identifier, plus 
            sign, etc.), a value (e.g. the name of an identifier), and a range of 
            characters in the source file. See <see cref="T:Loyc.Syntax.Lexing.ISimpleToken`1"/>.
            Note: Token is usually a small struct; this class assumes that it will 
            never be null.</typeparam>
            <typeparam name="MatchType">A data type, usually int, that represents a 
            token type (identifier, operator, etc.) and implements <see cref="T:System.IEquatable`1"/>
            so it can be compared for equality with other token types; this is also the 
            type of the <see cref="P:Loyc.Syntax.Lexing.ISimpleToken`1.Type"/> property. <c>MatchType</c>
            cannot be an enum because an enum does not implement <see cref="T:System.IEquatable`1"/>.</typeparam>
            <typeparam name="List">Data type of the list that contains the tokens (one 
            often uses IList{Token}, but one could use <see cref="T:Loyc.Collections.Impl.InternalList`1"/> 
            for potentially higher performance.)</typeparam>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.#ctor(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <summary>Initializes this object to begin parsing the specified tokens.</summary>
            <param name="list">A list of tokens that the derived class will parse.</param>
            <param name="eofToken">A token value to return when the input position 
            reaches the end of the token list. Ideally <c>eofToken.StartIndex</c>
            should contain the position of EOF, but the base class method
            <see cref="M:Loyc.Syntax.BaseParser`2.LaIndexToCharIndex(System.Int32)"/> does not trust this
            value, and will ensure that the character index returned for EOF is at 
            least as large as the character index of the last token in the file. 
            This means that it is safe to set <c>ISimpleToken{MatchType}.StartIndex</c> 
            to 0 in the EOF token, because when an error message involves EOF, the
            base class will find a more accurate EOF position.</param>
            <param name="file">A source file object that will be returned by the 
            <see cref="T:Loyc.Syntax.SourceFile"/> property. By default, this object is used to 
            get the file name, line number and column number shown in parser errors. 
            If you are using <see cref="T:Loyc.Syntax.Lexing.BaseLexer"/> or <see cref="T:Loyc.Syntax.Lexing.LexerSource"/>, 
            you can get this object from the <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> 
            property. The <see cref="T:Loyc.Syntax.SourceFile"/> property (in this class) will 
            return this value. If this parameter is null, then by default, error 
            messages will only show the character index instead of the file, line 
            number and column number.</param>
            <param name="startIndex">The initial index from which to start reading
            tokens from the list (normally 0).</param>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.Reset(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <summary>Reinitializes the object. This method is called by the constructor.</summary>
            <remarks>See the constructor for documentation of the parameters.</remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.ToString(`1)">
            <summary>Returns a string representation of the specified token type.
            These strings are used in error messages.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.Down(`2)">
            <summary>Switches to parsing the specified token list at position zero
            (typically the value of <see cref="P:Loyc.Syntax.Lexing.Token.Children"/> 
            in a token tree produced by <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>.) The original 
            token list and the original <see cref="P:Loyc.Syntax.BaseParserForList`3.InputPosition"/> are placed on a 
            stack, so you can restore the old list by calling <see cref="M:Loyc.Syntax.BaseParserForList`3.Up"/>.</summary>
            <returns>True if successful, false if <c>children</c> is null.</returns>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.Up">
            <summary>Returns to the old token list saved by <see cref="M:Loyc.Syntax.BaseParserForList`3.Down(`2)"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`3.Up``1(``0)">
            <summary>Calls <see cref="M:Loyc.Syntax.BaseParserForList`3.Up"/> and returns <c>value</c>.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParserForList`3.TokenList">
            <summary>The IList{Token} that was provided to the constructor, if any.</summary>
            <remarks>Note: if you are starting to parse a new source file, you should call 
            <see cref="M:Loyc.Syntax.BaseParserForList`3.Reset(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)"/> instead of setting this property.</remarks>
        </member>
        <member name="T:Loyc.Syntax.BaseParserForList`2">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator) and receive tokens from any <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <remarks>
            This base class for LLLPG parsers reads tokens from <see cref="T:System.Collections.Generic.IList`1"/>,
            but you can also pass an <see cref="T:System.Collections.Generic.IEnumerable`1"/> or 
            <see cref="T:System.Collections.Generic.IEnumerator`1"/> to the constructor and it will 
            convert it to a list, lazily, using <see cref="T:Loyc.Collections.BufferedSequence`1"/>.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`2.#ctor(System.Collections.Generic.IList{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`2.#ctor(System.Collections.Generic.IEnumerable{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.BaseParserForList`2.#ctor(System.Collections.Generic.IEnumerator{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="T:Loyc.Syntax.BaseParserNoBacktracking`2">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator) and receive tokens from any <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <remarks>
            This base class for LLLPG parsers simply requires an enumerator to work,
            and it has a small buffer to hold lookahead tokens. Old tokens are 
            forgotten, so this base class does not support backtracking (i.e. syntactic 
            predicates), but it can save memory. Please use <see cref="T:Loyc.Syntax.BaseParserForList`2"/> 
            if your input sequence comes in the form of a list.
            <para/>
            This version of BaseParser has Enumerator as a generic parameter. Compared 
            to using IEnumerator{Token} directly, this can increase performance in case 
            Enumerator is a value type (e.g. <c>List&lt;Token&gt;.Enumerator</c>).
            <para/>
            (I wrote this class by mistake... I actually forgot about backtracking!)
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.BaseParserNoBacktracking`2.#ctor(`1,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <summary>Initializes this object to begin parsing the specified tokens.</summary>
            <param name="sequence">A list of tokens to be parsed.</param>
            <param name="eofToken">A token value to return when the input position 
            reaches the end of the token list.</param>
            <param name="file">A source file object that will be returned by the <see cref="T:Loyc.Syntax.SourceFile"/>
            property. By default, this object is used to get the file name, line 
            number and column number shown in parser errors. If you are using 
            <see cref="T:Loyc.Syntax.Lexing.BaseLexer"/>, you can get this object from the
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.SourceFile"/> property. The <see cref="T:Loyc.Syntax.SourceFile"/>.
            property (in this class) will return this value. It can be null, which
            means that default error messages will show the character index instead
            of the file, line number and column number.</param>
            <param name="startIndex">The initial value of the InputPosition property.
            This is informational only, and has no effect on the behavior of this 
            class.</param>
        </member>
        <member name="M:Loyc.Syntax.BaseParserNoBacktracking`2.LT(System.Int32)">
            <summary>Returns the Token at lookahead i, where 0 is the next token.
            This class does not support negative lookahead because old tokens from 
            the IEnumerator are discarded.</summary>
        </member>
        <member name="M:Loyc.Syntax.BaseParserNoBacktracking`2.ToString(System.Int32)">
            <summary>Returns a string representation of the specified token type.
            These strings are used in error messages.</summary>
        </member>
        <member name="P:Loyc.Syntax.BaseParserNoBacktracking`2.InputPosition">
            <summary>Cumulative index of the next token to be parsed.</summary>
            <remarks>This class doesn't care what the absolute InputPosition is, 
            since it reads from an <see cref="T:System.Collections.Generic.IEnumerator`1"/>. This property
            is constrained to always increase, since old tokens are forgotten.</remarks>
        </member>
        <member name="T:Loyc.Syntax.BaseParserNoBacktracking`1">
            <summary>
            An base class designed for parsers that use LLLPG (Loyc LL(k) Parser 
            Generator) and receive tokens from an <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <seealso cref="T:Loyc.Syntax.BaseParserNoBacktracking`2"/>
        </member>
        <member name="T:Loyc.Syntax.CodeSymbols">
            <summary>
            A list of common symbols that have special meaning somewhere in Loyc or EC#:
            operators, built-in data types, keywords, trivia, etc.
            </summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.AltList">
            <summary># is used for lists of things in definition constructs, e.g. 
                <c>#class(Derived, #(Base, IEnumerable), {...})</c>.
            For a time, #tuple was used for this purpose; the problem is that a
            find-and-replace operation intended to find run-time tuples could 
            accidentally match one of these lists. So I decided to dedicate # 
            for use inside special constructs; its meaning depends on context.
            </summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.BadCode">
            <summary>An identifier or call with this Name indicates that parsing or 
            analysis failed earlier and that an error message has already been 
            printed.</summary>
            <remarks>When code in a compiler sees this symbol it should be seen as
            a signal to avoid printing further error messages that involve the same
            node. Typically, a node named #badCode should replace the bad code, and 
            it may have an argument that describes the error, which could be printed 
            at runtime if compilation continues to completion.</remarks>
            <example>#badCode("Argument 2: Cannot convert 'string' to 'int'.")</example>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.Internal">
            <summary>Provides general access within a library or program (implies
            #protected_in).</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.Public">
            <summary>Provides general access, even outside the assembly (i.e. 
            dynamic-link library). Implies #internal, #protectedIn and #protected.</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.ProtectedIn">
            <summary>Provides access to derived classes only within the same library
            or program (i.e. assembly). There is no C# equivalent to this keyword,
            which does not provide access outside the assembly.</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.Protected">
            <summary>Provides access to all derived classes. Implies #protected_in.
            #protected #internal corresponds to C# "protected internal"</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.Private">
            <summary>Revokes access outside the same space and nested spaces. This 
            can be used in spaces in which the default is not private to request
            private as a starting point. Therefore, other flags (e.g. #protected_ex)
            can be added to this flag to indicate what access the user wants to
            provide instead.
            </summary><remarks>
            The name #private may be slightly confusing, since a symbol marked 
            #private is not actually private when there are other access markers
            included at the same time. I considered calling it #revoke instead,
            since its purpose is to revoke the default access modifiers of the
            space, but I was concerned that someone might want to reserve #revoke 
            for some other purpose.
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.FilePrivate">
            <summary>Used with #alias to indicate that an alias is local to the
            current source file. <c>[#filePrivate] #alias(X = Y, #())</c> is the long
            form of <c>using X = Y</c> in EC#.</summary>
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.TriviaRawTextBefore">
            if `#trivia_rawText` has the string "eat my shorts!" attached as its Value,
            then `[#trivia_rawText] x;` is printed "eat my shorts!x;". It can also be
            structured as a call: `[#trivia_rawText("eat my shorts!")] x;`
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.TriviaWordAttribute">
            "#trivia_wordAttribute": in EC#, this trivia is placed on an identifier treated as an attribute (e.g. partial, async).
        </member>
        <member name="F:Loyc.Syntax.CodeSymbols.RawText">
            #rawText must have a Value, or be a call with a single literal argument.
            The Value is converted to a string and printed out by EcsNodePrinter 
            without any filtering, e.g. `#rawText("Hello")` is printed `Hello`.
        </member>
        <member name="M:Loyc.Syntax.CodeSymbols.IsArrayKeyword(Loyc.Symbol)">
            <summary>Returns true if the symbol is a pair of square brackets with 
            zero or more commas inside, e.g. "[,]", which in EC# represents an array 
            type of a specific number of dimensions.</summary>
        </member>
        <member name="M:Loyc.Syntax.CodeSymbols.CountArrayDimensions(Loyc.Symbol)">
            <summary>Returns the rank of an array symbol when <see cref="M:Loyc.Syntax.CodeSymbols.IsArrayKeyword(Loyc.Symbol)"/> 
            is true, or 0 if the symbol does not represent an array type.</summary>
        </member>
        <member name="M:Loyc.Syntax.CodeSymbols.GetArrayKeyword(System.Int32)">
            <summary>Gets the Symbol for an array with the specified number of 
            dimensions, e.g. <c>GetArrayKeyword(3)</c> returns <c>[,,]</c>.</summary>
        </member>
        <member name="T:Loyc.Syntax.IParsingService">
            <summary>An interface that encapsulates the lexer, parser, and printer
            of a programming language, or a non-programming language that can be 
            represented by Loyc trees.</summary>
            <remarks>
            The simplest way to parse code is with the extension method 
            <c>Parse(string, IMessageSink msgs = null, Symbol inputType = null)</c>.
            The simplest way to print is with <c>Print(LNode, IMessageSink)</c>
            <para/>
            The ToString() method should return a string that indicates the 
            programming language represented by this object, e.g. "LES 1.0 parser".
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Tokenize(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink)">
            <summary>Returns a lexer that is configured to begin reading the specified file.</summary>
            <param name="file">Text to be tokenized (e.g. <see cref="T:Loyc.UString"/>)</param>
            <param name="fileName">File name to be associated with any errors that occur.</param>
            <param name="msgs">Error messages are sent to this object.</param>
            <remarks>
            The returned lexer should be a "simple" tokenizer. If the language uses 
            tree lexing (in which tokens are grouped by parentheses and braces),
            the returned lexer should NOT include the grouping process, and it 
            should not remove comments, although it may skip spaces and perhaps
            newlines. If there is a preprocessor, it should not run.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Symbol)">
            <summary>Parses a source file into one or more Loyc trees.</summary>
            <param name="file">input file or string.</param>
            <param name="msgs">output sink for error and warning messages.</param>
            <param name="inputType">Indicates the kind of input: <c>Exprs</c> (one 
            or more expressions, typically seprated by commas but this is language-
            defined), <c>Stmts</c> (a series of statements), or <c>File</c> (an 
            entire source file). <c>null</c> is a synonym for <c>File</c>.</param>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Parse(Loyc.Syntax.Lexing.ILexer{Loyc.Syntax.Lexing.Token},Loyc.IMessageSink,Loyc.Symbol)">
            <summary>If <see cref="P:Loyc.Syntax.IParsingService.HasTokenizer"/> is true, this method accepts a 
            lexer returned by Tokenize() and begins parsing.</summary>
            <param name="msgs">output sink for error and warning messages.</param>
            <param name="inputType">Indicates how the input should be interpreted:
            <see cref="F:Loyc.Syntax.ParsingService.File"/>, <see cref="F:Loyc.Syntax.ParsingService.Exprs"/> or
            <see cref="F:Loyc.Syntax.ParsingService.Stmts"/>. The default input type should be
            File.</param>
            <exception cref="T:System.NotSupportedException">HasTokenizer is false.</exception>
            <remarks>
            This method adds any preprocessing steps to the lexer (tree-ification 
            or token preprocessing) that are required by this language before it 
            sends the results to the parser. If possible, the output is computed 
            lazily.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.IListSource{Loyc.Syntax.Lexing.Token},Loyc.Syntax.ISourceFile,Loyc.IMessageSink,Loyc.Symbol)">
            <summary>Parses a token tree, such as one that came from a token literal.</summary>
            <remarks>
            Some languages may offer token literals, which are stored as token trees
            that can be processed by "macros" or compiler plugins. A macro may wish 
            to parse some of the token literal using the host language's parser 
            (e.g. LLLPG needs to do this), so this method is provided for that 
            purpose.
            </remarks>
            <exception cref="T:System.NotSupportedException">This feature is not supported 
            by this parsing service.</exception>
        </member>
        <member name="M:Loyc.Syntax.IParsingService.Print(Loyc.Syntax.LNode,Loyc.IMessageSink,System.Object,System.String,System.String)">
            <summary>Converts the specified syntax tree to a string.</summary>
            <param name="node">A syntax tree to print.</param>
            <param name="msgs">If errors or warnings occur during printing, 
            they are sent here. If this is null, messages shall be sent to
            <see cref="P:Loyc.MessageSink.Current"/>.</param>
            <param name="mode">Language-defined configuration. It is suggested 
            that the printing service should accept ParsingService.Exprs, 
            ParsingService.Stmts and ParsingService.File as possible printing 
            modes.</param>
            <param name="indentString">Indent character for multi-line nodes</param>
            <param name="lineSeparator">Newline string for multi-line nodes</param>
        </member>
        <member name="P:Loyc.Syntax.IParsingService.FileExtensions">
            <summary>Standard file extensions for this language, without leading 
            dots, with the first one being the most common.</summary>
        </member>
        <member name="P:Loyc.Syntax.IParsingService.HasTokenizer">
            <summary>Returns true if the Tokenize() method is available.</summary>
        </member>
        <member name="P:Loyc.Syntax.IParsingService.Printer">
            <summary>Gets a printer delegate that you can use with 
            <see cref="P:Loyc.Syntax.LNode.Printer"/> and <see cref="M:Loyc.Syntax.LNode.PushPrinter(Loyc.Syntax.LNodePrinter)"/>,
            or null if there is no corresponding printer available for the parser
            reresented by this object.</summary>
        </member>
        <member name="T:Loyc.Syntax.ParsingService">
            <summary>Extension methods for <see cref="T:Loyc.Syntax.IParsingService"/>.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParsingService.Exprs">
            <summary>Tells <see cref="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Symbol)"/> to treat the input 
            as a single expression or expression list (which, in most languages, 
            is comma-separated).</summary>
        </member>
        <member name="F:Loyc.Syntax.ParsingService.Stmts">
            <summary>Tells <see cref="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Symbol)"/> to treat the input
            as a list of statements. If the language makes a distinction between 
            executable and declaration contexts, this refers to the executable 
            context.</summary>
        </member>
        <member name="F:Loyc.Syntax.ParsingService.File">
            <summary>Tells <see cref="M:Loyc.Syntax.IParsingService.Parse(Loyc.Collections.ICharSource,System.String,Loyc.IMessageSink,Loyc.Symbol)"/> to treat the input
            as a complete source file (this should be the default, i.e. null will
            do the same thing).</summary>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.PushCurrent(Loyc.Syntax.IParsingService)">
            <summary>Sets the current language service, returning a value suitable 
            for use in a C# using statement, which will restore the old service.</summary>
            <param name="newValue">new value of Current</param>
            <example><code>
            LNode code;
            using (var old = ParsingService.PushCurrent(LesLanguageService.Value))
                code = ParsingService.Current.ParseSingle("This is les code;");
            </code></example>
        </member>
        <member name="M:Loyc.Syntax.ParsingService.PrintMultiple(Loyc.Syntax.LNodePrinter,System.Collections.Generic.IEnumerable{Loyc.Syntax.LNode},Loyc.IMessageSink,System.Object,System.String,System.String)">
            <summary>Converts a sequences of LNodes to strings, adding a newline after each.</summary>
            <param name="printer">Printer for a single LNode.</param>
            <param name="mode">A language-specific way of modifying printer behavior.
            The printer ignores the mode object if it does not not understand it.</param>
            <param name="indentString">A string to print for each level of indentation, such as a tab or four spaces.</param>
            <param name="lineSeparator">Line separator, typically "\n" or "\r\n".</param>
            <returns>A string form of the nodes.</returns>
        </member>
        <member name="P:Loyc.Syntax.ParsingService.Current">
            <summary>Gets or sets the active language service on this thread. If 
            no service has been assigned on this thread, returns <see cref="F:Loyc.Syntax.Les.LesLanguageService.Value"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.ParsingService.PushedCurrent">
            <summary>Returned by <see cref="M:Loyc.Syntax.ParsingService.PushCurrent(Loyc.Syntax.IParsingService)"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.LesLanguageService">
            <summary>The <see cref="F:Loyc.Syntax.Les.LesLanguageService.Value"/> property provides easy access to the lexer, 
            parser and printer for Loyc Expression Syntax (LES).</summary>
            <remarks>
            LES overview: http://sourceforge.net/apps/mediawiki/loyc/index.php?title=LES
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Les.LesLexer">
            <summary>Lexer for EC# source code.</summary>
            <seealso cref="T:Loyc.Syntax.Lexing.ILexer`1"/>
            <seealso cref="T:Loyc.Syntax.Lexing.TokensToTree"/>
        </member>
        <member name="F:Loyc.Syntax.Les.LesLexer.SkipValueParsing">
            <summary>Used for syntax highlighting, which doesn't care about token values.
            This option causes the Token.Value to be set to a default, like '\0' for 
            single-quoted strings and 0 for numbers. Operator names are still parsed.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.LesLexer.UnescapeQuotedString(Loyc.UString@,System.Action{System.Int32,System.String},Loyc.UString)">
            <summary>Parses a normal or triple-quoted string that still includes 
            the quotes. Supports quote types '\'', '"' and '`'.</summary>
            <param name="sourceText">input text</param>
            <param name="onError">Called in case of parsing error (unknown escape sequence or missing end quotes)</param>
            <param name="indentation">Inside a triple-quoted string, any text
            following a newline is ignored as long as it matches this string. 
            For example, if the text following a newline is "\t\t Foo" and this
            string is "\t\t\t", the tabs are ignored and " Foo" is kept.</param>
            <returns>The decoded string</returns>
            <remarks>This method recognizes LES and EC#-style string syntax.
            Firstly, it recognizes triple-quoted strings (''' """ ```). These 
            strings enjoy special newline handling: the newline is always 
            interpreted as \n regardless of the actual kind of newline (\r and 
            \r\n newlines come out as \n), and indentation following the newline
            can be stripped out. Triple-quoted strings can have escape sequences
            that use both kinds of slash, like so: <c>\n/ \r/ \'/ \"/ \0/</c>.
            However, there are no unicode escapes (\u1234/ is NOT supported).
            <para/>
            Secondly, it recognizes normal strings (' " `). These strings stop 
            parsing (with an error) at a newline, and can contain C-style escape 
            sequences: <c>\n \r \' \" \0</c> etc. C#-style verbatim strings are 
            NOT supported.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.LesLexer.UnescapeQuotedString(Loyc.UString@,System.Action{System.Int32,System.String},System.Text.StringBuilder,Loyc.UString)">
            <summary>Parses a normal or triple-quoted string that still includes 
            the quotes (see documentation of the first overload) into a 
            StringBuilder.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.LesLexer.UnescapeString(Loyc.UString@,System.Char,System.Boolean,System.Action{System.Int32,System.String},System.Text.StringBuilder,Loyc.UString)">
            <summary>Parses a normal or triple-quoted string whose starting quotes 
            have been stripped out. If triple-quote parsing was requested, stops 
            parsing at three quote marks; otherwise, stops parsing at a single 
            end-quote or newline.</summary>
            <returns>true if parsing stopped at one or three quote marks, or false
            if parsing stopped at the end of the input string or at a newline (in
            a string that is not triple-quoted).</returns>
            <remarks>This method recognizes LES and EC#-style string syntax.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.LesLexer.ParseIdentifier(Loyc.UString@,System.Action{System.Int32,System.String},System.Boolean@)">
            <summary>Parses an LES-style identifier such as <c>foo</c>, <c>@foo</c>, 
            <c>@`foo`</c> or <c>@--punctuation--</c>. Also recognizes <c>#`foo`</c>.
            </summary>
            <param name="source">Text to parse. On return, the range has been 
            decreased by the length of the token; this method also stops if this
            range becomes empty.</param>
            <param name="onError">A method to call on error</param>
            <param name="checkForNamedLiteral">This is set to true when the input 
            starts with @ but is a normal identifier, which could indicate that 
            it is an LES named literal such as @false or @null.</param>
            <returns>The parsed version of the identifier.</returns>
        </member>
        <member name="M:Loyc.Syntax.Les.LesLexer.ParseNumberCore(Loyc.UString,System.Boolean,System.Int32,System.Boolean,Loyc.Symbol,System.String@)">
            <summary>Parses the digits of a literal (integer or floating-point),
            not including the radix prefix (0x, 0b) or type suffix (F, D, L, etc.)</summary>
            <param name="source">Digits of the number (not including radix prefix or type suffix)</param>
            <param name="isFloat">Whether the number is floating-point</param>
            <param name="numberBase">Radix. Must be 2 (binary), 10 (decimal) or 16 (hexadecimal).</param>
            <param name="typeSuffix">Type suffix: F, D, M, U, L, UL, or null.</param>
            <param name="error">Set to an error message in case of error.</param>
            <returns>Boxed value of the literal, null if total failure (result 
            is not null in case of overflow), or <see cref="F:Loyc.Syntax.CodeSymbols.Sub"/> (-)
            if isNegative is true but the type suffix is unsigned or the number 
            is larger than long.MaxValue.</returns>
        </member>
        <member name="T:Loyc.Syntax.Les.LesNodePrinter">
            <summary>Prints a Loyc tree in LES (Loyc Expression Syntax) format.</summary>
            <remarks>Unless otherwise noted, the default value of all options is false.</remarks>
        </member>
        <member name="F:Loyc.Syntax.Les.LesNodePrinter.StartStmt">
            <summary>Context: beginning of main expression (potential superexpression)</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.LesNodePrinter.AllowExtraParenthesis">
            <summary>Introduces extra parenthesis to express precedence, without
            using an empty attribute list [] to allow perfect round-tripping.</summary>
            <remarks>For example, the Loyc tree <c>x * @+(a, b)</c> will be printed 
            <c>x * (a + b)</c>, which is a slightly different tree (the parenthesis
            add the trivia attribute #trivia_inParens.)</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.LesNodePrinter.OmitMissingArguments">
            <summary>When an argument to a method or macro has the value <c>@``</c>,
            it will be omitted completely if this flag is set.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.LesNodePrinter.OmitSpaceTrivia">
            <summary>When this flag is set, space trivia attributes are ignored
            (e.g. <see cref="F:Loyc.Syntax.CodeSymbols.TriviaSpaceAfter"/>).</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.LesNodePrinter.OmitComments">
            <summary>When this flag is set, comment trivia attributes are ignored
            (e.g. <see cref="F:Loyc.Syntax.CodeSymbols.TriviaSLCommentAfter"/>).</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.LesNodePrinter.QuoteUnprintableLiterals">
            <summary>When the printer encounters an unprintable literal, it calls
            Value.ToString(). When this flag is set, the string is placed in double
            quotes; when this flag is clear, it is printed as raw text.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.LesNodePrinter.OmitUnknownTrivia">
            <summary>Causes unknown trivia (other than comments, spaces and raw 
            text) to be dropped from the output.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.LesNodePrinter.PrintExplicitTrivia">
            <summary>Causes comments and spaces to be printed as attributes in order 
            to ensure faithful round-trip parsing. By default, only "raw text" and
            unrecognized trivia is printed this way. Note: #trivia_inParens is 
            always printed as parentheses.</summary>
        </member>
        <member name="P:Loyc.Syntax.Les.LesNodePrinter.ObeyRawText">
            <summary>Causes raw text to be printed verbatim, as the EC# printer does.
            When this option is false, raw text trivia is printed as a normal 
            attribute.</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.LesNodePrinter.Mode.Wsa">
            <summary>Whitespace agnostic mode. ':' cannot be used to begin a 
            python-style code block.</summary>
        </member>
        <member name="F:Loyc.Syntax.Les.LesNodePrinter.Mode.InParens">
            <summary>Inside parenthesis (implies Wsa, and additionally allows 
            ':' as an operator).</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.INodePrinterWriter">
            <summary>This interface is implemented by helper objects that handle the 
            low-level details of node printing. It is used by <see cref="T:Loyc.Syntax.Les.LesNodePrinter"/>.</summary>
            <remarks>Specifically, INodePrinterWriter objects are in charge of how much
            to indent lines of code, and ensuring that there are spaces between tokens
            whenever omitting a space would screw up parsing.
            <para/>
            Although this interface is also used by EC#, I've kept it in the 
            Les namespace because I'm not yet confident that it's a <i>good</i> design 
            for arbitrary languages.</remarks>
        </member>
        <member name="P:Loyc.Syntax.Les.INodePrinterWriter.Target">
            <summary>Gets the object being written to (TextWriter or StringBuilder)</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.NodePrinterWriterBase">
            <summary>Abstract base class for <see cref="T:Loyc.Syntax.Les.INodePrinterWriter"/>. Has an
            protected <c>_indentLevel</c> field that is increased by Indent() and 
            decreased by Dedent().</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.DefaultNodePrinterWriter">
            <summary>Base class for the helper classes of <see cref="T:Loyc.Syntax.Les.LesNodePrinter"/>
            and <see cref="!:Ecs.EcsNodePrinter"/>, called LesNodePrinterWriter and 
            EcsNodePrinterWriter. See <see cref="T:Loyc.Syntax.Les.INodePrinterWriter"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.LesNodePrinterWriter">
            <summary>Helper class of <see cref="T:Loyc.Syntax.Les.LesNodePrinter"/> that ensures there is 
            a tokens are spaced apart properly.</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.LesParser">
            <summary>Parses LES (Loyc Expression Syntax) code into a sequence of Loyc 
            trees (<see cref="T:Loyc.Syntax.LNode"/>), one per top-level statement.</summary>
            <remarks>
            You can use <see cref="F:Loyc.Syntax.Les.LesLanguageService.Value"/> with <see cref="M:Loyc.Syntax.ParsingService.Parse(Loyc.Syntax.IParsingService,Loyc.UString,Loyc.IMessageSink,Loyc.Symbol)"/>
            to easily parse a text string (holding zero or more LES statements) into a Loyc tree.
            <para/>
            This class expects to receive tokens from <see cref="T:Loyc.Syntax.Les.LesLexer"/> that have been 
            preprocessed by <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>, with whitespace tokens filtered out.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.LesParser.Start(Loyc.Holder{Loyc.Syntax.Les.TokenType})">
            <summary>Top-level rule: expects a sequence of statements followed by EOF</summary>
        </member>
        <member name="T:Loyc.Syntax.Les.LesPrecedence">
             <summary>Contains <see cref="T:Loyc.Syntax.Precedence"/> objects that represent the 
             precedence levels of LES.</summary>
             <remarks>
             In LES, the precedence of an operator is decided based simply on the text 
             of the operator. The precedence of each one-character operator is 
             predefined; the precedence of any operator with two or more characters 
             is decided based on the last character, or the first and last character;
             the middle characters, if any, do not affect precedence.
             <para/>
             The LES precedence table is designed to be comparable with popular
             programming languages, with a couple of "corrections" that I felt were 
             appropriate; for example, in LES, <c>x ^ 7 != 0</c> is parsed 
             <c>(x ^ 7) != 0</c>, rather than <c>x ^ (7 != 0)</c> as in the C family
             of languages. Similarly, <c>x &gt;&gt; 1 + y</c> is parsed <c>(x &gt;&gt; 1) + y</c>
             rather than <c>x &gt;&gt; (1 + y)</c>. Shifting is often used as a substitute
             for multiplication and division, so it has the same precedence.
             <para/>
             As a nod to functional languages, the arrow operator "-&gt;" is right-
             associative and has a precedence below '*' so that <c>int * int -&gt; int</c>
             parses as <c>(int * int) -&gt; int</c> rather than <c>int * (int -&gt; int)</c> 
             as in the C family of languages.
             <para/>
             An operator consists of a sequence of the following characters:
             <pre>
                ~ ! % ^ &amp; * \ - + = | &lt; &gt; / ? : . $
             </pre>
             Or a backslash (\) followed by a sequence of the above characters and/or 
             letters, numbers, underscores or #s. Or a string with `backtick quotes`.
             <para/>
             "@" is not considered an operator. It is used to mark a sequence of 
             punctuation and/or non-punctuation characters as an identifier, a symbol,
             or a special literal. "#" is not an operator; like an underscore, the 
             hash sign is considered to be an identifier character, and while it is 
             conventionally used to mark "keywords", the parser does not assign any 
             special meaning to it.
             <para/>
             "," and ";" are not considered operators; rather they are separators, and
             they cannot be combined with operators. For example, "?,!" is parsed as 
             three separate tokens.
             <para/>
             The following table shows all the precedence levels and associativities
             of the "built-in" LES operators, except `backtick` and the "lambda" 
             operator =&gt;, which is special. Each precedence level has a name, which 
             corresponds to a static field of this class. All binary operators are 
             left-associative unless otherwise specified.
             <ol>
             <li>Substitute: prefix $ . :</li>
             <li>Primary: binary . =:, generic arguments List!(int), suffix ++ --, method calls f(x), indexers a[i]</li>
             <li>NullDot: binary ?. ::</li>
             <li>DoubleBang: binary right-associative !!</li>
             <li>Prefix: prefix ~ ! % ^ &amp; * - + `backtick`</li>
             <li>Power: binary **</li>
             <li>Suffix2: suffix \\</li>
             <li>Multiply: binary * / % \ &gt;&gt; &lt;&lt;</li>
             <li>Add: binary + -</li>
             <li>Arrow: binary right-associative -&gt; &lt;-</li>
             <li>AndBits: binary &amp;</li>
             <li>OrBits: binary | ^</li>
             <li>OrIfNull: binary ??</li>
             <li>PrefixDots: prefix ..</li>
             <li>Range: binary right-associative ..</li>
             <li>Compare: binary != == &gt;= &gt; &lt; &lt;=</li>
             <li>And: binary &amp;&amp;</li>
             <li>Or: binary || ^^</li>
             <li>IfElse: binary right-associative ? :</li>
             <li>Assign: binary right-associative =</li>
             <li>PrefixOr: |</li>
             </ol>
             Not listed in table: binary =&gt; ~ &lt;&gt; `backtick`; prefix / \ &lt; &gt; ? =
             <para/>
             Notice that the precedence of an operator depends on how it is used. The 
             prefix operator '-' has higher precedence than the binary operator '-', 
             so for example <c>- y * z</c> is parsed as <c>(- y) * z</c>, while 
             <c>x - y * z</c> is parsed as <c>x - (y * z)</c>.
             <para/>
             The Lambda operator =&gt;, which is right-associative, has a precedence 
             level above Multiply on the left side, but below Assign on the right 
             side. For example, the expression <c>a = b =&gt; c = d</c> is parsed as 
             <c>a = (b =&gt; (c = d))</c>, and similarly <c>a + b =&gt; c + d</c> is parsed 
             as <c>a + (b =&gt; (c + d))</c>, but <c>a ** b =&gt; c ** d</c> is parsed
             <c>(a ** b) =&gt; (c ** d)</c>. The idea of two different precedences on the
             two sides of an operator may seem strange; see the documentation of 
             <see cref="T:Loyc.Syntax.Precedence"/> for more explanation.
             <para/>
             In addition to these, the binary `backtick` operators have a 
             "precedence range" that is above Compare and below Power. This means that 
             they are immiscible with the Multiply, Add, Arrow, AndBits, OrBits, 
             OrIfNull, PrefixDots, and Range operators, as explained in the 
             documentation of <see cref="T:Loyc.Syntax.Precedence"/>. 
             <para/>
             After constructing an initial table based on common operators from other
             languages, I noticed that 
             <ul>
             <li>All the suffix operators (++ --) had the same precedence, so
             I added \...\ as an extra suffix operator with a lower precedence
             (but, not seeing a purpose for low-precedence suffixes, it's still
             above * and /.)</li>
             <li>None of the high-precedence operators were right-associative, so I 
             added the !! operator to "fill in the gap".</li>
             <li>There were no prefix operators with low precedence, so I added ".." 
             whose precedence is just above binary "..", and "|" which has a precedence 
             lower than anything except attributes (this "operator" is inspired by
             Nemerle, which uses "|" in pattern matching and variants.)</li>
             </ul>
             I also wanted to have a little "room to grow"--to defer the precedence 
             decision to a future time for some operators. So the precedence of the 
             binary operators ~ and &lt;&gt; is constrained to be above Compare and below 
             NullDot; mixing one of these operators with any operator in this range 
             will produce a "soft" parse error (meaning that parsing still proceeds 
             but the exact precedence is undefined.)
             <para/>
             The operators / \ &lt; &gt; ? = can be used as prefix operators, but their
             precedence is is similarly undefined (but definitely above Compare and
             below NullDot).
             <para/>
             The way that low-precedence prefix operators are parsed deserves some 
             discussion... TODO.
             <para/>
             Most operators can have two roles. Most operators can either be 
             binary operators or prefix operators; for example, <c>!*!</c> is a 
             binary operator in <c>x !*! y</c> but a prefix operator in <c>x + !*! y</c>.
             <para/>
             The operators <c>++ --</c> also have two roles, but different roles: 
             they can be either prefix or suffix operators, but not binary operators.
             For example, <c>-*-</c> is a suffix operator in <c>x -*- + y</c> and a 
             prefix operator in <c>x + -*- y</c>. Please note that <c>x -*- y</c> is 
             ambiguous (it could be parsed as either of two superexpressions, 
             <c>(x -*-) (y)</c> or <c>(x) (-*- y)</c>) and it is illegal.
             <para/>
             Operators that end with $ can only be prefix operators (not binary or 
             suffix). Operators that start and end with \ can only be suffix (not 
             binary or prefix) operators. Having only a single role makes these 
             operators unambiguous inside superexpressions.
             <para/>
             An operator cannot have all three roles (suffix, prefix and binary); that 
             would be overly ambiguous. For example, if "-" could also be a suffix 
             operator then <c>x - + y</c> could be parsed as <c>(x -) + y</c> as well 
             as <c>x - (+ y)</c>. More subtly, LES does not define any operators that
             could take binary or suffix roles, because that would also be ambiguous. 
             For example, suppose <c>|?|</c> is a binary or suffix operator, but not a 
             prefix operator. Clearly <c>x |?| y</c> and <c>x |?| |?| y</c> are 
             unambiguous, but <c>x |?| + y</c> is ambiguous: it could be parsed as 
             <c>(x |?|) + y</c> or <c>x |?| (+ y)</c>. It turns out that a computer 
             language can contain operators that serve as binary and prefix operators, 
             OR it can contain operators that serve as binary and suffix operators, 
             but a language is ambiguous if it has both kinds of operators at the 
             same time.
            
             <h3>How to detect an operator's precedence</h3>
             
             To determine the precedence of any given operator, first you must
             decide, mainly based on the context in which the operator appears and the
             text of the operator, whether it is a prefix, binary, or suffix operator. 
             Suffix operators can only be derived from the operators <c>++, --, \\</c>
             ("derived" means that you can add additional operator characters in the 
             middle, e.g. <c>+++</c> and <c>-%-</c> are can be prefix or suffix 
             operators.)
             <para/>
             If an operator starts with a backslash (\), the backslash is not considered 
             part of the operator name and it not used for the purpose of choosing 
             precedence either (rather, it is used to allow letters and digits in the 
             operator name). A `backquoted` operator always has precedence of 
             <see cref="F:Loyc.Syntax.Les.LesPrecedence.Backtick"/> and again, the backticks are not considered part
             of the operator name.
             <para/>
             Next, if the operator is only one character, simply find it 
             in the above table. If the operator is two or more characters, take the 
             first character A and the last character Z, and apply the following rules 
             in order:
             <ol>
             <li>If the operator is binary and it is exactly equal to "&gt;=" or "&lt;=" 
             or "!=", the precedence is Compare.</li>
             <li>If the operator is binary, A is NOT '=', and Z is '=', then the 
             precedence is Assign.</li>
             <li>Look for an operator named AZ. If it is defined, the operator 
             will have the same precedence. For example, binary "=|&gt;" has the same 
             precedence as binary "=&gt;".</li>
             <li>Otherwise, look for an entry in the table for Z. For example,
             binary "%+" has the same precedence as binary "+" and unary "%+" has
             the same precedence as unary "+".</li>
             <li>If no other rule applies (e.g. \word-operator), use Reserved for
             punctuation-based operators with undefined precedence and BackslashWord
             for all other operators (which will have started with a backslash).</li>
             </ol>
             The first two rules are special cases that exist for the sake of the 
             shift operators, so that "&gt;&gt;=" has the same precedence as "=" instead 
             of "&gt;=".
             <para/>
             Please note that the plain colon ':' is not treated as an operator at
             statement level; it is assumed to introduce a nested block, as in the 
             languages Python and boo (e.g. in "if x: y();" is interpreted as 
             "if x { y(); }"). However, ':' is allowed as an operator inside a 
             parenthesized expression. ([June 2014] Python-style blocks are not
             yet implemented.)
             <para/>
             The double-colon :: has the "wrong" precedence according to C# and C++
             rules; <c>a.b::c.d</c> is parsed <c>(a.b)::(c.d)</c> although it would 
             be parsed <c>((a.b)::c).d</c> in C# and C++. The change in precedence 
             allows double colon to be used for variable declarations in LeMP, as 
             in <c>x::System.Drawing.Point</c>. The lower precedence allows this
             to be parsed properly, but it sacrifices full fidelity with C#/C++.
             <para/>
             There are no ternary operators in LES. '?' and ':' are right-associative 
             binary operators, so <c>c ? a : b</c> is parsed as <c>c ? (a : b)</c>.
             The lack of an official ternary operator reduces the complexity of the
             parser; C-style conditional expressions could still be parsed in LEL 
             with the help of a macro, but they are generally not necessary since the 
             if-else superexpression is preferred: <c>if c a else b</c>.
             <para/>
             I suppose I should also mention the way operators map to function names.
             In LES, there is no semantic distinction between operators and functions;
             <c>x += y</c> is equivalent to the function call <c>@+=(x, y)</c>, and 
             the actual name of the function is "+=" (the @ character informs the 
             lexer that a special identifier name follows.) Thus, the name of most 
             operators exactly matches the operator; the + operator is named "+",
             the |*| operator is named "|*|", and so forth. There are a couple of 
             exceptions:
             <ul>
             <li>While prefix ++ and -- are named "++" and "--", the suffix versions
             are named "suf++" and "suf--" to distinguish them.</li>
             <li>The backslash is stripped from operators that start with a backslash.
             So \+ is named "+" and \foo\ is named "foo\". \+ means the same thing as 
             the normal + operator, it just has a different precedence. However, a 
             single backslash (\) followed by whitespace is named "\".</li>
             <li>For operators surrounded by `backquotes`, the backquotes are not 
             part of the name either; \&gt; and `&gt;` and &gt; differ only in precedence.</li>
             </ul>
             </remarks>
             <seealso cref="T:Loyc.Syntax.Precedence"/>
        </member>
        <member name="T:Loyc.Syntax.Les.LesPrecedenceMap">
            <summary>This class's main job is to maintain a table of 
            <see cref="T:Loyc.Syntax.Precedence"/> values for LES operators. When you ask about a
            new operator, its precedence is cached for future reference.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.LesPrecedenceMap.Reset">
            <summary>Forgets previously encountered operators to save memory.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.LesPrecedenceMap.Find(Loyc.Syntax.OperatorShape,System.Object,System.Boolean)">
            <summary>Gets the precedence of a prefix, suffix, or infix operator in 
            LES, under the assumption that the operator isn't surrounded in 
            backticks (in which case its precedence is always Backtick).</summary>
            <param name="op">Parsed form of the operator. op must be a Symbol, but 
            the parameter has type object to avoid casting Token.Value in the parser.</param>
        </member>
        <member name="M:Loyc.Syntax.Les.LesPrecedenceMap.IsOpChar(System.Char)">
            <summary>Returns true if this character is one of those that operators are normally made out of in LES.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.LesPrecedenceMap.IsNaturalOperator(Loyc.Symbol)">
            <summary>Returns true if the given Symbol can be printed as an operator 
            without escaping it.</summary>
            <remarks>The parser should read something like <c>+/*</c> as an operator
            with three characters, rather than "+" and a comment, but the printer 
            should be conservative, so this function returns false in such a case:
            "Be liberal in what you accept, and conservative in what you produce."</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.LesPrecedenceMap.ToSuffixOpName(System.Object)">
            <summary>Given a normal operator symbol like <c>(Symbol)"++"</c>, gets
            the suffix form of the name, such as <c>(Symbol)"suf++"</c>.</summary>
            <remarks>op must be a Symbol, but the parameter has type object to avoid casting Token.Value in the parser.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Les.LesPrecedenceMap.IsSuffixOperatorName(Loyc.Symbol,Loyc.Symbol@,System.Boolean)">
            <summary>Decides whether the name appears to represent a suffix operator 
            of the form <c>sufOP</c> or <c>OP\</c>.</summary>
            <param name="name">Potential operator name to evaluate.</param>
            <param name="bareName">If the name starts with "suf", this is the same 
            name without "suf", otherwise it is set to <c>name</c> itself. This
            output is calculated even if the function returns false.</param>
            <param name="checkNatural">If true, part of the requirement for 
            returning true will be that IsNaturalOperator(bareName) == true.</param>
        </member>
        <member name="T:Loyc.Syntax.Les.TokenExt">
            <summary>Provides the <c>Type()</c> extension method required by 
            <see cref="T:Loyc.Syntax.Lexing.Token"/> and the ToString(Token) method to express an LES token
            as a string, for tokens that contain sufficient information to do so.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.TokenExt.Type(Loyc.Syntax.Lexing.Token)">
            <summary>Converts <c>t.TypeInt</c> to <see cref="T:Loyc.Syntax.Les.TokenType"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Les.TokenExt.ToString(Loyc.Syntax.Lexing.Token)">
            <summary>Expresses an LES token as a string.</summary>
            <remarks>Note that some Tokens do not contain enough information to
            reconstruct a useful token string, e.g. comment tokens do not store the 
            comment but merely contain the location of the comment in the source code.
            For performance reasons, a <see cref="T:Loyc.Syntax.Lexing.Token"/> does not have a reference 
            to its source file, so this method cannot return the original string.
            <para/>
            The results are undefined if the token was not produced by <see cref="T:Loyc.Syntax.Les.LesLexer"/>.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.BaseLexer">
            <summary>Alias for <see cref="T:Loyc.Syntax.Lexing.BaseLexer`1"/> where C is <see cref="T:Loyc.Collections.ICharSource"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ILllpgApi`3">
            <summary>For reference purposes, this interface is a list of the non-static 
            methods that LLLPG expects to be able to call when it is generating code. 
            LLLPG does not actually need lexers and parsers to implement this interface;
            they simply need to implement the same set of methods as this interface 
            contains.</summary>
            <typeparam name="Token">The return value of the Match methods. LLLPG does 
            not care and does not need to know what this type is. In lexers, these 
            methods typically return the character that was matched (i.e. int, because
            EOF is -1), and in parsers they should return the token that was matched.</typeparam>
            <typeparam name="MatchType">The data type of arguments to Match, 
            MatchExcept, TryMatch and TryMatchExcept. In lexers, MatchType is always 
            int. In parsers, by default, LLLPG generates code as though MatchType is 
            same as LaType, but one often uses int instead, e.g. because enums do not
            implement <see cref="T:System.IEquatable`1"/> as required by 
            <see cref="T:Loyc.Syntax.BaseParser`2"/>. you're using
            <see cref="T:Loyc.Syntax.BaseParser`2"/> with LaType=int token 
            type is an enum, which for some reason does not implement 
            IEquatable{T}. So, often, when using BaseParser{Token you need to use the matchType(int) 
            option to change MatchType to int.</typeparam>
            <typeparam name="LaType">The data type of LA0 and LA(i). This is always int 
            in lexers, but in parsers you can use the laType(...) option to change this 
            type.</typeparam>
            <seealso cref="T:Loyc.Syntax.Lexing.ILllpgLexerApi`1"/>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ILllpgLexerApi`1">
            <summary>For reference purposes, this interface contains the non-static 
            methods that LLLPG expects lexers to implement. LLLPG does not actually 
            expect lexers to implement this interface; they simply need to implement 
            the same set of methods as this interface contains.</summary>
            <typeparam name="Token">The return value of the Match() methods, which is
            the input value (character) actually encountered in the stream. This type 
            is usually int.</typeparam>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerSource`1">
            <summary>An implementation of the LLLPG Lexer API, used with the LLLPG
            options <c>inputSource</c> and <c>inputClass</c>.</summary>
            <remarks>
            This derived class simply makes public all of the LLLPG APIs which are 
            marked protected in <see cref="T:Loyc.Syntax.Lexing.BaseLexer`1"/>.
            </remarks>
            <example>
            LLLPG(lexer(inputSource(src), inputClass(LexerSource))) {
            	static rule int ParseInt(string input) {
            		var src = (LexerSource&lt;UString&gt;)input;
            		@[ (d:='0'..'9' {$result = $result * 10 + (d - '0');})+ ];
            	}
            }
            </example>
            <typeparam name="CharSrc">A class that implements ICharSource. In order
            to write lexers that can accept any source of characters, set 
            CharSrc=ICharSource. For maximum performance when parsing strings (or
            to avoid memory allocation), set CharSrc=UString (<see cref="T:Loyc.UString"/> 
            is a wrapper around <c>System.String</c> that, among other things, 
            implements <c>ICharSource</c>; please note that C# will implicitly convert 
            normal strings to <see cref="T:Loyc.UString"/> for you).</typeparam>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerSourceWorkaround`1">
            <summary>This class only exists to work around a limitation of the C# language:
            "cannot change access modifiers when overriding 'protected' inherited member Error(...)".</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>Initializes LexerSource.</summary>
            <param name="source">A source of characters, e.g. <see cref="T:Loyc.UString"/>.</param>
            <param name="fileName">A file name associated with the characters, 
            which will be used for error reporting.</param>
            <param name="inputPosition">A location to start lexing (normally 0).
            Careful: If you're starting to lex in the middle of the file, the 
            <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> still starts at 1, and (if <c>newSourceFile</c>
            is true) the <see cref="P:Loyc.Syntax.Lexing.LexerSource`1.SourceFile"/> object may or may not discover 
            line breaks prior to the starting point, depending on how it is used.</param>
            <param name="newSourceFile">Whether to create a <see cref="T:Loyc.Syntax.Lexing.LexerSourceFile`1"/>
            object (an implementation of <see cref="T:Loyc.Syntax.ISourceFile"/>) to keep track 
            of line boundaries. The <see cref="P:Loyc.Syntax.Lexing.LexerSource`1.SourceFile"/> property will point
            to this object, and it will be null if this parameter is false. Using 
            'false' will avoid memory allocation, but prevent you from mapping 
            character positions to line numbers and vice versa. However, this
            object will still keep track of the current <see cref="P:Loyc.Syntax.Lexing.BaseLexer`1.LineNumber"/> 
            and <see cref="P:Loyc.Syntax.Lexing.LexerSource`1.LineStartAt"/> (the index where the current line started) 
            when this parameter is false.</param>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.Reset(`0,System.String,System.Int32,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.Skip">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.AfterNewline">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.Newline">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSource`1.PrintChar(System.Int32,System.Text.StringBuilder)">
            <inheritdoc/>
        </member>
        <member name="P:Loyc.Syntax.Lexing.LexerSource`1.LineStartAt">
            <inheritdoc/>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerSource">
            <summary>A synonym for <see cref="T:Loyc.Syntax.Lexing.LexerSource`1"/> where C is <see cref="T:Loyc.Collections.ICharSource"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.LexerSourceFile`1">
            <summary>Adds the <see cref="M:Loyc.Syntax.Lexing.LexerSourceFile`1.AfterNewline(System.Int32)"/> method to <see cref="T:Loyc.Syntax.SourceFile"/>.</summary>
            <remarks>
            When implementing a lexer, the most efficient approach to building the list
            of line breaks is to save the location of each newline as it is encountered 
            while lexing, rather than doing a separate pass over the file just to find 
            line breaks. This class supports this optimization.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.SourceFile`1">
            <summary>A default implementation of ISourceFile based on <see cref="T:Loyc.Syntax.IndexPositionMapper"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.IndexPositionMapper`1">
            <summary>
            Helper class for mapping from indexes to SourcePos and back.
            </summary><remarks>
            This class's job is to keep track of the locations of line breaks in order
            to map from indices to SourcePos objects or vice versa. Converting indexes 
            to SourcePos is commonly needed for error reporting; lexers, parsers and 
            code analyzers typically use indexes (simple integers) internally, but must
            convert to SourcePos in order to communicate with the end user. Occasionally
            one may wish to convert in the reverse direction also (SourcePos to index).
            <para/>
            Line breaks themselves are classified as being at the end of each line.
            So if the file is "Bob\nJoe", <c>IndexToLine(3).Line == 1</c>, not 2.
            <para/>
            The outputs are immutable and this class assumes the input file never 
            changes. However, this class is not entirly multi-thread-safe until the 
            entire input file or string has been scanned, since the list of line breaks
            is built on-demand, without locking.
            </remarks>
            <typeparam name="CharSource">A type that implements <c>IListSource(Char)</c>.
            Originally this class did not have any type parameters and dealt with
            <c>IListSource(Char)</c>, but it was made generic so that one could wrap
            value types such as <c>UString</c> without boxing.
            </typeparam>
        </member>
        <member name="T:Loyc.Syntax.IIndexPositionMapper">
            <summary>
            This interface is for classes that can convert indexes to SourcePos
            structures and back.
            </summary>
        </member>
        <member name="M:Loyc.Syntax.IIndexPositionMapper.LineToIndex(System.Int32)">
            <summary>Returns the index in a source file of the beginning of the 
            specified line, where the first line is number 1, not 0.</summary>
            <remarks>If lineNo is zero, this method should return -1 (signifying 
            an unknown location). If lineNo is larger than the largest line 
            number, this method should return the index of end-of-file.</remarks>
        </member>
        <member name="M:Loyc.Syntax.IndexPositionMapper`1.#ctor(`0,Loyc.Syntax.SourcePos)">
            <summary>Initializes CharIndexPositionMapper.</summary>
            <param name="source">An immutable list of characters.</param>
            <param name="startingPos">Optional. The first character of <c>source</c> 
            will be considered to have the file name and line number specified by 
            this object. If this is null, IndexToLine() will return a blank file 
            name ("").</param>
        </member>
        <member name="M:Loyc.Syntax.IndexPositionMapper`1.Reset(`0,System.String)">
            <summary>Reinitializes the object (as though the constructor were called again).</summary>
        </member>
        <member name="T:Loyc.Syntax.ISourceFile">
            <summary>Represents a text file with a file name and its textual content,
            plus the data necessary to convert between line-column positions and 
            0-based integer indexes.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.LexerSourceFile`1.AfterNewline(System.Int32)">
            <summary>Allows a lexer to record the index of the character after 
            each line break, in the order they exist in the file or string.</summary>
            <param name="index">Index of the first character after the newline.</param>
            <remarks>
            A lexer is not required to call this method; if the lexer doesn't call 
            it, the list of line breaks (which is used to map indexes to line 
            numbers and vice versa) will be built on-demand when one calls methods
            such as <c>IndexToLine</c>.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TokenListAsLexer">
            <summary>Adapter: converts <c>IEnumerable(Token)</c> to the <see cref="T:Loyc.Syntax.Lexing.ILexer`1"/> interface.</summary>
            <remarks>
            The LineNumber property is computed on-demand by the <see cref="T:Loyc.Syntax.ISourceFile"/> provided.
            <para/>
            TODO: IndentLevel, IndentString do not work.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TokenTree">
            <summary>A list of Token structures along with the <see cref="T:Loyc.Syntax.ISourceFile"/> 
            object that represents the source file that the tokens came from.</summary>
            <remarks>This class is called <c>TokenTree</c> because certain kinds of 
            tokens used by some parsers are formed into trees by using <see cref="T:Loyc.Syntax.Lexing.TokenTree"/> 
            as the type of the <see cref="F:Loyc.Syntax.Lexing.Token.Value"/> of certain tokens. Specifically,
            the LES and EC# parsers expect open-bracket and open-brace tokens ('(', 
            '[' and '{') to have a child <see cref="T:Loyc.Syntax.Lexing.TokenTree"/> that contains all the 
            tokens within a pair of brackets or braces. Typically this tree is not 
            created directly by the lexer, but by a helper class (<see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>).
            <para/>
            Caution: this class is mutable, even though TokenTrees are sometimes stored
            in <see cref="T:Loyc.Syntax.LNode"/>s which are supposed to be immutable. Please do not
            modify token trees that are stored inside LNodes.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TokenTree.Clone">
            <summary>Gets a deep (recursive) clone of the token tree.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TokenTree.Equals(Loyc.Syntax.Lexing.TokenTree)">
            <summary>Compares the elements of the token tree for equality.</summary>
            <remarks>Because <see cref="T:Loyc.Syntax.LNode"/>s are compared by value and not by 
            reference, and LNodes can contain TokenTrees, TokenTrees should also be
            compared by value.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TokenTree.ToLNodes">
            <summary>Converts this list of <see cref="T:Loyc.Syntax.Lexing.Token"/> to a list of <see cref="T:Loyc.Syntax.LNode"/>.</summary>
            <remarks>See <see cref="M:Loyc.Syntax.Lexing.Token.ToLNode(Loyc.Syntax.ISourceFile)"/> for more information.</remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.TokenTree.Flatten">
            <summary>Converts a token tree back to a plain list.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.WhitespaceTag">
            <summary><see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/> can be used as the
            <see cref="F:Loyc.Syntax.Lexing.Token.Value"/> of whitespace tokens, to make whitespace
            easy to filter out.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.Token">
            <summary>
            A common token type recommended for Loyc languages that want to use 
            features such as token literals or the <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/> class.
            </summary>
            <remarks>
            For performance reasons, a Token ought to be a structure rather than
            a class. But if Token is a struct, we have a conundrum: how do we support 
            tokens from different languages? We can't use inheritance since structs
            do not support it. When EC# is ready, we could use a single struct plus
            an alias for each language, but of course this structure predates the 
            implementation of EC#.
            <para/>
            Luckily, tokens in most languages are very similar. A four-word structure
            generally suffices:
            <ol>
            <li><see cref="F:Loyc.Syntax.Lexing.Token.TypeInt"/>: each language can use a different set of token types 
            represented by a different <c>enum</c>. All enums can be converted to 
            an integer, so <see cref="T:Loyc.Syntax.Lexing.Token"/> uses Int32 as the token type. In order
            to support DSLs via token literals (e.g. LLLPG is a DSL inside EC#), the
            TypeInt should be based on <see cref="T:Loyc.Syntax.Lexing.TokenKind"/>.</li>
            <li><see cref="F:Loyc.Syntax.Lexing.Token.Value"/>: this can be any object. For literals, this should 
            be the actual value of the literal, for whitespace it should be 
            <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/>, etc. See <see cref="F:Loyc.Syntax.Lexing.Token.Value"/> for 
            the complete list.</li>
            <li><see cref="F:Loyc.Syntax.Lexing.Token.StartIndex"/>: location in the original source file where 
            the token starts.</li>
            <li><see cref="P:Loyc.Syntax.Lexing.Token.Length"/>: length of the token in the source file (24 bits).</li>
            <li><see cref="P:Loyc.Syntax.Lexing.Token.Style"/>: 8 bits for other information.</li>
            </ol>
            Originally I planned to use <see cref="T:Loyc.Symbol"/> as the common token 
            type, because it is extensible and could nicely represent tokens in all
            languages; unfortunately, Symbol may reduce parsing performance because 
            it cannot be used with the switch opcode (i.e. the switch statement in 
            C#), so I decided to switch to integers instead and to introduce the 
            concept of <see cref="T:Loyc.Syntax.Lexing.TokenKind"/>, which is derived from 
            <see cref="T:System.Type"/> using <see cref="F:Loyc.Syntax.Lexing.TokenKind.KindMask"/>.
            Each language should have, in the namespace of that language, an
            extension method <c>public static TokenType Type(this Token t)</c> that 
            converts the TypeInt to the enum type for that language.
            <para/>
            To save space (and because .NET doesn't handle large structures well),
            tokens do not know what source file they came from and cannot convert 
            their location to a line number. For this reason, one should keep a
            reference to the <see cref="T:Loyc.Syntax.ISourceFile"/> and call <see cref="M:Loyc.Syntax.IIndexToLine.IndexToLine(System.Int32)"/> 
            to get the source location.
            <para/>
            A generic token also cannot convert itself to a properly-formatted 
            string. The <see cref="M:Loyc.Syntax.Lexing.Token.ToString"/> method does allow 
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.Lexing.IToken`1">
            <summary>The methods of <see cref="T:Loyc.Syntax.Lexing.Token"/> in the form of an interface.</summary>
            <typeparam name="TT">Token Type: the data type of the Type property of 
            <see cref="T:Loyc.Syntax.Lexing.ISimpleToken`1"/> (one often uses int).</typeparam>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ISimpleToken`1">
            <summary>Basic information about a token as expected by <see cref="T:Loyc.Syntax.BaseParser`1"/>:
            a token <see cref="P:Loyc.Syntax.Lexing.ISimpleToken`1.Type"/>, which is the type of a "word" in the program 
            (string, identifier, plus sign, etc.), a value (e.g. the name of an 
            identifier), and an index where the token starts in the source file.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ISimpleToken`1.Type">
            <summary>The category of the token (integer, keyword, etc.) used as
            the primary value for identifying the token in a parser.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.ISimpleToken`1.StartIndex">
            <summary>Character index where the token starts in the source file.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.Token.TypeInt">
            <summary>Token type.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.Token.StartIndex">
            <summary>Location in the orginal source file where the token starts, or
            -1 for a synthetic token.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.Token.Value">
            <summary>The parsed value of the token.</summary>
            <remarks>The value is
            <ul>
            <li>For strings: the parsed value of the string (no quotes, escape 
            sequences removed), i.e. a boxed char or string. A backquoted string 
            is converted to a Symbol because it is a kind of operator.</li>
            <li>For numbers: the parsed value of the number (e.g. 4 =&gt; int, 4L =&gt; long, 4.0f =&gt; float)</li>
            <li>For identifiers: the parsed name of the identifier, as a Symbol 
            (e.g. x =&gt; x, @for =&gt; for, @`1+1` =&gt; <c>1+1</c>)</li>
            <li>For any keyword including AttrKeyword and TypeKeyword tokens: a 
            Symbol containing the name of the keyword, with "#" prefix</li>
            <li>For punctuation and operators: the text of the punctuation as a 
            symbol (with '#' in front, if the language conventionally uses this 
            prefix)</li>
            <li>For openers (open paren, open brace, etc.) after the tokens have
            been processed by <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>: a TokenTree object.</li>
            <li>For spaces and comments: <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/></li>
            <li>When no value is needed (because the Type() is enough): null</li>
            </ul>
            For performance reasons, the text of whitespace is not extracted from
            the source file; <see cref="F:Loyc.Syntax.Lexing.Token.Value"/> is WhitespaceTag.Value for 
            whitespace. Value must be assigned for other types such as 
            identifiers and literals.
            <para/>
            Since the same identifiers and literals are often used more than once 
            in a given source file, an optimized lexer could use a data structure 
            such as a trie or hashtable to cache boxed literals and identifier 
            symbols, and re-use the same values when the same identifiers and 
            literals are encountered multiple times. Done carefully, this avoids 
            the overhead of repeatedly extracting string objects from the source 
            file. If strings must be extracted for some reason (e.g. <c>
            double.TryParse</c> requires an extracted string), at least memory can 
            be saved.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.Is(System.Int32,System.Object)">
            <summary>Returns true if the specified type and value match this token.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.Range(Loyc.Syntax.ISourceFile)">
            <summary>Gets the <see cref="T:Loyc.Syntax.SourceRange"/> of a token, under the 
            assumption that the token came from the specified source file.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.SourceText(Loyc.Collections.ICharSource)">
            <summary>Gets the original source text for a token if available, under the 
            assumption that the specified source file correctly specifies where the
            token came from. If the token is synthetic, returns <see cref="F:Loyc.UString.Null"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.ToString">
            <summary>Reconstructs a string that represents the token, if possible.
            Does not work for whitespace and comments, because the value of these
            token types is stored in the original source file and for performance 
            reasons is not copied to the token.</summary>
            <remarks>
            This does <i>not</i> return the original source text; it uses a language-
            specific stringizer (<see cref="P:Loyc.Syntax.Lexing.Token.ToStringStrategy"/>).
            <para/>
            The returned string, in general, will not match the original
            token, since the <see cref="P:Loyc.Syntax.Lexing.Token.ToStringStrategy"/> does not have access to
            the original source file.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.Equals(Loyc.Syntax.Lexing.Token)">
            <summary>Equality depends on TypeInt and Value, but not StartIndex and 
            Length (this is the same equality condition as <see cref="T:Loyc.Syntax.LNode"/>).</summary>
        </member>
        <member name="M:Loyc.Syntax.Lexing.Token.ToLNode(Loyc.Syntax.ISourceFile)">
            <summary>Converts a <see cref="T:Loyc.Syntax.Lexing.Token"/> to a <see cref="T:Loyc.Syntax.LNode"/>.</summary>
            <param name="file">This becomes the <see cref="P:Loyc.Syntax.LNode.Source"/> property.</param>
            <remarks>If you really need to store tokens as LNodes, use this. Only
            the <see cref="P:Loyc.Syntax.Lexing.Token.Kind"/>, not the TypeInt, is preserved. Identifiers 
            (where Kind==TokenKind.Id and Value is Symbol) are translated as Id 
            nodes; everything else is translated as a call, using the TokenKind as
            the <see cref="P:Loyc.Syntax.LNode.Name"/> and the value, if any, as parameters. For
            example, if it has been treeified with <see cref="T:Loyc.Syntax.Lexing.TokensToTree"/>, the
            token list for <c>"Nodes".Substring(1, 3)</c> as parsed by LES might 
            translate to the LNode sequence <c>String("Nodes"), Dot(@@.), 
            Substring, LParam(Number(1), Separator(@@,), Number(3)), RParen()</c>.
            The <see cref="P:Loyc.Syntax.LNode.Range"/> will match the range of the token.
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Kind">
            <summary>Token kind.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Length">
            <summary>Length of the token in the source file, or 0 for a synthetic 
            or implied token.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Style">
            <summary>8 bits of nonsemantic information about the token. The style 
            is used to distinguish hex literals from decimal literals, or triple-
            quoted strings from double-quoted strings.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.Children">
            <summary>Returns Value as TokenTree (null if not a TokenTree).</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.EndIndex">
            <summary>Returns StartIndex + Length.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.IsWhitespace">
            <summary>Returns true if Value == <see cref="F:Loyc.Syntax.Lexing.WhitespaceTag.Value"/>.</summary>
        </member>
        <member name="P:Loyc.Syntax.Lexing.Token.ToStringStrategy">
            <summary>Gets or sets the strategy used by <see cref="M:Loyc.Syntax.Lexing.Token.ToString"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.ISimpleToken">
            <summary>Alias for ISimpleToken{int}.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TokenKind">
            <summary>A list of token categories that most programming languages have.</summary>
            <remarks>
            Some Loyc languages will support the concept of a "token literal" which
            is a <see cref="T:Loyc.Syntax.Lexing.TokenTree"/>, and some DSLs will rely on these token 
            literals for input. However, tokens differ between different languages; 
            for instance the set of operators varies between languages. On the other 
            hand, most languages do have some concept of "an operator" and "an 
            identifier", and the TokenKind reflects this fact.
            <para/>
            When you are using <see cref="T:Loyc.Syntax.Lexing.Token"/> to represent tokens in your language,
            it is recommended to define every value of your "TokenType" enumeration in 
            terms of TokenKind using integer offsets, like this:
            <pre>
            enum MyTokenType {
                EOF         = TokenKind.Spaces,
                Id          = TokenKind.Id,
                IfKeyword   = TokenKind.OtherKeyword,
                ForKeyword  = TokenKind.OtherKeyword + 1,
                LoopKeyword = TokenKind.OtherKeyword + 2,
                ...
                MulOp   = TokenKind.Operator,
                AddOp   = TokenKind.Operator + 1,
                DivOp   = TokenKind.Operator + 2,
                DotOp   = TokenKind.Dot,
                ...
            }
            </pre>
            Using TokenKind is only important if you intend to support DSLs via token
            literals (e.g. LLLPG) in your language.
            <para/>
            A DSL that just needs simple tokens like "strings", "identifiers" and "dots" 
            can write a parser based on values of <see cref="P:Loyc.Syntax.Lexing.Token.Kind"/> alone; if 
            it needs certain specific operators or "keywords" that do not have a 
            dedicated TokenKind, such as + and %, it can further check the Value of the 
            token; meanwhile, the host language put a global <see cref="T:Loyc.Symbol"/> 
            in the <see cref="F:Loyc.Syntax.Lexing.Token.Value"/> to represent operators, keywords and 
            identifiers.
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Spaces">
            <summary>Spaces, tabs, non-semantic newlines, and EOF</summary>
            <remarks>Spaces and comments are typically filtered out before parsing and will not appear in token literals.</remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Comment">
            <summary>Single- and multi-line comments</summary>
            <remarks>Spaces and comments are typically filtered out before parsing and will not appear in token literals.</remarks>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Id">
            <summary>Simple identifiers</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Literal">
            <summary>Literals, such as numbers and strings.</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Dot">
            <summary>Scope operator (dot and dot-like ops such as :: in C++) </summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Assignment">
            <summary>Simple or compound assignment</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Operator">
            <summary>All operators except assignment, dot, or separators</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Separator">
            <summary>e.g. semicolon, comma (if not considered an operator)</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.AttrKeyword">
            <summary>e.g. public, private, static, virtual</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.TypeKeyword">
            <summary>e.g. int, bool, double, void</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.OtherKeyword">
            <summary>e.g. sizeof, struct</summary>
        </member>
        <member name="F:Loyc.Syntax.Lexing.TokenKind.Other">
            <summary>For token types not covered by other token kinds.</summary>
        </member>
        <member name="T:Loyc.Syntax.Lexing.TokensToTree">
            <summary>
            A preprocessor usually inserted between the lexer and parser that converts 
            a token list into a token tree. Everything inside brackets, parens or 
            braces is made a child of the open bracket.
            </summary>
            <remarks>
            The close bracketis not treated as one of the children of the opening bracket.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.IdNode">
            <summary>Base class of all nodes that represent simple identifiers (including special symbols such as #foo).</summary>
        </member>
        <member name="T:Loyc.Syntax.LNode">
             <summary>All nodes in a Loyc syntax tree share this base class.</summary>
             <remarks>
             Loyc defines only three types of nodes: simple symbols, literals, and calls.
             <ul>
             <li>A <see cref="T:Loyc.Syntax.IdNode"/> is a simple identifier, such as a VariableName</li>
             <li>A <see cref="T:Loyc.Syntax.LiteralNode"/> is a literal constant, such as 123 or "hello"</li>
             <li>A <see cref="T:Loyc.Syntax.CallNode"/> encompasses all other kinds of nodes, such as
             normal function calls like <c>f(x)</c>, generic specifications like <c>f&lt;x&gt;</c>
             (represented as <c>#of(f, x)</c>), braced blocks of statements (represented as
             <c>@`{}`(stmt1, stmt2, ...)</c>), and so on. Also, parenthesized expressions
             are represented as a call with one argument and <c>null</c> as the <see cref="P:Loyc.Syntax.LNode.Target"/>.</li>
             </ul>
             This class provides access to all properties of all three types of nodes,
             in order to make this class easier to access from plain C#, and to avoid
             unnecessary downcasting in some cases.
             <para/>
             Loyc nodes are always immutable, except for the 8-bit <see cref="P:Loyc.Syntax.LNode.Style"/> 
             property which normally affects printing only.
             <para/>
             <h3>Background information</h3>
             <para/>
             EC# (enhanced C#) is intended to be the starting point of the Loyc 
             (Language of your choice) project, which will be a family of programming
             languages that will share a common representation for the syntax tree and 
             other compiler-related data structures.
             <para/>
             Just as LLVM assembly has emerged as a nearly universal standard 
             intermediate representation for back-ends, Loyc nodes are intended to be a 
             universal intermediate representation for syntax trees, and Loyc will 
             (eventually) include a generic set of tools for semantic analysis so that
             it provides a generic representation for front-ends.
             <para/>
             EC#, then, will be the first language to use the Loyc syntax tree 
             representation, known as the "Loyc tree" for short. Most syntax trees are 
             very strongly typed, with separate data types for, say, variable 
             declarations, binary operators, method calls, method declarations, unary 
             operators, and so forth. Loyc, however, defines only three types of Nodes,
             and this one class provides access to all the parts of a node. There are 
             several reasons for this design:
             <ul>
             <li>Simplicity. Many compilers have thousands of lines of code dedicated 
               to the AST (abstract syntax tree) data structure itself, because each 
               kind of AST node has its own class.</li>
             <li>Serializability. Loyc nodes can always be serialized to a plain text 
               "prefix tree" and deserialized back to objects, even by programs that 
               are not designed to handle the language that the tree represents*. This 
               makes it easy to visualize syntax trees or exchange them between 
               programs.</li>
             <li>Extensibility. Loyc nodes can represent any language imaginable, and
               they are suitable for embedded DSLs (domain-specific languages). Since 
               nodes do not enforce a particular structure, they can be used in 
               different ways than originally envisioned. For example, most languages 
               only have "+" as a binary operator, that is, with two arguments. If  
               Loyc had a separate class for each AST, there would probably be a 
               PlusOperator class derived from BinaryOperator, or something, with 
               properties "Left" and "Right". But since there is only one node class, 
               a "+" operator with three arguments is always possible; this is denoted 
               by #+(a, b, c) in EC# source code.</li>
             </ul>
               * Currently, the only supported languages for plain-text Loyc trees are 
                 LES and EC# (either normal EC# or prefix-tree notation).
             <para/>
             Loyc trees are comparable to LISP trees, except that "attributes" and
             position information are added to the tree, and the concept of a "list" 
             is replaced with the concept of a "call", which I feel is a more 
             intuitive notion in most programming languages that are not LISP.
             <para/>
             Loyc's representation is both an blessing and a curse. The advantage is 
             that Loyc nodes can be used for almost any purpose, perhaps even 
             representing data instead of code in some cases. However, there is no 
             guarantee that a given AST follows the structure prescribed by a particular 
             programming language, unless a special validation step is performed after 
             parsing. In this way, Loyc trees are similar to XML trees, only simpler.
             <para/>
             Another major disadvantage is that it is more difficult to interpret a 
             syntax tree correctly: you have to remember that a method definition has 
             the structure <c>#fn(return_type, name, args, body)</c>, so if "node" is 
             a method definition then <c>node.Args[2]</c> represents the return type, 
             for example. In contrast, most compilers have an AST class called 
             <c>MethodDefinition</c> or something, that provides properties such as 
             Name and ReturnType. Once EC# is developed, however, aliases could help 
             avoid this problem by providing a more friendly veneer over the raw nodes.
             <para/>
             For optimization purposes, the node class is a class hierarchy, but most 
             users should only use this class and perhaps the three derived classes
             <see cref="T:Loyc.Syntax.IdNode"/>, <see cref="T:Loyc.Syntax.LiteralNode"/> and <see cref="T:Loyc.Syntax.CallNode"/>.
             Some users will also find it useful to use <see cref="T:Loyc.Syntax.LNodeFactory"/> for 
             generating synthetic code snippets (bits of code that never existed in any 
             source file), although you can also use the methods defined here in this
             class: <see cref="M:Loyc.Syntax.LNode.Id(Loyc.Symbol,Loyc.Syntax.LNode)"/>(), <see cref="M:Loyc.Syntax.LNode.Literal(System.Object,Loyc.Syntax.LNode)"/>(), <see cref="M:Loyc.Syntax.LNode.Call(Loyc.Symbol,Loyc.Syntax.LNode)"/>(),
             <see cref="M:Loyc.Syntax.LNode.InParens(Loyc.Syntax.LNode)"/>().
             <para/>
             Normal <see cref="T:Loyc.Syntax.LNode"/>s are "persistent" in the comp-sci sense, which 
             means that a subtree can be shared among multiple syntax trees, and nodes
             do not know their own parents. This allows a single node to exist at 
             multiple locations in a syntax tree. This makes manipulation of trees 
             convenient, as there is no need to "detach" a node from one place, or 
             duplicate it, before it can be inserted in another place. Immutable nodes
             can be safely re-used within different source files or multiple versions 
             of one source file in an IDE's "intellisense" or "code completion" engine.
            
             <!-- screws up doxygen
             <h3>Loyc and EC#</h3>
             
             Now let's talk about EC# syntax and how it relates to this class.
             <para/>
             EC# supports a generalized C-style syntax which will be described briefly
             here. Basically, almost any code that a programming student might mistake 
             for real C# code is legal, and there is some odd-looking syntax you've 
             never seen before that is also legal.
             <para/>
             Also, virtually any tree of nodes can be represented in EC# source code 
             using a prefix notation, which helps you understand Loyc ASTs because
             the prefix notation closely corresponds to the AST. For example, 
             @=(x, @*(y, 2)) is equivalent to the expression x = y * 2. This notation 
             tells you that 
             - there are two nodes with two arguments each, 
             - the outer one is named "=" and the inner is named "*"
             The syntax tree built from these two representations is identical.
             <para/>
             Prefix notation can be freely mixed with normal EC# code, although usually 
             there is no reason to do so:
             <para/>
             public Point OneTwo = MakePoint(1, 2);
             public #var(Point, Origin(MakePoint(0, 0)));
             public static #fn(MakePoint, #(int x, int y), System.Drawing.Point, #{
            		return new Point(x, y);
            	});
             <para/>
             The prefix notation often involves special identifiers of the form #X, 
             where X is an identifier (or keyword). In the LES and EC# parsers, the # 
             character is considered a normal part of an identifier, no different than
             a letter (A-Z) or an underscore (_). However, the # is "special" in the
             sense that when a special construct (like a method, or a field declaration)
             is converted to a Loyc tree, the Loyc tree represents that special 
             construct using an identifier that starts with "#".
             <para/>
             Code in prefix notation also often has identifiers of the form @X, where X is
             <ol>
             <li>An operator such as + or ==</li>
             <li>A C# keyword</li>
             <li>A backquoted string</li>
             </ol>
             The @ character is <i>not</i> part of the identifier; it merely indicates
             that the characters after the @ symbol represent an identifier, rather than
             an operator or keyword. For example, "==" is normally an operator, and 
             "class" is normally a keyword, but @== and @class are both identifiers,
             not operators or keywords.
             <para/>
             The following examples show how source code text is translated into symbol names:
             <pre>
             #foo     ==> "#foo"        @>>           ==> ">>"
             #?       ==> "?"           @`{}`         ==> "{}"
             #while   ==> "#while"      @`#Newline\n` ==> "#Newline\n"
             @#while  ==> "#while"      @`hi there!`  ==> "hi there!"
             @while   ==> "while"
             </pre>
             Identifiers that start with # are parsed like normal identifiers, but 
             are reserved for things that have special semantic meaning. For example, 
             "#class" is treated by the parser like any other identifier, but it has
             the same semantic meaning as "class", although a structure defined with 
             "#class" looks quite different from the same structure defined using 
             "class". For example, the following forms are equivalent:
             <pre>
             #class(X, #(), @`{}`(int x));
             class X { int x; }
             </pre>
             The #class(...) form uses prefix notation, and it demonstrates the
             structure of the Loyc tree for a class declaration.
             <para/>
             As another example, "#return(7);" is syntactically a function call to a 
             function called "#return". Although the parser treats it like a function 
             call, it produces the same syntax tree as "return 7;" does.
             <para/>
             Ordinary method calls like <c>Foo(x, y)</c> count as prefix notation, and 
             in EC# there is actually a non-prefix notation for this call: <c>x `Foo` y</c>.
             Both forms are equivalent, but the infix notation can only be used when you
             are calling a method that takes two arguments (also, the string `Foo` should
             be a simple identifier; if it contains a dot, it is treated as part of the
             identifier name, not as a normal dot operator.)
             <para/>
             So #class is a keyword that is parsed like an identifier, but this is 
             different from the notation @class which already exists in plain C#.
             @class is an ordinary identifier that has a "@" sign in front to ensure 
             that the compiler does not treat it like a keyword at all. #class is a 
             special identifier that is parsed like an identifier but then treated like 
             a keyword after parsing is complete.
             <para/>
             In other words, to the parser, @struct and #struct are the same except that 
             the parser removes the @ sign but not the # sign. However, later stages of 
             the compiler treat @struct (now stored without the @ sign) and #struct quite 
             differently, as <c>#struct</c> is treated like a keyword and <c>struct</c> 
             is not.
             <para/>
             Since the "#" character is already reserved in plain C# for preprocessor 
             directives, any node name such as "#if" and "#else" that could be mistaken
             for an old-fashioned preprocessor directive must be preceded by "@" at the 
             beginning of a line. For example, the statement "if (failed) return;" can 
             be represented in prefix notation as "@#if(failed, return)", although the 
             node name of "@#if" is actually "#if" (while the node name of the 
             preprocessor directive "#if" would be "##if", and the node name of "return"
             is actually "#return"). Please note that preprocessor directives themselves 
             are not part of the normal syntax tree, because they can appear 
             midstatement. For example, this is valid C#:
             <pre>
             if (condition1
                #if DEBUG
                   &amp;&amp; condition2
                #endif
                ) return;
             </pre>
             Preprocessor statements will be processed early in the compiler and then 
             deleted.
             <para/>
             The special #X tokens don't require an argument list, although the compiler
             expects most of them to have one (and often it must have a specific length).
             Again, this doesn't matter for parsing, only for later stages of analysis.
             <para/>
             Any statement or expression can have attributes attached to it; when 
             attributes are seen beside a statement, they are attached to the root node 
             of that statement. In this example, the attribute is attached to the = 
             operator:
             <pre>
             [PointlessAttribute(true)] x = y * 2;
             </pre>
             Attributes are allowed not just at the beginning of a statement, but at the 
             beginning of any subexpression in parenthesis:
             <pre>
             Debug.Assert(x == ([PointlessAttribute(true)] y + 2));
             </pre>
             Here, the PointlessAttribute is attached to the addition operator (+).
             These attributes are simply normal EC# nodes (arbitrary expressions), so 
             they don't have to look like normal attributes:
             <pre>
             [TheKing is dead] LongLive(TheKing);
             </pre>
             Applying attributes to executable statements has no predefined meaning; A 
             warning is issued if the compiler encounters an attribute where one is not 
             allowed in plain C#, or if the syntax cannot be interpreted as an 
             attribute. The parser supports this feature because it is sometimes useful 
             in metaprogramming and DSLs.
             <para/>
             Because an attribute must be attached to something, an "assembly:" 
             attribute is represented as an #assembly node with an attribute attached:
             <pre>
             [assembly: AssemblyTitle("MyApp")]  // Normal EC#
             [AssemblyTitle("MyApp")] #assembly; // The way EC# sees it internally
             </pre>
             (assembly and module attributes must be special-cased anyway, since it 
             doesn't make sense for them to be attached to whatever follows them.)
             <para/>
             Unlike in plain C#, by the way, EC# labels do not have to be attached to 
             anything; they are considered statements by themselves:
             <pre>
             void f() {
                goto end;
                end:       // OK in EC#, syntax error in plain C#
             }
             </pre>
             Perhaps the most interesting thing about EC# is that it is actually an 
             expression-based language, like LISP: everything in EC# can be considered
             an expression! For example, instead of writing a method as a list of 
             statements, we can write it as a list of expressions:
             <pre>
             // Normal EC#
            	public static char HexDigitChar(int value)
            	{
            		Debug.Assert(16u > (uint)value);
            		if ((uint)value >= 10)
            			return (char)('A' - 10 + value);
            		else
            			return (char)('0' + value);
            	}
            	// Bizarro EC#
            	[#public, #static] #fn(HexDigitChar, #(#var(int, value)), #char, #
            	(
            		Debug.Assert(16u > (uint)value),
            		#if ((uint)value >= 10,
            			#return((char)('A' - 10 + value)),
            			#return((char)('0' + value)));
            	);
             </pre>
             Just so we're clear, you're not supposed to write "bizarro" code, but this
             notation can help you understand the underlying representation. The parser
             basically operates in two modes, one for expressions and one for
             statements. Statement mode allows certain constructs like "if", "while" 
             and "class" that expression mode does not understand. But once parsing is 
             finished, the code is just a tree of nodes with almost nothing to
             distinguish statements from expressions.
             <para/>
             EC# adopts a convention from LISP: the value of the final statement in a 
             block is the value of the block as a whole. This can be used to simplify 
             method and property definitions:
             <para/>
            	int _value;
            	public int Value { get { _value } }
             <para/>
             The EC# if-else and switch statements (but not loops) work the same way, 
             and you can put a braced block in the middle of any expression:
             <pre>
             int hexChar = {
            			if ((uint)value >= 10)
            				'A' - 10
            			else
            				'0'
            		} + value;
             </pre>
             The braced block is represented by a {} node, which introduces a new scope.
             In contrast, the special # node type (the "list marker"), does not create 
             a new scope. It is normally used with expression syntax:
             <pre>
             var three = #(Console.WriteLine("Fetching the three!"), 3);
             var eight = #(int x = 5, three + x);
             var seven = x + 2;
             </pre>
             Since # does not create a new scope, the variable "x" is created in the 
             outer scope, where it can be used to compute the value of seven.
             The # keyword is intended mostly to express lists with prefix notation, but 
             it can be used with braces in case there is a need to switch back to 
             statement notation. 
             <para/>
             The above code is a bit confusing because of how it is written; EC# is 
             meant for mature people who have enough sense not to write confusing code 
             like this.
             -->
             
             <h3>The reimplementation</h3>
             
             This implementation has been redesigned (in Subversion, the last version
             based on the old design is revision 289.) The core concept is the same as 
             described in my blog at
             http://loyc-etc.blogspot.ca/2013/04/the-loyc-tree-and-prefix-notation-in-ec.html
             except that the concept of a "Head" has mostly been eliminated, although
             you might see it occasionally because it still has a meaning. The "head"
             of a node refers either to the Name of a symbol, the Value of a literal,
             or the Target of a call (i.e. the name of the method being called, which
             could be an arbitrarily complex node). In the original implementation, it 
             was also possible to have a complex head (a head that is itself a node) 
             even when the node was not a call; this situation was used to represent
             an expression in parenthesis.
             <para/>
             This didn't quite feel right, so I changed it. Now, only calls can be
             complex, and the head of a call (the method being called) is called the
             Target.
             <para/>
             In the new version, there are explicitly three types of nodes: symbols, 
             literals, and calls. There is no longer a Head property, instead there 
             are three separate properties for the three kinds of heads, <see cref="P:Loyc.Syntax.LNode.Name"/> (a Symbol), <see cref="P:Loyc.Syntax.LNode.Value"/> (an Object), and <see cref="P:Loyc.Syntax.LNode.Target"/> (an LNode). Only call nodes have a Target, and only 
             literal nodes have a Value (as an optimization, <see cref="T:Loyc.Syntax.StdTriviaNode"/> breaks this rule; it can only do this because it
             represents special attributes that are outside the normal syntax tree,
             such as comments). Symbol nodes have a Name, but I thought it would be 
             useful for some call nodes to also have a Name, which is defined as the 
             name of the Target if the Target is a symbol (if the Target is not a 
             symbol, the Name must be blank.)
             <para/>
             An expression in parenthesis is now represented by a call with a blank
             name (use <see cref="M:Loyc.Syntax.LNode.IsParenthesizedExpr"/> to detect this case; it is
             incorrect to test <c><see cref="P:Loyc.Syntax.LNode.Name"/> == $``</c> because a call with 
             a non-symbol Target also has a blank name.)
             <para/>
             The following differences in implementation have been made:
             <ul>
             <li>"Red" and "green" nodes have basically been eliminated, at least for now.</li>
             <li>Nodes normally do not contain parent references anymore</li>
             <li>Mutable nodes have been eliminated, for now.</li>
             <li>There are now three standard subclasses, <see cref="T:Loyc.Syntax.IdNode"/>,
                 <see cref="T:Loyc.Syntax.LiteralNode"/> and <see cref="T:Loyc.Syntax.CallNode"/>, and a node
                 can no longer change between classes after it is created.</li>
             <li>An empty Name is now allowed. A literal now has a blank name (instead 
                 of #literal) and a method that calls anything other than a simple symbol
                 will also have a blank Name. Note:
                 The <see cref="P:Loyc.Syntax.LNode.Name"/> property will still never return null.</li>
             <li>As mentioned, an expression in parenthesis is represented differently.</li>
             </ul>
             The problems that motivated a redesign are described at
             http://loyc-etc.blogspot.ca/2013/05/redesigning-loyc-tree-code.html
             <para/>
             One very common use of mutable nodes is building lists of statements, e.g. 
             you might create an empty braced block or an empty loop and then add 
             statements to the body of the block or loop. To do this without mutable 
             nodes, create a mutable <see cref="T:Loyc.Collections.RWList`1"/> instead and add 
             statements there; once the list is finished, create the braced block or
             loop afterward. The new design stores arguments and attributes in 
             <see cref="T:Loyc.Collections.RVList`1"/> objects; you can instantly convert your WList 
             to a VList by calling <see cref="M:Loyc.Collections.WListBase`1.ToRVList"/>.
             <para/>
             During the redesign I've decided on some small changes to the representation
             of certain expressions in EC#.
             <ul>
             <li>The '.' operator is now treated more like a normal binary operator; 
                 <c>a.b.c</c> is now represented <c>#.(#.(a, b), c)</c> rather than 
                 <c>#.(a, b, c)</c> mainly because it's easier that way, and because the 
                 second representation doesn't buy anything significant other than a 
                 need for special-casing.</li>
             <li><c>int x = 0</c> will now be represented <c>#var(int, x = 0)</c>
                 rather than <c>#var(int, x(0))</c>. I chose the latter representation 
                 initially because it is slightly more convenient, because you can 
                 always learn the name of the declared variable by calling 
                 <c>var.Args[1].Name</c>. However, I decided that it was more important
                 for the syntax tree to be predictable, with obvious connections between
                 normal and prefix notations. Since I decided that <c>alias X = Y;</c> 
                 was to be represented <c>#alias(X = Y, #())</c>, it made sense for the 
                 syntax tree of a variable declaration to also resemble its C# syntax. 
                 There's another small reason: C++ has both styles <c>Foo x(y)</c> and 
                 <c>Foo x = y</c>; if Loyc were to ever support C++, it would make sense 
                 to use <c>#var(Foo, x(y))</c> and <c>#var(Foo, x = y)</c> for these two 
                 cases, and I believe C#'s variable declarations are semantically closer 
                 to the latter. (Note: another possibility was #var(int, x) = 0, but I 
                 decided this wasn't an improvement, it would just shift the pain around.)</li>
             <li>An constructor argument list is required on <i>all</i> types using the #new
                 operator, e.g. <c>new int[] { x }</c> must have an empty set of arguments
                 on int[], i.e. <c>#new(#of(#[],int)(), x)</c>; this rule makes the 
                 different kinds of new expressions easier to interpret by making them 
                 consistent with each other.</li>
             <li>A missing syntax element is now represented by an empty symbol instead 
                 of the symbol #missing.</li>
             <li>I've decided to adopt the "in-expression" generics syntax from Nemerle 
                 as an unambiguous alternative to angle brackets: List.[int] means 
                 List&lt;int&gt; and the printer will use this syntax in cases where angle 
                 brackets are ambiguous.</li>
             <li>By popular demand, constructors will be written this(...) instead
                 of new(...), since both D and Nemerle use the latter notation.</li>
             <li>The \ and $ characters have been swapped; \S now denotes a symbol S,
                 while $S now denotes a substitution.</li>
             <li>The \ and $ characters have been swapped; \S now denotes a symbol S,
                 while $S now denotes a substitution. Originally EC# was designed just
                 as an extension of C#, so \ made sense as a substitution operator for
                 string interpolation because it doesn't hurt backward compatibility:
                 "Loaded '\(filename)' successfully". But now that my focus has shifted 
                 to multi-language interoperability, $ makes more sense, as it is used 
                 for string interpolation in at least five other languages and it makes
                 sense to use the same character for both string substitution and code
                 substitution.</li>
             </ul>
             
             <h3>Important properties</h3>
             
             The main properties of a node are
             <ol>
             <li><see cref="P:Loyc.Syntax.LNode.Attrs"/>: holds the attributes of the node, if any.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Name"/>: the name of an <see cref="T:Loyc.Syntax.IdNode"/>, or the name 
                of the <see cref="T:Loyc.Syntax.IdNode"/> that is acting as the <see cref="P:Loyc.Syntax.LNode.Target"/> 
                of a <see cref="T:Loyc.Syntax.CallNode"/>.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Value"/>: the value of a <see cref="T:Loyc.Syntax.LiteralNode"/>.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Target"/>: the target of a <see cref="T:Loyc.Syntax.CallNode"/>. It 
                represents a method, macro, or special identifier that is being called.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Args"/>: holds the arguments to a <see cref="T:Loyc.Syntax.CallNode"/>,
                if any. Returns an empty list if the node does not have an argument list.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Range"/>: indicates the source file that the node came from
                and location in that source file.</li>
             <li><see cref="P:Loyc.Syntax.LNode.Style"/>: an 8-bit flag value that is used as a hint to the
                node printer about how the node should be printed. For example, a hex
                literal like 0x10 has the <see cref="F:Loyc.Syntax.NodeStyle.Alternate"/> style to
                distinguish it from decimal literals such as 16. Custom display styles 
                that do not fit in the Style property can be expressed with attributes.</li>
             </ol>
             <para/>
             The argument and attribute lists cannot be null, since they have type 
             <see cref="T:Loyc.Collections.RVList`1"/> which is a struct.
             <para/>
             <c>LNode</c> implements <see cref="T:Loyc.Collections.INegListSource`1"/>, so you can loop 
             through all children of the node like this:
             <code>
             for (int i = node.Min; i &lt;= node.Max; i++) {
                 LNode child = node[i];
             }
             </code>
             You can also use <c>foreach</c>. The children are numbered like this:
             <ul>
             <li>if i is less than -1, node[i] refers to an attribute. Specifically, node[i] 
             means node.Attrs[i + node.Attrs.Count + 1] in that case.</li>
             <li>node[-1] refers to <c>Target</c> (but throws if there is no target)</li>
             <li>Non-negative values are indexes of Args, e.g. node[i] means node.Args[i].</li>
             </ul>
             LNode also provides <c>Select(child =&gt; result)</c> and <c>ReplaceRecursive(child =&gt; result)</c>
             methods which allows you to transform all children (Atrrs, Target and Args).
             Currently there is no <c>Where(child =&gt; bool)</c> method because it is not
             possible to remove the <see cref="P:Loyc.Syntax.LNode.Target"/> of an LNode (you can still use
             standard LINQ Where(), of course, but the result is not an LNode).
             
             <h3>Note</h3>
             
             The argument and attribute lists should never contain null nodes. Any code 
             that puts nulls in <see cref="P:Loyc.Syntax.LNode.Args"/> or <see cref="P:Loyc.Syntax.LNode.Attrs"/> is buggy. 
             However, we can't ensure nulls are not placed into <see cref="T:Loyc.Collections.RVList`1"/> 
             since it's a general-purpose data type, not specialized for LNode. There is
             code to ensure nulls are not placed in Args and Attrs (<see cref="M:Loyc.Syntax.LNode.NoNulls(Loyc.Collections.RVList{Loyc.Syntax.LNode},System.String)"/>),
             but only in debug builds, since null-checking is fairly expensive.
             </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.WithName(Loyc.Symbol)">
            <summary>Creates a node with a new value for Name.</summary>
            <remarks>If IsId, the Name is simply changed. If <see cref="P:Loyc.Syntax.LNode.IsCall"/>, 
            this method returns the equivalent of <c>WithTarget(Target.WithName(name))</c>
            (which may be optimized for the particular call type). If <see cref="P:Loyc.Syntax.LNode.IsLiteral"/>, the <see cref="P:Loyc.Syntax.LNode.Kind"/> changes to <see cref="F:Loyc.Syntax.LNodeKind.Id"/> in
            order to set the name.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.WithValue(System.Object)">
            <summary>Creates a new literal node with a different Value than the current literal node.</summary>
            <exception cref="T:System.InvalidOperationException">The node was not a literal already.</exception>
        </member>
        <member name="M:Loyc.Syntax.LNode.WithArgs(Loyc.Collections.RVList{Loyc.Syntax.LNode})">
            <summary>Creates a Node with a new argument list. If this node is not a 
            call, a new node is created using this node as its target. Otherwise,
            the existing argument list is replaced.</summary>
            <param name="args">New argument list</param>
        </member>
        <member name="M:Loyc.Syntax.LNode.With(Loyc.Syntax.LNode,Loyc.Collections.RVList{Loyc.Syntax.LNode})">
            <summary>Creates a <see cref="T:Loyc.Syntax.CallNode"/> with the same attributes and 
            <see cref="P:Loyc.Syntax.LNode.Range"/>, but a different target and argument list. If the 
            current node is not a CallNode, it becomes one (the Range, Style and 
            attributes of the current node are kept, but the Kind, Value, and 
            Name are discarded.)</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.With(Loyc.Symbol,Loyc.Collections.RVList{Loyc.Syntax.LNode})">
            <summary>Creates a <see cref="T:Loyc.Syntax.CallNode"/> with the same attributes and 
            <see cref="P:Loyc.Syntax.LNode.Range"/>, but a different target and argument list. If the 
            current node is not a CallNode, it becomes one (the Range, Style and 
            attributes of the current node are kept, but the Kind, Value, and 
            Name are discarded.)</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.Clone">
            <summary>Creates a copy of the node. Since nodes are immutable, there 
            is little reason for an end-user to call this, but Clone() is used 
            internally as a helper method by the WithXyz() methods.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.PushPrinter(Loyc.Syntax.LNodePrinter)">
            <summary>Helps you change printers temporarily. Usage in C#: 
            <c>using (LNode.PushPrinter(myPrinter)) { ... }</c></summary>
            <remarks>For example, to switch to the EC# printer, use
            <c>using (LNode.PushPrinter(EcsNodePrinter.Printer)) { ... }</c>.
            This changes the default printer. If you don't want to change the
            default printer, please invoke the printer directly: 
            <code>
                var sb = new StringBuilder();
                EcsNodePrinter.Printer(node, sb, MessageSink.Trace);
            </code>
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.Equals(Loyc.Syntax.LNode,Loyc.Syntax.LNode,System.Boolean)">
            <inheritdoc cref="M:Loyc.Syntax.LNode.Equals(Loyc.Syntax.LNode,System.Boolean)"/>
        </member>
        <member name="M:Loyc.Syntax.LNode.Equals(Loyc.Collections.RVList{Loyc.Syntax.LNode},Loyc.Collections.RVList{Loyc.Syntax.LNode},System.Boolean)">
            <summary>Compares two lists of nodes for structural equality.</summary>
            <param name="compareStyles">Whether to compare values of <see cref="P:Loyc.Syntax.LNode.Style"/></param>
            <remarks>Position information is not compared.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.Equals(Loyc.Syntax.LNode,System.Boolean)">
            <summary>Compares two nodes for structural equality. Two green nodes 
            are considered equal if they have the same name, the same value, the
            same arguments, and the same attributes. IsCall must be the same, but
            they need not have the same values of SourceWidth or IsFrozen.</summary>
            <param name="compareStyles">Whether to compare values of <see cref="P:Loyc.Syntax.LNode.Style"/></param>
            <remarks>Position information (<see cref="P:Loyc.Syntax.LNode.Range"/>) is not compared.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.GetHashCode">
            <summary>Gets the hash code based on the structure of the tree.</summary>
            <remarks>
            If the tree is large, less than the entire tree is scanned to produce 
            the hashcode (in the absolute worst case, about 4000 nodes are examined, 
            but usually it is less than 100).
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.HasSimpleHead">
            <summary>Returns true if the Target is an Id or a Literal, and the Target has no attributes.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.HasSimpleHeadWithoutPAttrs">
            <summary>Returns true if the Target is an Id or a Literal, and the Target has only trivia attributes.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNode.MergeLists(Loyc.Syntax.LNode,Loyc.Syntax.LNode,Loyc.Symbol)">
            <summary>Some <see cref="T:Loyc.Syntax.CallNode"/>s are used to represent lists. This 
            method merges two nodes, forming or appending a list (see remarks).</summary>
            <param name="node1">First node, list, or null.</param>
            <param name="node2">Second node, list, or null.</param>
            <param name="listName">The <see cref="P:Loyc.Syntax.LNode.Name"/> used to detect whether a 
            node is a list (typically "#splice"). Any other name is considered a 
            normal call, not a list. If this method creates a list from two non-
            lists, this parameter specifies the Name that the list will have.</param>
            <returns>The merged list.</returns>
            <remarks>
            The order of the data is retained (i.e. the data in node1 is inserted
            before the data in node2).
            <ul>
            <li>If either node1 or node2 is null, this method returns the other (node1 ?? node2).</li>
            <li>If both node1 and node2 are lists, this method merges the list 
            into a single list by appending node2's arguments at the end of node1.
            The attributes of node1 are kept and those of node2 are discarded.</li>
            <li>If one of the nodes is a list and the other is not, the non-list
            is inserted into the list's Args.</li>
            <li>If neither node is a list, a list is created with both nodes as 
            its two Args.</li>
            </ul>
            </remarks>
            <seealso cref="M:Loyc.Syntax.LNodeExt.WithSpliced(Loyc.Collections.RVList{Loyc.Syntax.LNode},System.Int32,Loyc.Syntax.LNode,Loyc.Symbol)"/>
        </member>
        <member name="M:Loyc.Syntax.LNode.MergeBinary(Loyc.Syntax.LNode,Loyc.Syntax.LNode,Loyc.Symbol)">
            <summary>Combines two nodes using a binary operator or function.</summary>
            <param name="node1">First node, list, or null.</param>
            <param name="node2">Second node, list, or null.</param>
            <param name="binaryOpName">Binary operator to use when the nodes are not null.</param>
            <returns>If either node1 or node2 is null, this method returns the other node
            (node1 ?? node2), otherwise the nodes are joined with the specified operator.</returns>
        </member>
        <member name="M:Loyc.Syntax.LNode.Select(System.Func{Loyc.Syntax.LNode,Loyc.Syntax.LNode})">
            <summary>Transforms the attributes, <see cref="P:Loyc.Syntax.LNode.Target"/>, and parameters 
            of an LNode, returning another LNode of the same Kind. If the selector
            makes no changes, Select() returns <c>this</c>.</summary>
            <remarks>The selector is not allowed to return null.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNode.ReplaceRecursive(System.Func{Loyc.Syntax.LNode,Loyc.Syntax.LNode},System.Boolean)">
            <summary>Performs a recursive find-and-replace operation, by attempting
            to replace each child (among <see cref="P:Loyc.Syntax.LNode.Attrs"/>, <see cref="P:Loyc.Syntax.LNode.Target"/>, 
            <see cref="P:Loyc.Syntax.LNode.Args"/>) using the specified selector. This method can also
            be used for simple searching, by giving a selector that always returns 
            null.</summary>
            <param name="selector">The selector is called for each descendant, and
            optionally the root node. If the selector returns a node, the new node 
            replaces the node that was passed to <c>selector</c> and the children of 
            the new node are ignored. If the selector returns null, children of the 
            child are scanned recursively.</param>
            <param name="replaceRoot">Whether to call <c>selector(this)</c>.</param>
            <returns>The new node produced after all replacements have occurred.</returns>
            <remarks>If <c>replaceFunc</c> always returns null (or if <c>replaceRoot</c>
            is false and the root has no children), <c>ReplaceRecursive</c> returns 
            <c>this</c>.</remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Range">
            <summary>Returns the location and range in source code of this node.</summary>
            <remarks>
            A parser should record a sufficiently wide range for each parent node, 
            such that all children are fully contained within the range. However, 
            this is not an invariant; macros can splice together syntax trees from 
            different source files or add synthetic nodes, so that the parent range
            does not necessarily include all child ranges. (In fact, in general it 
            is impossible to ensure that parent ranges include child ranges because
            a parent can only specify a single source file, while children can come
            from several source files.)
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Source">
            <summary>Returns the source file (shortcut for <c><see cref="P:Loyc.Syntax.LNode.Range"/>.Source</c>).</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Loyc#IHasLocation#Location">
            <summary>Gets Range.Begin.ToString().</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Style">
            <summary>Indicates the preferred style to use when printing the node to a text string.</summary>
            <remarks>
            The Style is an 8-bit value that acts as a hint to the node printer about 
            how the node should be printed. Custom display styles that do not fit in 
            the Style property can be expressed with special attributes that have a
            <see cref="P:Loyc.Syntax.LNode.Name"/> starting with "#trivia_". ("#trivia" attributes, which
            are also used to store comments in the syntax tree, are not printed like
            normal attributes and are normally ignored if the node printer does not 
            specifically recognize them.)
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Attrs">
            <summary>Returns the attribute list for this node.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.IsFrozen">
            <summary>Returns true if the node is immutable, and false if any part of it can be edited.
            Currently, mutable nodes are not implemented.</summary>
            <remarks>Debugger-hidden until such time as mutable nodes actually exist.</remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Kind">
            <summary>Returns the <see cref="T:Loyc.Syntax.LNodeKind"/>: Symbol, Literal, or Call.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Name">
            <summary>Returns the Symbol if <see cref="P:Loyc.Syntax.LNode.IsId"/>. If this node is 
            a call (<see cref="P:Loyc.Syntax.LNode.IsCall"/>) and <c>Target.IsId</c> is true, 
            this property returns <c>Target.Name</c>. In all other cases, the name
            is <see cref="F:Loyc.GSymbol.Empty"/>. Shall not return null.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.HasSpecialName">
            <summary>Returns true if <see cref="P:Loyc.Syntax.LNode.Name"/> starts with '#'.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Value">
            <summary>Returns the value of a literal node, or <see cref="F:Loyc.NoValue.Value"/> 
            if this node is not a literal (<see cref="P:Loyc.Syntax.LNode.IsLiteral"/> is false).</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Target">
            <summary>Returns the target of a method call, or null if <see cref="P:Loyc.Syntax.LNode.IsCall"/> 
            is false. The target can be a symbol with no name (<see cref="F:Loyc.GSymbol.Empty"/>)
            to represent a parenthesized expression, if there is one argument.</summary>
        </member>
        <member name="P:Loyc.Syntax.LNode.Args">
            <summary>Returns the argument list of this node. Always empty when <c><see cref="P:Loyc.Syntax.LNode.IsCall"/>==false</c>.</summary>
            <remarks>
            Depending on the <see cref="P:Loyc.Syntax.LNode.Target"/>, Args may represent an actual 
            argument list, or it may represent some other kind of list. For 
            example, if the target is "{}" then Args represents a list of 
            statements in a braced block, and if the target is "&gt;=" then Args 
            represents the two arguments to the "&gt;=" operator.
            </remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.Printer">
            <summary>Gets or sets the default node printer on the current thread,
            which controls how nodes are serialized to text by default.</summary>
            <remarks>The LES printer is the default, and will be used if you try
            to set this property to null.</remarks>
        </member>
        <member name="P:Loyc.Syntax.LNode.TriviaValue">
            <summary>Gets the value of <c>Args[0].Value</c>, if Args[0] exists; 
            otherwise, returns <see cref="F:Loyc.NoValue.Value"/>.</summary>
            <remarks>"Trivia nodes" are used to efficiently represent the value of
            trivia and non-tree <see cref="T:Loyc.Syntax.Lexing.Token"/>s; they can be created by 
            calling the <see cref="M:Loyc.Syntax.LNode.Trivia(Loyc.Symbol,System.Object,Loyc.Syntax.LNode)"/> function. Since an LNode is not 
            allowed to have both a Name and a Value (as there is no syntax in LES 
            or EC# for such a node), a trivia node pretends that there is an 
            argument list with one item, and that one item is always a literal 
            whose Value is the value stored in the trivia node. Thus, a token node 
            is printed out as <c>TokenType(Value)</c> where <c>Value</c> is some 
            literal.
            <para/>
            If you suspect you're dealing with a trivia node, it is wasteful to 
            actually call <c>node.Args[0].Value</c> since this causes a temporary
            token list to be allocated. Instead you should use this property, which
            returns the token value without allocating memory. Of course, if this 
            property is called on a non-trivia node, it simply returns 
            <c>Args[0].Value</c>.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.LNode.PushedPrinter">
            <summary>Returned by <see cref="M:Loyc.Syntax.LNode.PushPrinter(Loyc.Syntax.LNodePrinter)"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.LNode.DeepComparer">
            <summary>An IEqualityComparer that compares nodes structurally.</summary>
        </member>
        <member name="T:Loyc.Syntax.LiteralNode">
            <summary>Base class of all nodes that represent literal values such as 123 and "foo".</summary>
        </member>
        <member name="T:Loyc.Syntax.CallNode">
            <summary>Base class of all nodes that represent calls such as <c>f(x)</c>, 
            operator calls such as <c>x + y</c>, braced blocks, and all other things 
            that are not simple symbols and literals.</summary>
        </member>
        <member name="T:Loyc.Syntax.NodeScanMode">
            <summary>Specifies which children to enumerate when calling <see cref="M:Loyc.Syntax.LNode.Descendants(Loyc.Syntax.NodeScanMode)"/>().</summary>
            <remarks>TODO code review</remarks>
        </member>
        <member name="T:Loyc.Syntax.DescendantsFrame">
            <summary>Helper class used to enumerate <see cref="M:Loyc.Syntax.LNode.Descendants(Loyc.Syntax.NodeScanMode)"/>().</summary>
            <remarks>TODO code review</remarks>
        </member>
        <member name="T:Loyc.Syntax.LNodePrinter">
            <summary>Signature for a method that serializes a Loyc tree to text. Each
            programming language will have one (when complete).</summary>
            <param name="node">Node to print</param>
            <param name="target">Output buffer</param>
            <param name="mode">A language-specific way of modifying printer behavior.
            The printer should ignore the mode object if it does not not understand it.</param>
            <param name="indentString">A string to print for each level of indentation, such as a tab or four spaces.</param>
            <param name="lineSeparator">Line separator, typically "\n" or "\r\n".</param>
            <remarks>This delegate only prints to a StringBuilder. Printing directly to 
            a stream requires language-specific facilities.</remarks>
        </member>
        <member name="T:Loyc.Syntax.LNodeExt">
            <summary>Standard extension methods for <see cref="T:Loyc.Syntax.LNode"/>.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.AsList(Loyc.Syntax.LNode,Loyc.Symbol)">
            <summary>Interprets a node as a list by returning <c>block.Args</c> if 
            <c>block.Calls(braces)</c>, otherwise returning a one-item list of nodes 
            with <c>block</c> as the only item.</summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.AsLNode(Loyc.Collections.RVList{Loyc.Syntax.LNode},Loyc.Symbol)">
            <summary>Converts a list of LNodes to a single LNode by using the list 
            as the argument list in a call to the specified identifier, or, if the 
            list contains a single item, by returning that single item.</summary>
            <param name="listIdentifier">Target of the node that is created if <c>list</c>
            does not contain exactly one item. Typical values include "{}" and "#splice".</param>
            <remarks>This is the reverse of the operation performed by <see cref="M:Loyc.Syntax.LNodeExt.AsList(Loyc.Syntax.LNode,Loyc.Symbol)"/>.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeExt.MatchesPattern(Loyc.Syntax.LNode,Loyc.Syntax.LNode,Loyc.Collections.MMap{Loyc.Symbol,Loyc.Syntax.LNode}@,Loyc.Collections.RVList{Loyc.Syntax.LNode}@)">
            <summary>Determines whether one Loyc tree "matches" another. This is 
            different from a simple equality test in that (1) trivia atributes do 
            not have to match, and (2) the pattern can contain placeholders represented
            by calls to $ (the substitution operator) with an identifier as a parameter.
            Placeholders match any subtree, and are saved to the <c>captures</c> map.
            </summary>
            <param name="candidate">A node that you want to compare with a 'pattern'.</param>
            <param name="pattern">A syntax tree that may contain placeholders. A 
            placeholder is a call to the $ operator with one parameter, which must 
            be a simple identifier (otherwise the $ operator is treated literally as
            something that must exist in <c>candidate</c>). The subtree in 
            <c>candidate</c> corresponding to the placeholder is saved in <c>captures</c>.</param>
            <param name="captures">A table that maps placeholder names from 
            <c>pattern</c> to subtrees in <c>candidate</c>. You can set your map to 
            null and a map will be created for you if necessary. If you already have
            a map, you should clear it before calling this method.</param>
            <param name="unmatchedAttrs">On return, a list of trivia attributes in 
            <c>candidate</c> that were not present in <c>pattern</c>.</param>
            <returns>true if <c>pattern</c> matches <c>candidate</c>, false otherwise.</returns>
            <remarks>
            Attributes in patterns are not yet supported.
            <para/>
            This method supports multi-part captures, which are matched to 
            placeholders whose identifier has a #params attribute (for example, if 
            the placeholder is called p, this is written as <c>$(params p)</c> in 
            EC#.) A placeholder that looks like this can match multiple arguments or
            multiple statements in the <c>candidate</c> (or <i>no</i> arguments, or
            no statements), and will become a #splice(...) node in <c>captures</c>
            if it matches multiple items. Multi-part captures are often useful for
            getting lists of statements before and after some required element,
            e.g. <c>{ $(params before); MatchThis($something); $(params after); }</c>
            <para/>
            If the same placeholder appears twice then the two matching items are 
            combined into a single output node (calling #splice).
            <para/>
            If matching is unsuccessful, <c>captures</c> and <c>unmatchedAttrs</c>
            may contain irrelevant information gathered during the attempt to match.
            <para/>
            In EC#, the quote(...) macro can be used to create the LNode object for 
            a pattern.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.LNodeFactory">
            <summary>Contains helper methods for creating <see cref="T:Loyc.Syntax.LNode"/>s.
            An LNodeFactory holds a reference to the current source file (<see cref="P:Loyc.Syntax.LNodeFactory.File"/>) 
            so that it does not need to be repeated every time you create a node.
            </summary>
        </member>
        <member name="M:Loyc.Syntax.LNodeFactory.Trivia(System.String,System.Object)">
            <summary>Creates a trivia node named <c>"#trivia_" + suffix</c> with the 
            specified Value attached.</summary>
            <remarks>This method only adds the prefix <c>#trivia_</c> if it is not 
            already present in the 'suffix' argument.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LNodeFactory.Trivia(Loyc.Symbol,System.Object,System.Int32,System.Int32)">
            <summary>Creates a trivia node with the specified Value attached.</summary>
            <seealso cref="M:Loyc.Syntax.LNode.Trivia(Loyc.Symbol,System.Object,Loyc.Syntax.LNode)"/>
        </member>
        <member name="T:Loyc.Syntax.LNodeVisitor">
            <summary>Base class for people that want to implement the visitor pattern with <see cref="T:Loyc.Syntax.LNode"/>.</summary>
        </member>
        <member name="T:Loyc.Syntax.ILNodeVisitor">
            <summary>Interface for people that want to implement the visitor pattern with <see cref="T:Loyc.Syntax.LNode"/>.
            If your visitor does not need a base class, use <see cref="T:Loyc.Syntax.LNodeVisitor"/> as the base class.</summary>
        </member>
        <member name="T:Loyc.Syntax.NodeStyle">
            <summary>Suggests a printing style when serializing a Loyc tree to text.</summary>
            <remarks>See <see cref="P:Loyc.Syntax.LNode.Style"/>.
            <para/>
            TODO: review, rethink.
            <para/>
            A printer should not throw exceptions unless specifically requested. It 
            should ignore printing styles that it does not allow, rather than throwing.
            <para/>
            Styles may be used in different ways by different parsers, different
            printers and different people. Be careful how you rely on them; they are 
            intended to affect only the appearance of a node when it is printed, not 
            its semantics.
            <para/>
            Please note that language-specific printing styles can be denoted by 
            attaching special attributes recognized by the printer for that language.
            These attributes should have Names starting with the string "#trivia_";
            printers are programmed to ignore trivia attributes that they do not
            understand.</remarks>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Default">
            <summary>No style category is specified; the printer should choose a 
            style automatically.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Operator">
            <summary>The node should be printed with operator notation (infix, prefix, 
            suffix) instead of prefix notation if applicable (can be used to request 
            `backquote notation` in LES and EC#).</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Statement">
            <summary>The node's immediate children (and/or the node itself) should be 
            printed in statement notation, if possible in the context in which it is 
            located.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Special">
            <summary>A language-specific special notation should be used for this
            node. In LES, this marker requests that the arguments to a call be
            broken out into separate expressions, forming a "superexpression", e.g.
            in "if c {a();} else {b();}", which actually means "if(c,{a();},else,{b();})",
            the "if(...)" node will have this style.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.PrefixNotation">
            <summary>The node should be printed in prefix notation, e.g. <c>@.(X, Y)</c>
            instead of <c>X.Y</c>.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Expression">
            <summary>The node(s) should be printed as a normal expression, rather
            than using a special or statement notation.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.DataType">
            <summary>The node should be printed like a data type, if the type 
            notation is somehow different from expression notation. (Note: in 
            general, one cannot expect data types to have this style).</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.OldStyle">
            <summary>Use an older or backward-compatible notation.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.BaseStyleMask">
            <summary>If s is a NodeStyle, (s &amp; NodeStyle.BaseStyleMask) is the 
            base style (Default, Expression, Statement, PrefixNotation, or PurePrefixNotation).</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Alternate">
            <summary>If this node has two common styles in which it is printed, this
            selects the second (either the less common style, or the EC# style for
            features of C# with new syntax in EC#). In LES and EC#, alternate style
            denotes hex numbers. In EC#, it denotes verbatim strings, x(->int) as 
            opposed to (int)x, x (as Y) as opposed to (x as Y). delegate(X) {Y;} is 
            considered to be the alternate style for X => Y, and it forces parens 
            and braces as a side-effect.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Alternate2">
            <summary>Another alternate style flag. In LES and EC#, this is used for
            binary-format numbers.</summary>
        </member>
        <member name="F:Loyc.Syntax.NodeStyle.Handled">
            <summary>Indicates that some part of a compiler has seen the node and 
            done something with it.</summary>
            <remarks>The idea behind this flag relates to compilers that allow 
            user-defined attributes for plug-ins that add functionality. For 
            example, internationalization plug-in might notice a language marker:
            <code>
               MessageBox.Show([en] "Hello, World!");
            </code>
            If an attribute is not used by any plug-in, the compiler should print 
            a warning that the attribute is unused. This leads to the question, how
            can a compiler tell if an attribute was used or not? The Handled flag
            is one possible mechanism; when any part of the compiler or its plug-
            ins use an attribute, the Handled flag should be set to disable the
            compiler warning.
            <para/>
            Remember that the same node can theoretically appear in multiple
            places in a syntax tree, which typically happens when a statement or
            expression is duplicated by a macro, without being changed. Remember 
            that when a style is changed on such a node, the change is visible at 
            all locations where the same node is used. However, style flags are
            not synchronized between copies of a node.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.StdTriviaNode">
            <summary>A node that has both a Name and a Value. </summary>
            <remarks>
            Since there is no syntax (or <see cref="T:Loyc.Syntax.LNodeKind"/>) for a node that has
            both a Name and a Value, the node pretends that it is has a single argument,
            Args[0], which allows this node to be printed as if it were a normal call
            node. For example, if this node has Name=(Symbol)"PI" and Value=3.1415,
            it will be printed as <c>PI(3.1415)</c>. The <see cref="P:Loyc.Syntax.StdTriviaNode.TriviaValue"/>
            property returns this value (in this case, (object)3.1415). Please note
            that the normal <see cref="P:Loyc.Syntax.LNode.Value"/> is still <see cref="F:Loyc.NoValue.Value"/>
            so that if the node is printed and reparsed, it doesn't behave differently.
            <para/>
            This node type is used to represent tokens and trivia nodes with values.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.OperatorShape">
            <summary>An enum of common operator formats.</summary>
            <remarks>It is intentional that the absolute value of each OperatorShape
            (except Other) is the arity of (number of arguments to) that shape.</remarks>
        </member>
        <member name="T:Loyc.Syntax.ParserSource`3">
            <summary>An implementation of the LLLPG Parser API, used with the LLLPG
            options <c>inputSource</c> and <c>inputClass</c>.</summary>
            <remarks>
            This derived class simply makes public all of the LLLPG APIs which are 
            marked protected in <see cref="T:Loyc.Syntax.BaseParserForList`3"/>.
            </remarks>
            <typeparam name="Token">Data type of complete tokens in the token list. A 
            token contains the type of a "word" in the program (string, identifier, plus 
            sign, etc.), a value (e.g. the name of an identifier), and a range of 
            characters in the source file. See <see cref="T:Loyc.Syntax.Lexing.ISimpleToken`1"/>.
            Note: Token is usually a small struct; this class does not expect it to
            ever be null.</typeparam>
            <typeparam name="MatchType">A data type, usually int, that represents a 
            token type (identifier, operator, etc.) and implements <see cref="T:System.IEquatable`1"/>
            so it can be compared for equality with other token types; this is also the 
            type of the <see cref="P:Loyc.Syntax.Lexing.ISimpleToken`1.Type"/> property.</typeparam>
            <typeparam name="List">Data type of the list that contains the tokens (one 
            often uses IList{Token}, but one could use <see cref="T:Loyc.Collections.Impl.InternalList`1"/> 
            for potentially higher performance.)</typeparam>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`3.#ctor(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`3.Reset(`2,`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`3.Skip">
            <inheritdoc/>
        </member>
        <member name="P:Loyc.Syntax.ParserSource`3.TokenTypeToString">
            <summary>Converts from MatchType (usually integer) to string (used in 
            error messages).</summary>
        </member>
        <member name="T:Loyc.Syntax.ParserSource`2">
            <summary>Alias for ParserSource{Token, int, IList{Token}}.</summary>
            <typeparam name="Token">Token type (one often uses <see cref="T:Loyc.Syntax.Lexing.Token"/>).</typeparam>
            <typeparam name="MatchType">Data type of the Type property of 
            <see cref="T:Loyc.Syntax.Lexing.ISimpleToken`1"/> (often set to int).</typeparam>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`2.#ctor(System.Collections.Generic.IList{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`2.#ctor(System.Collections.Generic.IEnumerable{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`2.#ctor(System.Collections.Generic.IEnumerator{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="T:Loyc.Syntax.ParserSource`1">
            <summary>Alias for ParserSource{Token, int, IList{Token}}.</summary>
            <typeparam name="Token">Token type (one often uses <see cref="T:Loyc.Syntax.Lexing.Token"/>).</typeparam>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`1.#ctor(System.Collections.Generic.IList{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`1.#ctor(System.Collections.Generic.IEnumerable{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="M:Loyc.Syntax.ParserSource`1.#ctor(System.Collections.Generic.IEnumerator{`0},`0,Loyc.Syntax.ISourceFile,System.Int32)">
            <inheridoc/>
        </member>
        <member name="T:Loyc.Syntax.Precedence">
            <summary>A four-byte tuple that represents the precedence and miscibility 
            of an operator.</summary>
            <remarks>
            An operator's precedence is encoded in the two numbers, <see cref="F:Loyc.Syntax.Precedence.Left"/> 
            and <see cref="F:Loyc.Syntax.Precedence.Right"/>. These numbers encode the knowledge that, for example, 
            <c>x &amp; y == z</c> will be parsed as <c>x &amp; (y == z)</c>. For normal 
            left-associative operators, Left and Right are the same. However, some 
            operators have different precedence on the left than on the right, a prime
            example being the =&gt; operator: <c>x = a =&gt; y = a</c> is parsed 
            <c>x = (a =&gt; (y = a))</c>; it has very high precedence on the left, but
            very low precedence on the right.
            <para/>
            To understand how this works, remember that a parser scans from left to 
            right. Each time it encounters a new operator, it needs to figure out 
            whether to include that operator in the current (inner) expression or 
            whether to "complete" the inner expression and bind the operator to an
            outer expression instead. The concept of a "precedence floor" can be used 
            to make this decision.
            <para/>
            For example, suppose we start parsing the expression <c>-a.b + c * d + e</c>.
            The parser sees "-" first, which must be a prefix operator since there is 
            no expression on the left. The <see cref="F:Loyc.Syntax.Precedence.Right"/> precedence of unary 
            '-' is 90 in EC#, so that will be the "precedence floor" to parse the 
            right-hand side. Operators above 90 will be permitted in the right-hand 
            side; operators at 90 or below will not.
            <para/>
            The next token is 'a', which is an expression by itself and doesn't have 
            any precedence, so it becomes the initial right-hand expression of '-'.
            Next we have '.', which has a <see cref="F:Loyc.Syntax.Precedence.Left"/> precedence of 100, which 
            is above the precedence floor of 90 so it can be bound to 'a'. The 
            precedence floor (PF) is raised to 100, and the next token 'b' is bound to 
            '.'.
            <para/>
            However, the next token '+' (which must be the binary operator rather than 
            the prefix operator, because there is an expression on the left) cannot be 
            accepted with its precedence of 60. Therefore the expression "a.b" is 
            deemed complete, and the PF is lowered back to 90. Again 60 is less than 
            90, so the expression "-a.b" is also deemed complete and the PF drops to 
            int.MinValue. This expression becomes the left-hand side of the '+' 
            operator. The PF rises to 60, and "c * d" becomes a subexpression because
            the precedence of '*' is 70 &gt; 60. However, next we have '+' with 
            precedence 60, which is not above the PF of 60. Therefore, the 
            subexpression "c * d" is deemed complete and the PF lowers to int.MinValue
            again. Now the '+' can be accepted with a left-hand side of <c>(-(a.b)) + 
            (c * d)</c>, and the right-hand side is, of course, 'e', so the completed
            expression is <c>((-(a.b)) + (c * d)) + e</c>. Hope that helps!
            <para/>
            Notice that <c>a + b + c</c> is parsed <c>(a + b) + c</c>, not 
            <c>a + (b + c)</c>. This is the natural result when the operator's 
            precedence is the same on the left and on the right. However, <c>a = b = c</c>
            is parsed <c>a = (b = c)</c>, because its precedence is 1 on the left and 
            0 on the right. When the parser sees the first '=' it sets the PF to 0 
            because it is about to parse the right side. When it encounters the second 
            '=', the left-hand precedence of that operator is 1 which is higher than 
            the current PF (0) so it is included in the right-hand side of the first 
            '='. This behavior is called "right associativity"; <see cref="P:Loyc.Syntax.Precedence.IsRightAssociative"/> 
            returns true when <c>Left &gt; Right</c>.
            <para/>
            Prefix and suffix operators only have one "side"; you can imagine that the 
            unused side (e.g. the left side of prefix -) has infinite precedence, so 
            that EC# can parse $-x as $(-x) even though the precedence of '-' is 
            supposedly lower than '$'.
            <para/>
            Some languages have a conditional operator (a?b:c) with three parts. In 
            the middle part, the PF must drop to Precedence.MinValue so that it is 
            possible to parse <c>a?b=x:c</c> even though '=' supposedly has lower 
            precedence than the conditional operator. Note that <c>a=b ? c=d : e=f</c> 
            is interpreted <c>a=(b ? c=d : e)=f</c>, so you can see that the precedence 
            of the conditional operator is higher at the "edges".
            <para/>
            The above explanation illustrates the meaning of Left and Right from the
            perspective of a parser, but an actual parser may or may not use the PF 
            concept and <c>Precedence</c> objects.
            <para/>
            This struct contains two other numbers, <see cref="F:Loyc.Syntax.Precedence.Lo"/> and <see cref="F:Loyc.Syntax.Precedence.Hi"/>,
            which are a precedence range that determines whether and how the operator 
            can be mixed with other operators, as explained below.
            <para/>
            A printer (e.g. <see cref="T:Loyc.Syntax.Les.LesNodePrinter"/>) has a different way of analyzing
            precedence. It starts with a known parse tree and then has to figure out 
            how to output something that the parser will reconstruct into the original
            tree. This is more difficult if perfect round-tripping is required: parentheses
            are encoded in the Loyc tree as a #trivia_inParens attribute, so if perfect
            round-tripping is desired, the printer cannot simply put everything in parens 
            "just to be safe".
            <para/>
            Generally, the printer has two ways of printing any expression tree: (1) 
            with operators (e.g. a+b), and (2) with prefix notation (e.g. @+(a, b)).
            The tree <c>@+(@*(a, b), c)</c> will be printed as "a*b+c" (unless prefix
            notation is specifically requested) because the precedence rules allow it,
            but <c>@*(@+(a, b), c)</c> will be printed as <c>@+(a, b)*c</c> because 
            both "a+b*c" and "(a+b)*c" are different from the original tree.
            <para/>
            While a parser proceeds from left to right, a printer proceeds from parents
            to children. So the printer for @*(@+(a, b), c) starts at @* with no 
            precedence restrictions, and roughly speaking will set the precedence floor
            to <see cref="T:Loyc.Syntax.Les.LesPrecedence"/>.Multiply in order to print its two children.
            Since the precedence of @+ (Add) is below Multiply, the + operator is not
            allowed in that context and either prefix notation or extra parenthesis
            is used as a fallback (depending on the <see cref="P:Loyc.Syntax.Les.LesNodePrinter.AllowExtraParenthesis"/> 
            option that permits <c>(a+b)*c</c>).
            <para/>
            Printing has numerous "gotchas"; the ones related to precedence are
            <ol>
            <li>Although <see cref="T:Loyc.Syntax.Les.LesPrecedence"/>.Add has the "same" precedence on the
                Left and Right, <c>@-(@-(a, b), c)</c> can be printed <c>a - b - c</c> but
                <c>@-(a, @-(b, c))</c> would have to be printed <c>a - @-(b, c)</c> 
                instead. Clearly, the left and right sides must be treated somehow
                differently.</li>
            <li>Similarly, the different arguments in <c>a?b:c</c> and <c>a=&gt;b</c> must
                be treated differently. And careful handling is needed for the dot 
                operator in particular due to its high precedence; e.g. <c>@.(a(b))</c> 
                cannot be printed <c>.a(b)</c> because that would mean <c>@.(a)(b)</c>.</li>
            <li>The LES parser, at least, allows a prefix operator to appear on the 
                right-hand side of any infix or prefix operator, regardless of the 
                precedence of the two operators; "$ ++x" is permitted even though ++ has
                lower precedence than $. Another example is that <c>a.-b.c</c> can be 
                parsed with the interpretation <c>a.(-b).c</c>, even though @- has 
                lower precedence than @$. Ideally the printer would replicate this 
                rule, but whether it does ot not, it also must take care that 
                <c>@.(a, -b.c)</c> is not printed as <c>a.-b.c</c> even though the 
                similar expression <c>@*(a, @-(b.c))</c> can be printed as <c>a*-b.c</c>.</li>
            <li>Prefix notation is needed when an operator's arguments have attributes;
                <c>@+([Foo] a, b)</c> cannot be printed <c>[Foo] a + b</c> because
                that would mean <c>[Foo] @+(a, b)</c>.</li>
            </ol>
            
            <h3>Printing and parsing are different</h3>
            
            This type contains different methods for printers and parsers. A basic 
            difference between them is that printers must make decisions (of whether
            an operator is allowed or not in a given context) based on both sides of
            the operator and both sides of the context (Left and Right), while parsers
            only have to worry about one side. For example, consider the following 
            expression:
            <code>
                a = b + c ?? d
            </code>
            When the parser encounters the "+" operator, it only has to consider 
            whether the precedence of the <i>left-hand side</i> of the "+" operator
            is above the <i>right-hand side</i> of the "=" operator. The fact that
            there is a "??" later on is irrelevant. In contrast, when printing the 
            expression "b + c", both sides of the "+" operator and both sides of the 
            context must be considered. The right-hand side is relevant because if 
            the right-hand operator was "*" instead of "??", the following printout 
            would be wrong:
            <code>
                a = b + c * d   // actual syntax tree: a = @+(b, c) * d
            </code>
            The same reasoning applies to the left-hand side (imagine if "=" was 
            "*" instead.)
            <para/>
            So, naturally there are different methods for parsing and printing.
            For printing you can use <see cref="M:Loyc.Syntax.Precedence.CanAppearIn(Loyc.Syntax.Precedence)"/>, <see cref="M:Loyc.Syntax.Precedence.LeftContext(Loyc.Syntax.Precedence)"/> and <see cref="M:Loyc.Syntax.Precedence.RightContext(Loyc.Syntax.Precedence)"/>, while for parsing you 
            only need <see cref="M:Loyc.Syntax.Precedence.CanParse(Loyc.Syntax.Precedence)"/> (to raise the precedence floor, simply
            replace the current <see cref="T:Loyc.Syntax.Precedence"/> value with that of the new 
            operator). In a parser, the "current" precedence is represented by 
            <see cref="F:Loyc.Syntax.Precedence.Right"/>; the value of <see cref="F:Loyc.Syntax.Precedence.Left"/> doesn't matter.
            <para/>
            Both printers and parsers can use <see cref="M:Loyc.Syntax.Precedence.CanMixWith(Loyc.Syntax.Precedence)"/>.
            
            <h3>Miscibility (mixability)</h3>
            
            <see cref="F:Loyc.Syntax.Precedence.Lo"/> and <see cref="F:Loyc.Syntax.Precedence.Hi"/> don't affect how operators are
            parsed into a tree, but are used to request a warning or error if operators
            are mixed improperly. If one operator's range overlaps another AND (the 
            ranges are not equal OR <c>Lo &gt; Hi</c>), then the two operators are 
            immiscible. For example, == and != have the same precedence in EC#, 38..39, 
            so they can be mixed with each other, but they cannot be mixed with &amp; 
            which has the overlapping range 32..45 (this will be explained below.)
            Normally Lo and Hi are set to <c>Min(Left,Right)</c> and <c>Max(Left,Right)</c>
            respectively, but this is not required--in particular, any pair where
            <c>Lo &gt; Hi</c> is used to indicate that the operator cannot be mixed with 
            other operators of the same precedence, even though it can (perhaps) be 
            mixed with others of different precedence. This is called non-associativity. 
            For example, in PHP are not allowed to write an expression such as 
            <c>x &gt; y &gt;= z</c>; to represent this, operators <c>&gt;</c> and <c>&gt;=</c> 
            should make <c>Lo &gt; Hi</c>.
            <para/>
            Certain operators should not be mixed because their precedence was originally 
            chosen incorrectly, e.g. x &amp; 3 == 1 should be parsed (x &amp; 3) == 1 but is 
            actually parsed x &amp; (3 == 1). To allow the precedence to be repaired 
            eventually, expressions like x &amp; y == z are deprecated in EC#: the parser will 
            warn you if you have mixed operators improperly. PrecedenceRange describes 
            both precedence and miscibility with a simple range of integers. As mentioned
            before, two operators are immiscible if their ranges overlap but are not 
            identical.
            <para/>
            In LES, the precedence range feature (a.k.a. immiscibility) is also used to 
            indicate that a specific precedence has not been chosen for an operator. 
            If a precedence is chosen in the future, it will be somewhere within the 
            range.
            
            <h3>Overall Range</h3>
            
            By convention, precedence scales range from 0 to 100 (or slightly higher).
            The precedence numbers are stored in this structure as <c>sbyte</c>s, so 
            <c>Left</c>, <c>Right</c>, <c>Lo</c>, and <c>Hi</c> must be between -128 
            and 127.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Precedence.#ctor(System.Int32)">
            <summary>Initializes a left-associative operator with the specified precedence.</summary>
        </member>
        <member name="M:Loyc.Syntax.Precedence.#ctor(System.Int32,System.Int32)">
            <summary>Initializes an operator with different precedence on the left 
            and right sides. For a right associative operator, conventionally 
            <c>right = left-1</c>.</summary>
        </member>
        <member name="M:Loyc.Syntax.Precedence.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Initializes an operator with the given precedence on the
            left and right sides, and the given immiscibility range (see 
            documentation of this type).</summary>
        </member>
        <member name="F:Loyc.Syntax.Precedence.Lo">
            <summary>Lo and Hi specify the miscibility of an operator; see the 
            remarks of <see cref="T:Loyc.Syntax.Precedence"/> for details.</summary>
        </member>
        <member name="F:Loyc.Syntax.Precedence.Hi">
            <summary>Lo and Hi specify the miscibility of an operator; see the 
            remarks of <see cref="T:Loyc.Syntax.Precedence"/> for details.</summary>
        </member>
        <member name="F:Loyc.Syntax.Precedence.Left">
            <summary>Left and Right denote the precedence level on the left and 
            right sides of an operator; see the remarks of <see cref="T:Loyc.Syntax.Precedence"/> 
            for details.</summary>
        </member>
        <member name="F:Loyc.Syntax.Precedence.Right">
            <summary>Left and Right denote the precedence level on the left and 
            right sides of an operator; see the remarks of <see cref="T:Loyc.Syntax.Precedence"/> 
            for details.</summary>
        </member>
        <member name="M:Loyc.Syntax.Precedence.LeftContext(Loyc.Syntax.Precedence)">
            <summary>For use in printers. Auto-raises the precedence floor to 
            prepare to print an expression on the left side of an operator.</summary>
            <param name="outerContext"></param>
            <returns></returns>
        </member>
        <member name="M:Loyc.Syntax.Precedence.RightContext(Loyc.Syntax.Precedence)">
            <summary>For use in printers. Auto-raises the precedence floor to 
            prepare to print an expression on the right side of an operator.</summary>
            <param name="outerContext">Context in which this operator is being printed</param>
            <returns></returns>
        </member>
        <member name="M:Loyc.Syntax.Precedence.CanAppearIn(Loyc.Syntax.Precedence)">
            <summary>For use in printers. Returns true if an infix operator 
            with this precedence can appear in the specified context.</summary>
            <remarks>Miscibility must be checked separately (<see cref="M:Loyc.Syntax.Precedence.CanMixWith(Loyc.Syntax.Precedence)"/>).</remarks>
        </member>
        <member name="M:Loyc.Syntax.Precedence.CanAppearIn(Loyc.Syntax.Precedence,System.Boolean)">
            <summary>For use in printers. Returns true if a prefix operator with 
            this precedence can appear in the specified context's right-hand 
            precedence floor (ignoring miscibility).</summary>
            <remarks>It is assumed that the left side of a prefix operator has 
            "infinite" precedence so only the right side is checked. This rule is 
            used by the EC# printer but may not be needed or allowed in all 
            languages (if in doubt, set prefix=false).</remarks>
        </member>
        <member name="M:Loyc.Syntax.Precedence.CanMixWith(Loyc.Syntax.Precedence)">
            <summary>Returns true if an operator with this precedence is miscible
            without parenthesis with the specified other operator.</summary>
            <remarks><see cref="M:Loyc.Syntax.Precedence.CanAppearIn(Loyc.Syntax.Precedence)"/> is for parsability, 
            this method is to detect a deprecated or undefined mixing of operators.
            </remarks>
        </member>
        <member name="M:Loyc.Syntax.Precedence.CanParse(Loyc.Syntax.Precedence)">
            <summary>For use in parsers. Returns true if 'rightOp', an operator
            on the right, has higher precedence than the current operator 'this'.</summary>
            <returns><c>rightOp.Left > this.Right</c></returns>
        </member>
        <member name="P:Loyc.Syntax.Precedence.IsRightAssociative">
            <summary>Returns true if this object represents a right-associative 
            operator such as equals (x = (y = z)), in contrast to left-
            associative operators such as division ((x / y) / z).</summary>
        </member>
        <member name="T:Loyc.Syntax.EmptySourceFile">
            <summary>
            A dummy implementation of ISourceFile that has only a filename, no source text.
            Used as the source file of synthetic syntax nodes.
            </summary>
        </member>
        <member name="T:Loyc.Syntax.IndexPositionMapper">
            <summary>Synonym for <c>IndexPositionMapper&lt;IListSource&lt;char>></c>.</summary>
        </member>
        <member name="T:Loyc.Syntax.SourceFileWithLineRemaps">
            <summary>An wrapper around ISourceFile that applies line remapping 
            information (if the source file uses it).</summary>
            <remarks>
            A preprocessor that supports #line may wrap the original <see cref="T:Loyc.Syntax.ISourceFile"/> in one of these, even when the source file 
            doesn't use #line.
            <para/>
            Call Remaps.AddRemap() and, optionally, Remaps.EndRemap(), to add each
            mapping.
            <para/>
            <see cref="T:Loyc.Syntax.ISourceFile"/> includes <see cref="T:Loyc.Syntax.IIndexPositionMapper"/>
            which allows reverse-mapping from line/position back to index. However,
            a position derived from #line information may be ambiguous (does not 
            always have a unique reverse mapping), and I'd rather avoid the work of 
            reverse mapping anyway. So this class does not perform reverse mapping,
            but forward mappings return <see cref="T:Loyc.Syntax.SourcePosAndIndex"/> which are
            automatically recognized by <see cref="M:Loyc.Syntax.SourceFileWithLineRemaps.LineToIndex(System.Int32)"/> which thereby 
            recovers the original index.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.LineRemapper">
            <summary>A small helper class for languages such as C# and C++ that permit 
            the locations reported by error messages to be remapped. This class stores
            and applies such commands (#line in C#/C++)</summary>
            <remarks>
            This is part of <see cref="T:Loyc.Syntax.SourceFileWithLineRemaps"/>.
            One LineRemapper should be created per real source file.</remarks>
        </member>
        <member name="M:Loyc.Syntax.LineRemapper.AddRemap(System.Int32,System.Int32,System.String)">
            <summary>Adds a mapping that starts on the specified real line.</summary>
            <remarks>In C++ and C#, a directive like "#line 200" affects the line 
            after the preprocessor directive. So if "#line 200" is on line 10, 
            you'd call AddRemap(11, 200) or possibly AddRemap(10, 199).</remarks>
        </member>
        <member name="M:Loyc.Syntax.LineRemapper.EndRemap(System.Int32)">
            <summary>Corresponds to <c>#line default</c> in C#.</summary>
        </member>
        <member name="M:Loyc.Syntax.LineRemapper.Remap(System.Int32@,System.String@)">
            <summary>Remaps the specified line number, if a remapping has been created that applies to it.</summary>
            <param name="line">On entry, a real line number. On exit, a remapped line number</param>
            <param name="fileName">This is changed to the user-specified file name 
            string, if and only if a file-name remapping exists and applies here.</param>
            <returns>true if a remapping exists and was applied, false if not.</returns>
        </member>
        <member name="T:Loyc.Syntax.LineAndPos">
            <summary>Holds a line number (Line) and a position in the line (PosInLine).
            This class isn't really needed in Loyc but is separated from SourcePos 
            in case anyone might want position without a filename.</summary>
            <remarks>Numbering starts at one for both numbers. Line=0 signifies 
            nowhere in particular.</remarks>
        </member>
        <member name="T:Loyc.Syntax.SourcePos">
            <summary>Holds a filename (FileName), a line number (Line) and a position in 
            the line (PosInLine), representing a position in a source code file.</summary>
            <remarks>
            Line and column numbering both start at one (1). Line=0 signifies nowhere 
            in particular. Instances are immutable.
            </remarks>
        </member>
        <member name="T:Loyc.Syntax.SourcePosAndIndex">
            <summary>A <see cref="T:Loyc.Syntax.SourcePos"/> that also includes the original index 
            from which the Line and PosInLine were derived.</summary>
        </member>
        <member name="T:Loyc.Syntax.SourceRange">
            <summary>
            Holds a reference to a source file (ISourceFile&lt;char&gt;) and the
            beginning and end indices of a range in that file.
            </summary>
        </member>
        <member name="T:Loyc.Syntax.StreamCharSource">
            <summary>
            Exposes a stream as an ICharSource, as though it were an array of 
            characters. The stream must support seeking, and if a text decoder 
            is specified, it must meet certain constraints.
            </summary><remarks>
            This class reads small blocks of bytes from a stream, reloading 
            blocks from the stream when necessary. Data is cached with a pair 
            of character buffers, and a third buffer is used to read from the
            stream. A Stream is required rather than a TextReader because
            TextReader doesn't support seeking.
            <para/>
            This class assumes the underlying stream never changes.
            <para/>
            The stream does not (and probably cannot, if I understand the 
            System.Text.Decoder API correctly) save the decoder state at each block 
            boundary. Consequently, only encodings that meet special constraints
            will work with StreamCharSource. These include Encoding.Unicode,
            Encoding.UTF8, and Encoding.UTF32, but not Encoding.UTF7. Using 
            unsupported encodings will cause exceptions and/or or corrupted data 
            output while reading from the StreamCharSource.
            <para/>
            The decoder must meet the following constraints:
            1. Characters must be divided on a byte boundary. UTF-7 doesn't work 
               because some characters are encoded using Base64.
            2. Between characters output by the decoder, the decoder must be 
               stateless. Therefore, encodings that support compression generally 
               won't work.
            3. The decoder must produce at least one character from a group of 
               8 bytes (StreamCharSource.MaxSeqSize).
            </remarks>
        </member>
        <member name="F:Loyc.Syntax.StreamCharSource._blkOffsets">
            <summary>A sorted list of mappings between byte positions and character 
            indexes. In each Pair(of A,B), A is the character index and B is the byte 
            index. This list is built on-demand.
            </summary>
        </member>
        <member name="F:Loyc.Syntax.StreamCharSource._reachedEnd">
            <summary>Set true when the last block has been scanned. If true, then
            _eofIndex and _eofPosition indicate the Count and the size of the 
            stream, respectively.</summary>
        </member>
        <member name="F:Loyc.Syntax.StreamCharSource._eofIndex">
            <summary>_eofIndex is the character index of EOF if it has been reached 
            or, if not, the index of the first unscanned character. _eofIndex 
            equals _blkOffsets[_blkOffsets.Count-1].A.</summary>
        </member>
        <member name="F:Loyc.Syntax.StreamCharSource._eofPosition">
            <summary>_eofPosition is the byte position of EOF if it has been reached 
            or, if not, the position of the first unscanned character. _eofPosition 
            equals _blkOffsets[_blkOffsets.Count-1].B.</summary>
        </member>
    </members>
</doc>
